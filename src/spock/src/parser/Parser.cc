/*
 * ISC License
 *
 * Copyright (C) 2000-2018 by
 *	Xander Burgerhout
 *	Simon de Graaf
 *	N.P. van der Meijs
 * Delft University of Technology
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// Qt includes
#include <qobject.h>
#include <qregexp.h>
#include <qmessagebox.h>

#include <stdlib.h>

// STL includes
#include <string>
#include <vector>
#include <sstream>
#include <iostream>

using namespace std;

// Project includes
#include "src/spock/src/parser/Parser.h"
#include "src/spock/src/datastruct/Component.h"
#include "src/spock/src/datastruct/ComponentTree.h"
#include "src/spock/src/datastruct/Generator.h"
#include "src/spock/src/datastruct/Visitors.h"
#include "src/spock/src/helper/log/Helper.h"
#include "src/spock/src/datastruct/Keywords.h"

// This is from the parser generated by bison and flex.
extern int yylineno;

// Static member initialization
CParser* CParser::m_singleton = 0;

//============================================================================
//! Default constructor
/*!
    The constructor creates objects for the component tree, the generator tree
    and the tree used internally by the parser, the m_allComps component tree.
  */
CParser::CParser()
{
    m_versionMajor = 1;
    m_versionMinor = 1;
    m_currentValMap = 0;
    m_allComps      = new CComponentTree("");   // All types can be root
    m_componentTree = new CComponentTree();     // Only tabpages can be root
    m_generatorTree = new CGenerators();

    m_propertiesToDisambiguate.push_back(PROP_DATASOURCE);
}

//============================================================================
//! Returns the (singleton) CParser object.
/*!
    This class is implemented as a singleton. Only one instance of the CParser
    class is allowed.
    If the CParser object had not yet been created it is created.

    \return The one and only instance of the CParser class.
    Should never return 0.
*/
CParser* CParser::instance()
{
    if (m_singleton == 0)
        m_singleton = new CParser();
    return m_singleton;
}

//============================================================================
//! Set the version number of the configuration file.
/*!
    \param major    the major version number
    \param minor    the minor version number

    The versioning system is currently unused. These mechanisms are only
    implemented for future versions.
 */
void CParser::setVersion(int major, int minor)
{
    m_versionMajor = major;
    m_versionMinor = minor;
}

//============================================================================
//! Returns the major version number of the configuration file.
/*!
    \return The major version number of the configuration file.
    The versioning system is currently unused. These mechanisms are only
    implemented for future versions.
*/
int CParser::getMajorVersion()
{
    return m_versionMajor;
}

//============================================================================
//! Returns the minor version number of the configuration file.
/*!
    \return The minor version number of the configuration file.
    The versioning system is currently unused. These mechanisms are only
    implemented for future versions.
*/
int CParser::getMinorVersion()
{
    return m_versionMinor;
}

//============================================================================
//! Adds a component to the componet tree
/*!
    \param component Compononent to add.

    \sa addDefine(), addGeneratorComp().
 */
void CParser::addComponent(CComponent* component)
{
    if (component != 0) {
        string rootType = m_componentTree->getRootType();
        if (component->getType() == rootType)
            m_componentTree->addRootComponent(component);
        m_allComps->addRootComponent(component);
    }
}

//============================================================================
//! Adds a component to the definitons list
/*!
    \param def  Component to add as a definition

    If the component was already present as a definition it is ignored.
    This ensures the list of definition does not contain any duplicates.

    \sa addComponent(), addGeneratorComp().
 */
void CParser::addDefine(CComponent* def)
{
    if (def != 0) {
        bool found = false;
        for (unsigned int i=0; i<m_defines.size() && found==false; ++i) {
            if (m_defines[i] == def)
                found = true;
        }
        if (found == false)
            m_defines.push_back(def);
    }
}

//============================================================================
//! Adds a generator component to the generator tree.
/*!
    \param gen  The CGeneratorComp component to add.
    \sa addComponent(), addDefine(), CGeneneratorComp.
 */
void CParser::addGeneratorComp(CGeneratorComp* gen)
{
    if (gen != 0)
        m_generatorTree->addGeneratorComp(gen);
}

//============================================================================
//! Creates a new component and pushes it on the stack.
/*!
    The parser generated by bison uses the stack to find the current component
    and edit this component as necessary.

    \return The newly created component.
    \sa push(), pop(), currentComp(), currentParent().
  */
CComponent* CParser::newComp()
{
    CComponent* comp = new CComponent(currentComp());
    push(comp);
    return comp;
}

//============================================================================
//! Pushes a component on the stack.
/*!
    The parser generated by bison uses the stack to find the current component
    and edit this component as necessary.

    \sa newComp(), pop(), currentComp(), currentParent().
 */
void CParser::push(CComponent* comp)
{
    m_componentStack.push_back(comp);
}

//============================================================================
//! Pops and returns the top of the component stack
/*!
    The parser generated by bison uses the stack to find the current component
    and edit this component as necessary.

    \sa newComp(), pop(), currentComp(), currentParent().

    \return The popped component or 0 if the stack was empty.
*/
CComponent* CParser::pop()
{
    CComponent* comp = 0;

    if (m_componentStack.size()>0) {
        comp = m_componentStack.back();
        m_componentStack.pop_back();
    }
    return comp;
}

//============================================================================
//! Returns the parent of the current component.
/*!
    \return The parent of the current component. Returns 0 if there was no
    parent or if the stack was empty.

    The parser generated by bison uses the stack to find the current component
    and edit this component as necessary.

    \sa currentComp(), push(), pop(), newComp().
 */
CComponent* CParser::currentParent()
{
    if (m_componentStack.size()>1)
        return m_componentStack[m_componentStack.size()-2];
    return 0;
}

//============================================================================
//! Returns the component at the top of the stack, without popping.
/*!
    The parser generated by bison uses the stack to find the current component
    and edit this component as necessary.

    There should always be a current component. If we assume this is the case
    we will not have to do a sanity check each time we want a component.

    Before calling this method, a component must be placed on the stack with
    either push() or newComp().

    If the stack is empty, this method will assert.

    \return The component at the top of the stack. The value remains on the stack.

    \sa newComp(), push(), pop(), currentParent().
 */
CComponent* CParser::currentComp()
{
    if (m_componentStack.size()>0)
        return m_componentStack.back();

    ASSERT(true);   // There must always be a current component.
    return 0;       // You should have called newComp() first.
}

//============================================================================
//! Maps location of the declaration in the configuration file to this component.
/*!
    To generate correct error line numbers (especially during disambiguation)
    the line number of the declaration of a component is stored for later use.

    \param comp Component to set line number of.

    If \a comp is 0, the current component is used.

    The line number is retrieved from yylineno which is kept up to date by the
    parser generated with bison.
 */
void CParser::setLineNumber(CComponent* comp)
{
    if (comp == 0) comp = currentComp();
    m_declarations[comp] = yylineno;
}

//============================================================================
//! Disambiguates a (partial) component name.
/*!
    \param src The (partial) component name.
    \param context The optional context to use.

    If the partial name \a src is ambiguous the parser will stop with an
    error. The full name of all candidates is displayed with the line
    number of where they are declared.

    If the name \a was not found at all an error is also generated. The error
    message displays the line number of the possible typo.

    \return The disambiguated full context name if succesful. Exits with an
          error otherwise.

    \sa setLineNumber()
 */
string CParser::disambiguate(const string& src, const string context)
{
    string source;
    if (context != "")
        source = context + "." + src;
    else
        source = src;

    CFindComponentVisitor found("");
    found = m_allComps->search(source);
    if (found.hitCount() > 1) {
        debug("Ambigious identifier found!");
        ostringstream err;
        err << "Ambigous '" << source << "' (line " << yylineno << ")" << endl;
        err << "Could be any of these:" << endl;
        for (int i=0; i<found.hitCount(); ++i) {
            CComponent* comp = found.getHit(i);
            int line = m_declarations[comp];
            err << "line " << line << ": '" << comp->getFullContextName() << endl;
        }
        err << ends;
        parseError(err.str());
        displayErrorAndExit();
    }
    if (found.hitCount() == 0 && source != KEY_APPLICATION) {

        for (unsigned int i=0; i<m_defines.size(); ++i) {
            if (source == m_defines[i]->getName())
                return source;
        }

        // Whoops! Really didn't find anything appropriate...."
        ostringstream err;
        err << "Don't know any '" << source << "'. Possible typo?" << ends;
        err << "(line " << yylineno << ")";
        err << ends;
        parseError(err.str());
        displayErrorAndExit();
    }

    string result = found.getHit()->getFullContextName();

//    debug("Disambiguating %s...result = %s", source.c_str(), result.c_str());
    return result;
}

//============================================================================
//! currently unused.
string CParser::disambiguate(const string& src, CComponent*)
{
    return disambiguate(src);
}

//============================================================================
//! currently unused.
void CParser::disambiguateDataSources()
{
    /*
    string src;
    debug("CParser::disambiguateDataSources()");
    for (unsigned int prop = 0; prop<m_propertiesToDisambiguate.size(); ++prop) {
        string property = m_propertiesToDisambiguate[prop];
        debug("   checking for %s", property.c_str());
        for (unsigned int i=0; i<m_defines.size(); ++i) {
	    if (m_defines[i]->getProp(property, src)) {
                string full = disambiguate(src, m_defines[i]);
                debug("Resetting adddatafrom property to %s", full.c_str());
                m_defines[i]->setProperty(property, full);
            }
        }
        for (unsigned int i=0; i<m_components.size(); ++i) {
	    if (m_components[i]->getProp(property, src)) {
                string full = disambiguate(src, m_components[i]);
                debug("Resetting adddatafrom property to %s", full.c_str());
                m_components[i]->setProperty(property, full);
            }
        }
    }*/
}

//============================================================================
//! Maps an iterator variable to the component being iterated
/*!
    \param iterName Name of the iterator variable
    \param compName Name of the component being iterated

    \sa unmapForEachIterator(), getMappedIterator()
*/
void CParser::mapForEachIterator(const string& iterName, const string& compName)
{
    m_forEachIterMap[iterName] = compName;
}

//============================================================================
//! Unmaps a mapped iterator variable.
/*!
    \param iterName Name of the iterator to unmap.

    After calling this method, there will no longer be a connection between
    the iterator named \a iterName and the component that was being iterated.

    \sa mapForEachIterator(), getMappedIterator()
 */
void CParser::unmapForEachIterator(const string& iterName)
{
    map<string, string>::iterator pos;
    pos = m_forEachIterMap.find(iterName);
    if (pos != m_forEachIterMap.end())
        m_forEachIterMap.erase(pos);
}

//============================================================================
//! Returns the component being iterated by \a iter.
/*!
    \param iter Name of the iterator variable.

    \return The component being iterated by \a iter.

    \sa mapForEachIterator(), unmapForEachIterator()
*/
string CParser::getMappedIterator(const string& iter)
{
    return m_forEachIterMap[iter];
}

//============================================================================
//! Adds \a errorTxt to the error report.
/*!
    \sa getErrorText(), displayErrorAndExit()
*/
void CParser::parseError(const string& errorTxt)
{
    m_parseErrors += errorTxt;
}

//============================================================================
//! Returns the current parse errors.
/*!
    \return The current parse errors.
    \sa displayErrorAndExit(), parseError()
 */
string CParser::getErrorText()
{
    return m_parseErrors;
}

//============================================================================
//! Displays the parse errors and exits the program.
/*!
    \sa getErrorText(), parseError()
 */
void CParser::displayErrorAndExit()
{
    QMessageBox::critical(0, "Error!", m_parseErrors.c_str());
    exit(-1);
}

//============================================================================
//! Copies the complete component tree
/*!
    The complete component tree is copied. This means a completely new tree
    is created in memory that is functionally equal to the tree created by the
    parser. It is an exact copy of this ``prototype'' tree.

    \return A copy of the prototype component tree created by the parser.

    \sa CComponentTree, CComponent, CComponentTree::copyComponentTree()
    \sa CComponentTree::copyComponentBranch()
  */
CComponentTree* CParser::copyComponentTree()
{
    return m_componentTree->copyComponentTree();
}

//============================================================================
//! Returns a pointer to the generators.
/*!
    \return A pointer to the generators.
    \sa CGeneratorComp, CGenerators
 */
CGenerators* CParser::getGenerators()
{
    return m_generatorTree;
}

//============================================================================
//! Finds a component named \a name.
/*!
    \param name Name of the component to find.

    The search takes place in the internal, unordered, component tree.
    This tree is used by the parser internally.

    \returns The component if found or 0 if unsuccesful.

    \sa CComponentTree::findComponent()
*/
CComponent* CParser::findComponent(const string& name)
{
    return m_allComps->findComponent(name);
}

void CParser::testComponent(const string& name)
{
    string tp = currentComp()->getType();
    if (tp == KEY_SPREADSHEET || tp == KEY_PARAMLIST) {
	CFindComponentVisitor find = m_allComps->search(name);
	for (int i=0; i<find.hitCount(); ++i) {
	    CComponent* c = find.getHit(i);
	    string ty = c->getType();
	    if (ty == KEY_SPREADSHEET || ty == KEY_PARAMLIST) {
		// debug("Non unique identifier found!");
		ostringstream err;
		err << "Non unique " << tp << " name '" << name;
		err << "' (line " << yylineno << ")" << endl;
		err << "Found " << ty << " fullname '" << c->getFullContextName();
		err << "' (line " << m_declarations[c] << ")" << ends;
		parseError(err.str());
		displayErrorAndExit();
	    }
	}
    }
}

//============================================================================
//! Adds \a src as a property value of the current property list.
/*!
    The parser maintains a temporary vector with the values of the current
    property being parsed. \a src is added to this list.

    \param src The property value to add.

    \sa clearPropertyList(), getPropertyList(), CComponent
 */
void CParser::addToPropertyList(const string& src)
{
    m_propertyList.push_back(src);
}

//============================================================================
//! Clears the values of the temporary property list.
/*!
    After the parser finished parsing a property, the temporary list containing
    the values of that property must be cleared. This method is then called.

    \sa getPropertyList(), addToPropertyList(), CComponent
*/
void CParser::clearPropertyList()
{
    m_propertyList.clear();
}

//============================================================================
//! Returns the values of the current property being parsed.
/*!
    \return The values of the current property being parsed.

    \sa addToPropertyList(), clearPropertyList(), CComponent
 */
vector<string> CParser::getPropertyList()
{
    return m_propertyList;
}

//============================================================================
//! Returns the current value map.
/*!
    \return Returns the current value map. If there is no current value map
    (that is the internal m_currentValMap is 0) a new value map is created.

    \sa CValueMap, newValueMap()
 */
CValueMap* CParser::getValueMap()
{
    if (m_currentValMap == 0)
        m_currentValMap = new CValueMap;

    return m_currentValMap;
}

//============================================================================
//! Creates a new value map.
/*!
    The new value map is also made the current map.

    \return The new value map
    \sa CValueMap, getValueMap().
 */
CValueMap* CParser::newValueMap()
{
    m_currentValMap = new CValueMap;
    return m_currentValMap;
}

//============================================================================
//! Sets the path used to expand icon file names.
/*!
    Icon locations in the configuration file are prepended with the path
    set in the ICONPATH variable. This method is called when the ICONPATH
    variable is parsed.

    \param src The path to use for the icons.
    \sa getIconPath()
 */
void CParser::setIconPath(const string& src)
{
    m_iconPath = src;
}

//============================================================================
//! Returns the path to prepend to icon locations.
/*!
    \return The path to prepend to icon locations.
    \sa setIconPath()
 */
string CParser::getIconPath()
{
    return m_iconPath;
}

//============================================================================
//! Creates a component(branch) from a define statement.
/*!
    If a defined type of component is encountered during parsing, this method
    copies the component branch of the defined component and returns this copy.

    The copied branch is glued to the component tree in the right spot, which
    is specified with \a parent.

    \param def      The defined type to use
    \param parent   The location in the tree to use for gluing the copied branch.

    \return A copy of the defined type.
*/
CComponent* CParser::createFromDefine(const string& def, CComponent* parent)
{
    CComponent* result = 0;
    CComponent* define = 0;
    for (unsigned int i=0; i<m_defines.size(); ++i) {
        if (m_defines[i]->getName() == def) {
            define = m_defines[i];
        }
    }
    if (define != 0) {
        result = m_componentTree->copyComponentBranch(define);
        if (parent != 0)
            parent->add(result);
    }
    return result;
}

//============================================================================
//! A debug method. Dumps the component tree
void CParser::dumpGlobals()
{
    m_componentTree->dump();
}

//============================================================================
//! A debug method. Dumps the current component stack.
void CParser::dumpStack()
{
    debug("Dump of the component stack:");
    for (unsigned int i=0; i<m_componentStack.size(); ++i) {
        unsigned int level = m_componentStack.size()-1-i;
        if (m_componentStack[i] != 0)
            debug("%2d: %p %s (type=%s)", level, m_componentStack[i], m_componentStack[i]->getName().c_str(),
                    m_componentStack[i]->getType().c_str());
        else
            debug("%2d: (null component)", level);
    }
}
