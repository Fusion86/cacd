/*
 * ISC License
 *
 * Copyright (C) 2000-2018 by
 *	Xander Burgerhout
 *	Simon de Graaf
 *	N.P. van der Meijs
 * Delft University of Technology
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// Qt includes
#include <qfiledialog.h>
#include <qmessagebox.h>
#include <qtabwidget.h>
#include <qframe.h>
#include <qlayout.h>
#include <qwidgetstack.h>
#include <qtabdialog.h>
#include <qmultilineedit.h>

// Project includes
#include "src/spock/src/gui/framework/ProcessManager.h"
#include "src/spock/src/guibuilder/GUITree.h"
#include "src/spock/src/datastruct/Component.h"
#include "src/spock/src/parser/Parser.h"
#include "src/spock/src/datastruct/Keywords.h"
#include "src/spock/src/guibuilder/Process.h"
#include "src/spock/src/guibuilder/GUIBuilderVisitor.h"

// STL includes.
#include <string>
#include <sstream>
#include <iostream>
#include <algorithm>

using namespace std;

// Yacc/Bison generated parser.
extern int yylineno;
extern FILE* yyin;
extern int yyparse( void );
extern int nr_of_yyerrors;

//////////////////////////////////////////////////////////////////////////////

CProcessManager* CProcessManager::m_singleton = 0;

//============================================================================
//! Constructor.
/*!
    The constructor runs the parser that parses the configuration file.
    After that, it intializes the QWidgetStack widget by calling the setupWidgets()
    method.
 */
CProcessManager::CProcessManager()
{
    runParser();
    setupWidgets();
}

//============================================================================
//! Returns a pointer to the only CProcessManager object.
/*!
    This class has been made a singleton class to allow easy access. It is also
    conceptually correct, since there should be only one process manager.

    \return The process manager.
 */
CProcessManager* CProcessManager::instance()
{
    if (m_singleton == 0)
        m_singleton = new CProcessManager;
    return m_singleton;
}

//============================================================================
//! Runs the parser generated by yacc/bison that parses the configuration file.
/*!
    The configuration file is searched for in the applications startup path
    if not found there in the ICDPATH/share/lib/spock path. The configuration file
    is named spock.uis.

    If any errors are encountered during parsing, the errors are displayed and
    the application will exit.
 */
void CProcessManager::runParser()
{
    yyin = 0;

    // Search paths.
    vector<string> location;
    location.push_back(".");
    char* icdpath = getenv("ICDPATH");
    if (icdpath == 0 || icdpath == NULL) {
        cout << "WARNING: could not find the ICDPATH environment variable.\n";
    } else {
	string tmp = icdpath;
	tmp += "/share/lib/spock";
	location.push_back(tmp);
    }

    int i=0;
    while (yyin == 0 && (unsigned)i<location.size()) {
        string filename = location[i] + "/spock.uis";
        yyin = fopen(filename.c_str(), "r");
        if (yyin != 0 && yyin != NULL) {
	    fprintf(stderr, "Please wait!\nParsing %s\n", filename.c_str());
	    yylineno = 1;
            yyparse();
	    fprintf(stderr, "\nParsing done!\n");
            fclose(yyin);
        }
        i++;
    }
    if (yyin == 0 || yyin == NULL) {
        cout << "Could not open the user interface/generator specification file.\n"
             << "The file is named spock.uis and it could not be found or opened. The searchpath is:\n";
        for (unsigned int i=0; i<location.size(); ++i)
            cout << location[i] << endl;
        exit(-1);
    }

    if (nr_of_yyerrors>0)
        CParser::instance()->displayErrorAndExit();

    CParser::instance()->disambiguateDataSources();
}

//============================================================================
//!  Sets up the widget stack.
/*!
    The widget stack represent the open processes. Each widget in the widget
    stack is an open process. The top of the stack is the current process.
 */
void CProcessManager::setupWidgets()
{
    m_stack = new QWidgetStack(0, "The widgetstack");
    m_lastTabWidgetID = 0;
}

//============================================================================
//! A tabwidget is created for each process.
/*!
    The created tabwidget is places in the widget stack representing the
    open processes.

    \param proc The process to create a tabwidget for.

    \return The created tabwidget.

    \sa createTabPages().
 */
QTabWidget* CProcessManager::createTabWidget(CProcess* proc)
{
    if (proc == 0)
        return 0;

    QTabWidget* tab = new QTabWidget(m_stack, "tabwidget");
    tab->setTabPosition(QTabWidget::Bottom);

    m_lastTabWidgetID++;
    m_stack->addWidget(tab, m_lastTabWidgetID);
    m_processTabs[proc] = tab;
    createTabPages(proc);

    return tab;
}

//============================================================================
//! Creates the tabpages in a tabwidget.
/*!
    Each tabwidget representing a process contains tabpages. The tabpages are
    specified in the configuration file and can be retrieved from the
    gui tree object associated with the process \a proc.

    \param proc The process to create tabpages for.
 */
void CProcessManager::createTabPages(CProcess* proc)
{
    ASSERT(proc != 0);

    CGUITree* guiTree = proc->guiTree();
    QTabWidget* tab = m_processTabs[proc];
    ASSERT(tab != 0);
    ASSERT(guiTree != 0);

    vector<QWidget*> pages = guiTree->getTabPages();

    tab->hide(); // Prevents screen flicker in some cases.
    for (int i=0; (unsigned)i<pages.size(); ++i) {
        string title = guiTree->getComponent(pages[i])->getProperty(PROP_TITLE);
        pages[i]->resize(tab->width(), tab->height());
        tab->addTab(pages[i], title.c_str());
    }
    tab->show();
}

//============================================================================
//! Returns a pointer to the widget stack.
/*!
    \return A pointer to the widget stack.
 */
QWidgetStack* CProcessManager::getWidgetStack()
{
    return m_stack;
}

//============================================================================
//! Returns the current active process.
/*!
    The current active process is determined by analyzing the top of the widget
    stack.

    \return The current active process.
 */
CProcess* CProcessManager::currentProcess()
{
    QWidget* top = m_stack->visibleWidget();
    map<CProcess*, QTabWidget*>::iterator pos;
    if (top) {
	pos = m_processTabs.begin();
	while (pos != m_processTabs.end()) {
	    if (pos->second == top)
		return pos->first;
	    ++pos;
	}
    }
    pos = m_processTabs.begin();
    if (pos != m_processTabs.end()) return pos->first;
    return 0;
}

//============================================================================
//! Creates a new process.
/*!
    A new process named \a name is created. This means
    a new CProcess object is created as well as a CGUITree containing the
    user interface belonging to the new process.

    \param name The name of the new process.

    \sa CProcess, CGUITree

    \return A pointer to the new process.
 */
CProcess* CProcessManager::newProcess(const string& name)
{
    CProcess* newProcess = new CProcess;

    int nr = 0;
    string findname = name;
    while(getProcess(findname) != 0) {
        nr++;
        ostringstream buf;
        buf << name << nr << ends;
        findname = buf.str();
    }

    newProcess->setName(findname);
    debug("Creating tabwidget for %s", findname.c_str());

    CGUIBuilderVisitor builder;
    CComponentTree* compTree = CParser::instance()->copyComponentTree();
    newProcess->setGUITree(builder.buildGUI(compTree));

    createTabWidget(newProcess);
    activateProcess(newProcess);

    return newProcess;
}

//============================================================================
//! Activates the process \a proc.
/*!
    \param proc The process to activate.

    The activated process will be made the current process and the user interface
    displayed will be the user interface associated with the activated process.
 */
void CProcessManager::activateProcess(CProcess* proc)
{
    if (m_processTabs.count(proc) > 0) {
        QTabWidget* tab = m_processTabs[proc];
        if (tab != 0)
            m_stack->raiseWidget(tab);
    }
}

//============================================================================
//! Returns a vector containing the currently loaded processes.
/*!
    \return A vector containing the currently loaded processes.
 */
vector<string> CProcessManager::getProcessNames()
{
    vector<string> retval;

    map<CProcess*, QTabWidget*>::iterator pos;

    for (pos = m_processTabs.begin(); pos != m_processTabs.end(); ++pos)
        retval.push_back(pos->first->getName());
    return retval;
}

//============================================================================
//! Returns a pointer to the process named \a name.
/*!
    \return A pointer to the process named \a name.
 */
CProcess* CProcessManager::getProcess(const string& name)
{
    map<CProcess*, QTabWidget*>::iterator pos;

    for (pos = m_processTabs.begin(); pos != m_processTabs.end(); ++pos)
        if (pos->first->getName() == name)
            return pos->first;
    return 0;
}

//============================================================================
//! Removes the specified process.
void CProcessManager::removeProcess(CProcess* proc)
{
    map<CProcess*, QTabWidget*>::iterator pos;

    pos = m_processTabs.find(proc);
    if (pos != m_processTabs.end()) {
        m_stack->removeWidget(pos->second);
        delete pos->first;
        delete pos->second;
        m_processTabs.erase(pos);
    }
}

//============================================================================
//! Returns true of a process named \a name is already loaded.
/*!
    \return True of a process named \a name is already loaded.
    False otherwise.
 */
bool CProcessManager::isLoaded(const string& name)
{
    if (getProcess(name) == 0)
        return false;
    return true;
}

//============================================================================
//! Saves the process \a proc.
void CProcessManager::saveProcess(CProcess* proc)
{
    ASSERT(proc != 0);
    fprintf(stderr, "Saving %s\n", proc->getFileName().c_str());
    //debug("Saving %s", proc->getFileName().c_str());
    proc->save();
}

//============================================================================
//! Loads the process in the file \a fileName.
/*!
    The loaded process is activated after loading.

    \sa saveProcess, CProcess::load()
  */
void CProcessManager::loadProcess(const string& fileName)
{
    fprintf(stderr, "Loading %s\n", fileName.c_str());
    //debug("Loading %s", fileName.c_str());

    CProcess* cproc = currentProcess();
    CProcess* proc = newProcess();

    proc->setFileName(fileName);
    if (!proc->load()) {
	removeProcess(proc);
	if (cproc) activateProcess(cproc);
	return;
    }
    string name = proc->getName();
    if (getProcess(name)!= proc && getProcess(name) != 0) {
        string mess = "A process named " + name + " is already\n"
                      "being edited. Do you wish to close that process\n"
                      "(losing any changes made) and open this one instead?";
        int res = QMessageBox::information(0, "Lose changes?", mess.c_str(),
                                "Yes, continue loading", "No, stop loading");
        if (res == 0) {
            removeProcess(getProcess(name));
        } else {
            removeProcess(proc);
            activateProcess(getProcess(name));
        }
    }
}

//============================================================================
//! Generates all technology files for process \a proc.
void CProcessManager::generateAllFiles(CProcess* proc)
{
    ASSERT(proc != 0);
    map<string, string> results = proc->generateAllFiles();

    QTabDialog* genResults = new QTabDialog(0, 0, true);

    map<string, string>::iterator pos;
    for (pos = results.begin(); pos != results.end(); ++pos) {
        QMultiLineEdit* edit = new QMultiLineEdit(genResults);
        edit->setFont(QFont("Courier", 10));
        genResults->addTab(edit, pos->first.c_str());
        edit->setText(pos->second.c_str());
    }
    genResults->resize(800, 600);
    genResults->exec();
    delete genResults;
}

//============================================================================
//! Generates a technology file into \a result.
/*!
    \param generatorTitle The name of the generator as specified in the
    configuration file.
    \param result The result of the generation algorithm.

    \sa CProcess::generateFile(), CProcess.
 */
void CProcessManager::generateFile(const string& generatorTitle, string& result)
{
    if (currentProcess() != 0)
        currentProcess()->generateFile(generatorTitle, result);
}
