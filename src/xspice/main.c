
/*
 * ISC License
 *
 * Copyright (C) 1987-2016 by
 *	Arjan van Genderen
 *	Peter Elias
 *	Sander de Graaf
 *	Simon de Graaf
 *	Nick van der Meijs
 * Delft University of Technology
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <time.h>
#include "src/xspice/incl.h"

#define TOOLVERSION "3.08 23-May-2016"

#ifdef XSPECTRE
char *argv0 = "xspectre";
char *use_msg = "\nUsage: %s [-NTdfghikonptuvxy -w width -z name -C file -D name -F outfile -O name -S stimfile -X lib] cell\n\n";
#else
#ifdef XPSTAR
char *argv0 = "xpstar";
char *use_msg = "\nUsage: %s [-NPQdfghikmnptuvxy -w width -z name -C file -D name -F outfile -O name -S stimfile -X lib] cell\n\n";
#else
char *argv0 = "xspice";
char *use_msg = "\nUsage: %s [-EHLNPRTadfghikonptuvxy -w width -z name -C file -D name -F outfile -O name -S stimfile -X lib] cell\n\n";
#endif
#endif

extern struct model_info *Netws;
extern struct model_info *Devs, *mlast;
extern struct model_info *Funcs;
extern struct model_info *preFuncs, *flast; /* predefined functions */

DM_PROJECT *dmproject = NULL;

FILE *fp_out;
long *Nil = NULL;
int tanner = 0;
int maxLL = -1; /* maximum output line length */
int use_Pmodels = 0;
int use_Qmodels = 0;
int tog_nodnbr = 0;
int use_include = 0;

#ifdef XSPECTRE
int dialect = SPECTRE;
int add_comma = 0; /* add comma? */
int add_paren = 1; /* add parentheses (around nodes) */
int incl_model = 2;
int listnames = 0;
#else
#ifdef XPSTAR
int dialect = PSTAR;
int add_comma = 1; /* add comma (between nodes) */
int add_paren = 1; /* add parentheses (around nodes) */
int incl_model = 0;
int listnames = 0;
#else
int dialect = SPICE;
int add_comma = 0; /* add comma? */
int add_paren = 0; /* add parentheses? */
int incl_model = 2;
int listnames = 1;
#endif
#endif

int choosebulk = 1; /* this options has been improved; turn it on always! */
int tog_pnod = 0;
int tog_nnod = 0;
int tog_nobrack = 0;
int tog_use0 = 0;
int tog_use0_save = 0;
int tog_vss0 = 0;
int tog_gnd0 = 0;
int xtree = 0;
int alsoImport = 0;
int verbose = 0;
int usenames = 0;
int ofile = 0;
char *outFile = NULL;
int titleCard = 1;
int onlySubckt = 0;
int groundVnet = 0;
int noUnconnect = 0;
int useDBinames = 0;
char ofname[BUFSIZ];
char node0[32];
char *node0ptr = NULL;

char *nameGND = NULL;
char *controlFile = NULL;
char *controlLabel = NULL;
char *stimiliFile = NULL;

struct lib_model *md_head = NULL;
struct lib_model *lm_head = NULL;
char *errorNameTab[MAX_IN_TAB];
int errorName_cnt = 0;

char *excl_lib[40];
int excl_lib_cnt = 0;

static void initIntrup (void);

static void writeHeader (char *network)
{
    struct tm *tstruct;
    time_t tval;
    char *s = "???";
#ifdef XSPECTRE
    char *c = "//";
#else
    char *c = "*";
#endif
    int year;

    time (&tval);
    tstruct = localtime (&tval);
    year = tstruct -> tm_year + 1900;

    switch (tstruct -> tm_mon) {
	case  0: s = "Jan"; break;
	case  1: s = "Feb"; break;
	case  2: s = "Mar"; break;
	case  3: s = "Apr"; break;
	case  4: s = "May"; break;
	case  5: s = "Jun"; break;
	case  6: s = "Jul"; break;
	case  7: s = "Aug"; break;
	case  8: s = "Sep"; break;
	case  9: s = "Oct"; break;
	case 10: s = "Nov"; break;
	case 11: s = "Dec"; break;
    }

#ifdef XPSTAR
    if (titleCard) fprintf (fp_out, "title: %s;\n", network);
#else
    if (titleCard) fprintf (fp_out, "%s %s\n", c, network);
#endif
    fprintf (fp_out, "\n");

#ifdef XPSTAR
    fprintf (fp_out, "/*\n");
#endif
    fprintf (fp_out, "%s Generated by: %s %s\n", c, argv0, TOOLVERSION);
    fprintf (fp_out, "%s Date: %d-%s-%d %d:%02d:%02d\n",
	c, tstruct -> tm_mday, s, year,
	tstruct -> tm_hour, tstruct -> tm_min,  tstruct -> tm_sec);
    fprintf (fp_out, "%s Path: %s\n", c, dmproject -> dmpath);

    switch (dialect) {
	case ESPICE: s = "ESPICE"; break;
	case HSPICE: s = "HSPICE"; break;
	case PSPICE: s = "PSPICE"; break;
	case PSTAR:  s = "PSTAR"; break;
	case ELDO:   s = "ELDO SPICE"; break;
	case SPECTRE:
#ifdef XSPECTRE
		     s = "SPECTRE"; break;
#else
		     s = "SPECTRE SPICE"; break;
#endif
	default:     s = "SPICE";
    }
    fprintf (fp_out, "%s Language: %s\n", c, s);
#ifdef XPSTAR
    fprintf (fp_out, "*/\n");
#else
#ifdef XSPECTRE
    fprintf (fp_out, "\nsimulator lang=spectre\n");
#else
    if (dialect == SPECTRE) fprintf (fp_out, "\nsimulator lang=spice\n");
#endif
#endif
}

int main (int argc, char *argv[])
{
    char *s, *t, *network;
    struct cir *cl;
    char buf[128];

    network = NULL;

    if ((s = strrchr (*argv, '/'))) ++s;
    else if ((s = strrchr (*argv, '\\'))) ++s;
    else s = *argv;
#ifdef WIN32
    if ((t = strchr (s, '.'))) *t = 0;
#endif

    if (argc <= 1) P_E "%s %s\n", argv0, TOOLVERSION);

    while (--argc > 0) {
	if ((*++argv)[0] == '-') {
	    for (s = *argv + 1; *s; s++) {
		switch (*s) {
		    case 'S':
			stimiliFile = *++argv;
			if (*(s + 1) || --argc <= 0 || !*stimiliFile) goto missing;
			break;
		    case 'C':
			controlFile = *++argv;
			if (*(s + 1) || --argc <= 0 || !*controlFile) goto missing;
			break;
		    case 'w':
		    case 'D':
			t = *++argv;
			if (*(s + 1) || --argc <= 0 || !*t) goto missing;
			if (*s == 'w') {
			    if ((maxLL = atoi(t)) < 0) maxLL = 0;
			    break;
			}
			controlLabel = t;
			while (*t) { *t = toupper (*t); ++t; }
			break;
		    case 'f':
			ofile = 1;
			break;
		    case 'F':
			ofile = 1;
			outFile = *++argv;
			if (*(s + 1) || --argc <= 0 || !*outFile) goto missing;
			break;
		    case 'h':
			xtree = 1;
			break;
                    case 'N':
                        use_include = 1;
                        break;
		    case 'i':
			alsoImport = 1;
			break;
		    case 'X':
			t = *++argv;
			if (*(s + 1) || --argc <= 0 || !*t) goto missing;
			if (excl_lib_cnt < 40)
			    excl_lib[excl_lib_cnt++] = strsave (t);
			break;
		    case 'v':
			verbose = 1;
			break;
#ifdef XPSTAR
		    case 'P': use_Pmodels = 1; break;
		    case 'Q': use_Qmodels = 1; break;
#else
#ifndef XSPECTRE
		    case 'E': dialect = ESPICE; break;
		    case 'H': dialect = HSPICE; break;
		    case 'L': dialect = ELDO;   break;
		    case 'P': dialect = PSPICE; break;
		    case 'R': dialect = SPECTRE; break;
		    case 'a': usenames = 1; break;
#endif
		    case 'T': ++tanner; break;
#endif
		    case 'd': useDBinames = 1; break;
		    case 'g': groundVnet = 1; break;
#ifdef XSPECTRE
		    case 'k': onlySubckt = 1; break;
#else
		    case 'k': onlySubckt = 1; titleCard = 0; break;
#endif
		    case 'm': incl_model = 2; break;
		    case 'n': tog_nnod = 1; break;
		    case 'o': incl_model = 0; break;
		    case 'p': tog_pnod = 1; break;
		    case 't': noUnconnect = 1; break;
		    case 'u': choosebulk = 0; break;
		    case 'x': tog_gnd0 = 1; break;
		    case 'y': tog_vss0 = 1; break;
		    case 'z':
		    case 'O':
			++argv;
			if (*(s + 1) || --argc <= 0 || !**argv) {
missing:
			    P_E "%s: option -%c: missing argument\n", argv0, *s);
			    goto stop;
			}
			if ((*s == 'z' && node0ptr) || (*s == 'O' && nameGND)) {
			    P_E "%s: option -%c: twice specified\n", argv0, *s);
			    goto stop;
			}
			if (*s == 'z') node0ptr = *argv;
			else nameGND = strsave (*argv);
			break;
		    default:
			P_E "%s: option -%c: illegal option\n", argv0, *s);
			goto stop;
		}
	    }
	}
	else {
	    if (!network) network = *argv;
	    else {
		P_E "%s: more than one cell name specified\n", argv0);
		goto stop;
	    }
	}
    }
    if (!network) {
	P_E "%s: no cell name specified\n", argv0);
stop:
	P_E use_msg, argv0);
	exit (1);
    }

    if (node0ptr) {
	if (strlen (node0ptr) > 30) {
	    P_E "%s: too long prefix: %s\n", argv0, node0ptr);
	    exit (1);
	}
	strcpy (node0, node0ptr);
    }

    dmInit (argv0);
    dmproject = dmOpenProject (DEFAULT_PROJECT, DEFAULT_MODE);

    dm_get_do_not_alloc = 1; /* fast circuit streams read */

    initIntrup ();

    if (ofile) {
        if (outFile) {
            sprintf (ofname, outFile);
        }
        else {
#ifdef XSPECTRE
	    sprintf (ofname, "%s.spectre", network);
#else
	    if (dialect == PSTAR)
		sprintf (ofname, "%s.pstar", network);
	    else if (dialect == ESPICE)
		sprintf (ofname, "%s.esp", network);
	    else
		sprintf (ofname, "%s.spc", network);
#endif
        }
	if (verbose) P_E "%s: Output to %s\n", argv0, ofname);
	OPENW (fp_out, ofname);
    }
    else {
	fp_out = stdout;
    }

#ifdef XPSTAR
    usenames = 1;
#else
    if (dialect == HSPICE || dialect == ELDO || dialect == SPECTRE) usenames = 1;
#endif
    if (dialect != HSPICE) tog_nobrack = 1;
    tog_nodnbr = !usenames;
    if (nameGND || tog_gnd0 || tog_vss0 || node0[0]) {
	tog_use0_save = tog_use0 = node0[0] ? strlen (node0) : 1;
    }

    initDevs ();

    readControl ();

    if (maxLL < 0) maxLL = 80; /* default */
    else if (maxLL > 0 && maxLL < 40) maxLL = 40;

    writeHeader (network);

    cl = cirTree (network);

    if (!xtree) scanInst (cl -> orig_name, cl -> proj);

    interDevs ();

    if (xtree) {
	int flag = 1;

	for (; cl; cl = cl -> next) {
            if (use_include && cl -> next) {
                if (verbose) P_E "%s: Adding 'include' for %s\n", argv0, cl -> name);
                if (flag) { flag = 0; fprintf (fp_out, "\n"); }
#if defined XPSTAR
		fprintf (fp_out, "#include \"%s.pstar\"\n", cl -> name);
#elif defined XSPECTRE
		fprintf (fp_out, "include \"%s.spectre\"\n", cl -> name);
#else
	    if (dialect == HSPICE || dialect == PSPICE)
		fprintf (fp_out, ".include \"%s.spc\"\n", cl -> name);
	    else
		fprintf (fp_out, ".include %s.spc\n", cl -> name);
#endif
                continue;
            }
	    if (verbose) P_E "%s: Extracting %s\n", argv0, cl -> name);
	    xnetwork (cl -> name, cl -> proj, cl -> imported, cl -> orig_name, cl -> next ? 1 : 0, listnames);
	}
    }
    else {
	if (verbose) P_E "%s: Extracting %s\n", argv0, network);
	xnetwork (cl -> name, cl -> proj, cl -> imported, cl -> orig_name, 0, listnames);
    }

    prImpFunc ();
    prImpNetw ();  /* should actually be placed before xnetwork;
		      but then it is not (yet) working correctly */
    prImpDev ();

    oprint (0, "\n");  /* to empty the buffer */

    endDevs ();

    if (fp_out && stimiliFile) {
	FILE *fp = fopen (stimiliFile, "r");
	if (fp) {
	    fprintf (fp_out, "\n");
	    while (fgets (buf, 80, fp)) {
		fprintf (fp_out, "%s", buf);
	    }
	    fclose (fp);
	}
    }
    if (ofile) CLOSE (fp_out);

    if (dmproject) dmCloseProject (dmproject, COMPLETE);
    dmQuit ();

    return (0);
}

int isCurrentDialect (char *buf)
{
    char *s = buf;
    while (*s) { *s = toupper (*s); ++s; }

    if (controlLabel && strcmp (buf, controlLabel) == 0) return (1);

#ifdef XSPECTRE
    return (strcmp (buf, "SPECTRE") == 0);
#else
#ifdef XPSTAR
    return (strcmp (buf, "PSTAR") == 0);
#else
    if (dialect == HSPICE) return (strcmp (buf, "HSPICE") == 0);
    if (dialect == PSPICE) return (strcmp (buf, "PSPICE") == 0);
    if (dialect == ESPICE) return (strcmp (buf, "ESPICE") == 0);
    if (dialect == SPECTRE)return (strcmp (buf, "SPECTRE") == 0);
    if (dialect == ELDO)   return (strcmp (buf, "ELDO") == 0);
    return (strcmp (buf, "SPICE") == 0);
#endif
#endif
}

void fatalErr (char *s1, char *s2)
{
    P_E "%s:", argv0);
    if (s1 && *s1) P_E " %s", s1);
    if (s2 && *s2) P_E " %s", s2);
    P_E "\n");
    if (ofile && fp_out) {
	oprint (0, ""); /* to empty the buffer */
	fprintf (fp_out, "\nfatalError:");
	if (s1 && *s1) fprintf (fp_out, " %s", s1);
	if (s2 && *s2) fprintf (fp_out, " %s", s2);
	fprintf (fp_out, "\n");
    }
    die ();
}

void int_hdl (int sig) /* interrupt handler */
{
    char *s;
    switch (sig) {
#ifdef SIGILL
	case SIGILL: s = "Illegal instruction"; break;
#endif
#ifdef SIGFPE
	case SIGFPE: s = "Floating point exception"; break;
#endif
#ifdef SIGBUS
	case SIGBUS: s = "Bus error"; break;
#endif
#ifdef SIGSEGV
	case SIGSEGV: s = "Segmentation violation"; break;
#endif
	default: s = "Unknown signal"; break;
    }
    P_E "%s\n", s);
    if (ofile && fp_out) {
	oprint (0, ""); /* to empty the buffer */
	fprintf (fp_out, "\ninterruptError: Some signal occurred!\n");
    }
    die ();
}

static void initIntrup ()
{
#define install_handler(sig) signal (sig, int_hdl)
#ifdef SIGINT
    if (signal (SIGINT, SIG_IGN) != SIG_IGN) install_handler (SIGINT);
#endif
#ifdef SIGQUIT
    if (signal (SIGQUIT, SIG_IGN) != SIG_IGN) install_handler (SIGQUIT);
#endif
#ifdef SIGTERM
    install_handler (SIGTERM);
#endif
#ifdef SIGILL
    install_handler (SIGILL);
#endif
#ifdef SIGFPE
    install_handler (SIGFPE);
#endif
#ifdef SIGBUS
    install_handler (SIGBUS);
#endif
#ifdef SIGSEGV
    install_handler (SIGSEGV);
#endif
}

void dmError (char *s)
{
    P_E "%s: ", argv0);
    dmPerror (s);
    if (ofile && fp_out) {
	oprint (0, ""); /* to empty the buffer */
	fprintf (fp_out, "\ndmError: %s: Error in database function!\n", s);
    }
    die ();
}

void die ()
{
    if (ofile && fp_out) { CLOSE (fp_out); fp_out = NULL; }
    dmQuit ();
    exit (1);
}

void cannot_die (int nr, char *fn)
{
    char *s;

    switch (nr) {
	case 1: s = "Cannot allocate"; fn = "storage"; break;
	case 2: s = "Cannot read file:"; break;
	case 3: s = "Cannot write file:"; break;
	case 4: s = "Internal error:"; break;
	default: if ((s = strrchr (fn, '/'))) fn = s+1;
		s = "Assert failure in";
    }
    if (nr > 4)
	P_E "%s: %s %s at line %d\n", argv0, s, fn, nr);
    else
	P_E "%s: %s %s\n", argv0, s, fn);
    if (ofile && fp_out) {
	oprint (0, ""); /* to empty the buffer */
	if (nr > 4)
	    fprintf (fp_out, "\nError: %s %s at line %d!\n", s, fn, nr);
	else
	    fprintf (fp_out, "\nError: %s %s!\n", s, fn);
    }
    die ();
}
