/*
 * ISC License
 *
 * Copyright (C) 1987-2018 by
 *	R. Paulussen
 *	S. de Graaf
 *	A.J. van Genderen
 *	N.P. van der Meijs
 * Delft University of Technology
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * PROCESS DESCRIPTION:
 *	Convert a GDS II file to the ICD database.
 */

#include "src/gds2/incl.h"

#define TOOLVERSION "4.90 23-Dec-2016"

#define AppendCell(cell) append_tree (cell, &mod_tree)
#define CheckCell(cell)  check_tree (cell, mod_tree)

#define Expect(id) {if (debug && rec_id != id) \
    PE "Expect '%s', got '%s'\n", \
    recordName (id), recordName (rec_id));}

#define Expect2(id1, id2) {if (debug && rec_id != id1 && rec_id != id2) \
    PE "Expect '%s' or '%s', got '%s'\n", \
    recordName (id1), recordName (id2), recordName (rec_id));}

#define MAX_CONV 200 /* the maximal number of cell names in the
                    ** conversion table is fixed at 200 (elias)
                    */

struct d_type {
    int type;
    int mask;
    int istext;
};

FILE   *fp_gds,			/* GDS filepointer               */
       *fp_conv;                /* cell-name conversion-table file pointer  (elias) */

int     pass,			/* number of the pass (1 of 2)   */
        nr_files = 0,		/* number of GDS files           */
        vol_nr,			/* volume number                 */
        t_code[3],		/* unique tape code              */
        Index,			/* record position in buffer     */
        rec_len,		/* record length                 */
        rec_id,			/* record id                     */
        rec_nr = 1,		/* record number                 */
        nr_coor,		/* number of co-ordinaten        */
        N_VOL,			/* flag: next_volume procedure   */
        width,			/* width of path                 */
        pathtype,		/* path type                     */
        magnify,		/* magnification factor		 */
        mir,			/* mirroring                     */
        mode45 = 0,		/* 45 degree test mode           */
        altpath = 0,		/* use alternative algorithm for paths */
        force,			/* force cell overwrite          */
        go_on = 0,		/* if possible, go on after error  */
        t_width = 0,            /* width of terminals generated by TEXT */
	text_as_term = 0,       /* write TEXT stmts in term stream */
	text_as_anno = 0,       /* write TEXT stmts in annotate stream */
	silent = 0,             /* give less messages (for use on WWW server) */
        allow_unknown_numbers = 0,  /* do not print message 28 and 32. */
       *layset;

double  double_val[MAX_DOUBLE],	/* array reals           */
        db_unit,		/* DB unit in micron     */
        resolution;		/* lambda/GDS unit       */

long    angle;			/* angle                 */

char    file_name[BUFLEN],	/* name of GDS file      */
      **maskname,
      **vector,			/* pointer to GDS files  */
      * conv_name[MAX_CONV][2],  /* pointer to cell names in conversion table (elias) */
        nbuf[128],		/* temp. number + text buffer */
        libname[DM_MAXNAME + 1],/* name of library       */
        gds_name[MAX_STRLEN + 1],/* names from GDS file  */
        buf[BUFLEN],
        buf1[128],
        buf2[128],
        buf3[128],
        buf4[256],
        bufe1[BUFLEN],
        bufe2[BUFLEN];

int     readingString = 0;

int     masknr[MAX_GDS_LAYNR + 1]; /* mask numbers */
int     istext[MAX_GDS_LAYNR + 1]; /* text as anno (1) or term (2) */
int     verbose = 0;
int     nr_of_cells = 0;
struct d_type	*masknr_datatype[MAX_GDS_LAYNR + 1];
int     max_datatype = 64;

int db_maxname = DM_MAXNAME;
int convert_dollar = 0;
int convert_long_text = 0;

int roundingWarning = 0;

int findIsText = 0;
int findMatchType = 0;

int mask_nr;

#define PROP_TERMSIDE   59
#define PROP_TERMLAY    60
#define PROP_INSTANCE   61
#define PROP_TERMINAL   62
#define PROP_LABELSIDE  -1
#define PROP_LABELLAY   -1
#define PROP_LABEL      -1

/****
Properties PROP_TERMSIDE PROP_TERMLAY PROP_LABELSIDE PROP_LABELLAY
   are followed by an integer
Properties PROP_INSTANCE PROP_TERMINAL PROP_LABEL are followed by a string

The terminal/label direction can be:
****/

#define BOTTOM  0
#define RIGHT   1
#define TOP     2
#define LEFT    3
#define ANY_DIRECTION   99

int boundary_box = 0;
int prop_termside;
int prop_termlay;
int prop_instance;
int prop_term;
int prop_labelside;
int prop_labellay;
int prop_label;

static				/* error messages */
char   *err_list[] =
{
     /*  0 */ "-- program finished --",
     /*  1 */ "missing GDS file(s)",
     /*  2 */ "cannot open GDS file '%s'",
     /*  3 */ "cannot read tape block from GDS file '%s'",
     /*  4 */ "last co-ordinates not equal to first pair",
     /*  5 */ "illegal %s",
     /*  6 */ "absolute %s not supported",
     /*  7 */ "too less co-ordinates",
     /*  8 */ "name %s too long, truncated!",
     /*  9 */ "cell '%s' not found",
     /* 10 */ "intersecting lines not allowed",
     /* 11 */ "illegal direction change in co-ordinates",
     /* 12 */ "equal co-ordinates not allowed",
     /* 13 */ "odd number of co-ordinates",
     /* 14 */ "lines (partly) overlap",
     /* 15 */ "too big direction change",
     /* 16 */ "cannot read info of cell '%s'",
     /* 17 */ "cannot allocate enough memory",
     /* 18 */ "cell '%s' not placed!",
     /* 19 */ "cell '%s' already exists, not overwritten!",
     /* 20 */ "interrupted due to signal '%s'",
     /* 21 */ "%s",
     /* 22 */ "in DMI function",
     /* 23 */ "multiple entry of cell '%s'",
     /* 24 */ "illegal increment (0 value(s))",
     /* 25 */ "illegal co-ordinates (%s)",
     /* 26 */ "empty cell '%s'",
     /* 27 */ "GDS unit < lambda, not allowed!",
     /* 28 */ "illegal layer number %s",
     /* 29 */ "too many co-ordinates",
     /* 30 */ "end of file detected",
     /* 31 */ "GDS unit changed into lambda value of %s micron",
     /* 32 */ "element '%s' skipped!",
     /* 33 */ "cell definition of cell '%s' had error",
     /* 34 */ "pathtype %s not supported (set to 0)",
     /* 35 */ "non 45 degree feature(s)",
     /* 36 */ "GDS file '%s' is not the correct volume",
     /* 37 */ "cannot access GDS file '%s'",
     /* 38 */ "file '%s' is not a regular file",
     /* 39 */ "illegal GDS masknr '%s' in bmlist file",
     /* 40 */ "already used GDS masknr '%s' in bmlist file",
     /* 41 */ "cannot read file '%s'",
     /* 42 */ "after read in file '%s'",
     /* 43 */ "unknown mask '%s' in bmlist file",
     /* 44 */ "already used mask '%s' in bmlist file",
     /* 45 */ "unsupported record type '%s', skipped!",
     /* 46 */ "unexpected record type '%s', skipped?",
     /* 47 */ "cannot find record type '%s' in GDS file",
     /* 48 */ "property attribute expected, found '%s'",
     /* 49 */ "cell '%s' already defined!",
     /* 50 */ "cell '%s' overwritten!",
     /* 51 */ "error in conversion table '%s'", /* (elias) */
     /* 52 */ "'$' detected in cell names: replaced by '_'", /* (elias) */
     /* 53 */ "number of conversions in '$' exceeds maximum 200", /* (elias) */
     /* 54 */ "TEXT name %s too long, truncated!",
     /* 55 */ "STRUCTURE name %s too long, truncated!",
     /* 56 */ "LIBRARY name %s too long, truncated!",
     /* 57 */ "abs. value of internal coordinate becomes larger than %s.\n   A solution may be to use the tool 'clambda' to increase the value of\n   lambda for your project.",
     /* 58 */ "file 'bmlist.gds': too many different datatypes defined for one layer",
     /* 59 */ "cannot open file '%s'",
     /* 60 */ "too long TEXT names occurred.\n   These names have been converted to shorter names.\n   See file '%s' for a conversion list.",
     /* 61 */ "cannot remove/overwrite file '%s'",
     /* 62 */ "abs. value of internal coordinate becomes larger than %s.\n   Consider to increase the layout grid.",
     /* 63 */ "GDS values multiplied by %s.",
     /* 64 */ "no correct value for '%s' in bmlist file."
};

char   *argv0 = "cgi";		/* Program Name */
char   *use_msg; 		/* Command Line */

int     debug = 0;
#define DEBUG_PRINT  if(debug) fprintf(stderr,

struct cell {
    DM_CELL *ckey;
    int     defined;
    int     father;
    int     rec_no;
    long    offset;
    char   *cell_name;
    struct ref *son;
    struct cell *next;
};

struct ref {
    char   *refname;
    struct cell *father;
    struct cell *origin;
    struct ref *next;
};

struct cell *cell_start = NULL;
struct cell *cell_last  = NULL;
char   *bmlist = 0,
       *conv_list = 0; /* cell-name conversion-table name (elias) */

DM_STREAM *fp_anno = NULL;

struct property {
    int     attr;
    char    value[DM_MAXNAME + 1];
} property[25];

int mygetc (void);
void next_rec (void);
void read_gds (void);
void jump_file (void);
int define_cell (struct cell *cell_P, int level);
void dump_data (void);
void add_mc (struct cell *cell_P, char *cell_name);
struct cell *add_cell (long offset, char *cell_name);
char *strsave (char *str);
void read_str (long offset, struct cell *cell_P);
void read_boundary (void);
void read_path (void);
void read_ref (int id);
void read_strans (void);
void search_id (int id);
void read_int (int length);
void read_double (void);
void read_string (void);
void read_rec_header (void);
void read_rec_contents (void);
void check_rec_id (int nr, int id);
int path (void);
double scale_coord (int v);
double round_float (int v, char *s);
int round_int (int v, char *s);
int box (int xl, int xr, int yb, int yt);
int poly (void);
int swire (void);
int append_tree (char *name, struct name_tree **head);
int check_tree (char *name, struct name_tree *ptr);
void ini_modtree (void);
void write_info (void);
void open_gds (void);
void next_volume (void);
void read_tape_id (void);
void sig_handler (int sig);
void pr_exit (int mode, int err_no, char *cs);
char *recordName (int id);
void check_for_prop (void);
void doTerm (char *termname, int termside);
void doLabel (char *labelname, int labelside);
void read_text (void);
int findMasknr (int gds_nr, int gds_datatype);
void initTruncDmNames (void);
void endTruncDmNames (void);
char *truncDmName (char *s, int head, int reuse);

int main (int argc, char *argv[])
{
    FILE * fp_bml;
    int     gds_laynr;
    int     usage = 0;
    int     nolays;		/* max. number of mask codes */
    register int    i, j, iarg, l;
    int     gds_datatype;
    int     isthistext;

    use_msg = "\nUsage: %s [-4cdfglpSsv] [-m mlist] [-n ctable] [-w size] GDS-file ...\n\n";

    if (argc <= 1) {
	PE "%s %s\n", argv0, TOOLVERSION);
	PE use_msg, argv0);
	exit (1);
    }

    dmInit (argv0);

    for (iarg = 1; iarg < argc; ++iarg) {

	if (argv[iarg][0] != '-') {
	    if (nr_files) {
		PE "%s: already GDS-file(s) found (must be in sequence)\n", argv0);
		PE use_msg, argv0);
		exit (1);
	    }
	    vector = &argv[iarg - 1];
	    do { ++nr_files; } while (++iarg < argc && argv[iarg][0] != '-');
	    if (iarg >= argc) break;
	}

	j = iarg;
	for (i = 1; argv[j][i] != '\0'; ++i) {
	    switch (argv[j][i]) {
		case 'm':
		    if (++iarg >= argc) {
			PE "%s: -m: missing mask-list argument\n", argv0);
			exit (1);
		    }
		    bmlist = argv[iarg];
		    break;
		case 'n':
		    /* Read specified cell-name conversion table (elias) */
		    if (++iarg >= argc) {
			PE "%s: -n: missing conversion-table argument\n", argv0);
			exit (1);
		    }
		    conv_list = argv[iarg];
		    break;
		case 'v':
		    ++verbose;
		    break;
		case 'l':
		    ++convert_dollar;
		    break;
		case 'c':
		    ++convert_long_text;
		    break;
		case 'd':
		    ++debug;
		    break;
		case 'f':
		    ++force;
		    break;
		case '4':
		    ++mode45;
		    break;
		case 'p':
		    ++altpath;
		    break;
		case 'g':
		    ++go_on;
		    break;
		case 'w':
		    {
			char *s = argv[++iarg];
			if (s && *s && isdigit ((int)(*s)))
			    t_width = atoi (s);
			else
			    usage = 1;
		    }
		    break;
		case 't':
		    ++text_as_term;
		    PE "%s: -t: obsolete option\n", argv0);
		    break;
		case 'a':
		    ++text_as_anno;
		    PE "%s: -a: obsolete option\n", argv0);
		    break;
                case 's':
                    ++allow_unknown_numbers;
                    break;
                case 'S':
		    ++silent;
		    break;
		default:
		    ++usage;
		    PE "%s: -%c: unknown option\n", argv0, argv[j][i]);
	    }
	}
    }

    if (!nr_files) {
	PE "%s: no GDS-file given\n", argv0);
	++usage;
    }

    if (usage) {
	PE use_msg, argv0);
	exit (1);
    }

    if ((i = sizeof (int)) != LONG) {
	pr_exit (A, 21, "sizeof int not equal to 4 bytes");
    }

    if (t_width < 0) t_width = 0;

    vol_nr = 1;
    open_gds ();

#ifdef SIGHUP
    signal (SIGHUP, SIG_IGN);	/* ignore hangup signal */
#endif
    if (signal (SIGINT, SIG_IGN) != SIG_IGN)
	signal (SIGINT, sig_handler);
#ifdef SIGQUIT
    if (signal (SIGQUIT, SIG_IGN) != SIG_IGN)
	signal (SIGQUIT, sig_handler);
#endif
    if (signal (SIGTERM, SIG_IGN) != SIG_IGN)
	signal (SIGTERM, sig_handler);

    signal (SIGILL, sig_handler);
    signal (SIGFPE, sig_handler);
#ifdef SIGBUS
    signal (SIGBUS, sig_handler);
#endif
    signal (SIGSEGV, sig_handler);

    dmproject = dmOpenProject (DEFAULT_PROJECT, DEFAULT_MODE);
    process = (DM_PROCDATA *) dmGetMetaDesignData (PROCESS, dmproject);
    maskname = process -> mask_name;
    nolays = process -> nomasks;

    for (i = 0; i <= MAX_GDS_LAYNR; ++i) {
        masknr[i] = -1;
        istext[i] = 0;
        masknr_datatype[i] = NULL;
    }

    if (!bmlist)
	bmlist = (char *) dmGetMetaDesignData (PROCPATH, dmproject, "bmlist.gds");

    if (!(fp_bml = fopen (bmlist, "r"))) pr_exit (A, 41, bmlist);

    CALLOC (layset, int, nolays);

    prop_termside = PROP_TERMSIDE;
    prop_termlay = PROP_TERMLAY;
    prop_instance = PROP_INSTANCE;
    prop_term = PROP_TERMINAL;
    prop_labelside = PROP_LABELSIDE;
    prop_labellay = PROP_LABELLAY;
    prop_label = PROP_LABEL;

    while (fgets (buf, BUFLEN, fp_bml)) {
	if (sscanf (buf, "%s", buf1) <= 0 || buf1[0] == '#')
            continue;  /* empty line or comment line. */
        isthistext = 0;
        buf1[0] = buf2[0] = buf3[0] = '\0';
	if (sscanf (buf, "%s%s%s", buf1, buf2, buf3) < 2)
            pr_exit (A, 42, bmlist);

        if (strcmp (buf1, "prop_termside") == 0) {
            if (sscanf (buf2, "%d", &prop_termside) < 1) {
                pr_exit (A, 64, "prop_termside");
            }
            continue;
        }
        else if (strcmp (buf1, "prop_termlay") == 0) {
            if (sscanf (buf2, "%d", &prop_termlay) < 1) {
                pr_exit (A, 64, "prop_termlay");
            }
            continue;
        }
        else if (strcmp (buf1, "prop_instance") == 0) {
            if (sscanf (buf2, "%d", &prop_instance) < 1) {
                pr_exit (A, 64, "prop_instance");
            }
            continue;
        }
        else if (strcmp (buf1, "prop_term") == 0) {
            if (sscanf (buf2, "%d", &prop_term) < 1) {
                pr_exit (A, 64, "prop_term");
            }
            continue;
        }
        else if (strcmp (buf1, "prop_labelside") == 0) {
            if (sscanf (buf2, "%d", &prop_labelside) < 1) {
                pr_exit (A, 64, "prop_labelside");
            }
            continue;
        }
        else if (strcmp (buf1, "prop_labellay") == 0) {
            if (sscanf (buf2, "%d", &prop_labellay) < 1) {
                pr_exit (A, 64, "prop_labellay");
            }
            continue;
        }
        else if (strcmp (buf1, "prop_label") == 0) {
            if (sscanf (buf2, "%d", &prop_label) < 1) {
                pr_exit (A, 64, "prop_label");
            }
            continue;
        }

        l = strlen (buf1);
        if (strncmp (buf1, "anno_", 5) == 0) {
            /* This one is for backward compatibility
               with an earlier version */
            isthistext = 1;
            strcpy (buf4, buf1 + 5);
            strcpy (buf1, buf4);
        }
        else if (l > 6 && strcmp (&buf1[l-6], ":label") == 0) {
            isthistext = 1;
            buf1[l-6] = '\0';
        }
        else if (l > 5 && strcmp (&buf1[l-5], ":term") == 0) {
            isthistext = 2;
            buf1[l-5] = '\0';
        }
	for (i = 0; i < nolays; ++i) {
	    if (strcmp (buf1, maskname[i]) == 0) break;
	}
	if (i >= nolays) pr_exit (A, 43, buf1);
	gds_laynr = atoi (buf2);
	if (gds_laynr >= 0) {
	    /*
	    if (layset[i] == 1 || layset[i] == -1)
		pr_exit(W, 44, buf1);
	    */
	    layset[i] += 1;
	}
	else {
	    gds_laynr = -gds_laynr;
	    layset[i] -= 2;
	}
	if (gds_laynr < 0 || gds_laynr > MAX_GDS_LAYNR) pr_exit (A, 39, buf2);
        if (buf3[0] >= '0' && buf3[0] <= '9')
            gds_datatype = atoi (buf3);
        else
            gds_datatype = -1;
        if (gds_datatype < 0) {
	    if (masknr[gds_laynr] >= 0
                && !(istext[gds_laynr] == 0 || isthistext == 0))
                pr_exit (A, 40, buf2);
            if (masknr[gds_laynr] < 0 || masknr[gds_laynr] == i) {
	        masknr[gds_laynr] = i;
                if (isthistext)
                    istext[gds_laynr] = isthistext;
            }
        }
        else {
            if (masknr_datatype[gds_laynr] == NULL) {
                masknr_datatype[gds_laynr] = (struct d_type *)
                  malloc (sizeof (struct d_type) * max_datatype);
                if (masknr_datatype[gds_laynr] == NULL) pr_exit (A, 17, 0);
                for (j = 0; j < max_datatype; j++) {
                    masknr_datatype[gds_laynr][j].type = -1;
                    masknr_datatype[gds_laynr][j].mask = -1;
                    masknr_datatype[gds_laynr][j].istext = 0;
                }
            }
            for (j = 0; j < max_datatype; j++) {
                if (masknr_datatype[gds_laynr][j].type < 0) break;
                if (masknr_datatype[gds_laynr][j].type == gds_datatype) break;
            }
            if (j == max_datatype)
                pr_exit (A, 58, NULL);
	    if (masknr_datatype[gds_laynr][j].type == gds_datatype
                && !(masknr_datatype[gds_laynr][j].istext == 0
                      || isthistext == 0)) {
                sprintf (buf4, "%s' and datatype '%s", buf2, buf3);
                pr_exit (A, 40, buf4);
            }
            if (masknr_datatype[gds_laynr][j].mask < 0
                || (masknr_datatype[gds_laynr][j].mask == i
                    && masknr_datatype[gds_laynr][j].type == gds_datatype)) {
                masknr_datatype[gds_laynr][j].type = gds_datatype;
                masknr_datatype[gds_laynr][j].mask = i;
                if (isthistext)
	            masknr_datatype[gds_laynr][j].istext = isthistext;
            }
        }
    }

    fclose (fp_bml);

    /* Read conversion table if specified (elias) */

    if (conv_list) {
        if (!(fp_conv = fopen (conv_list, "r")))
	     pr_exit (A, 41, conv_list);

         while (fgets (buf, BUFLEN, fp_conv)) {
	     if (*buf == '#') continue;
	     if (sscanf (buf, "%s", bufe1) <= 0) continue;  /* empty line */
	     if (sscanf (buf, "%s%s", bufe1, bufe2) != 2)
	         pr_exit (A, 51, conv_list); /* faulty line */
             /* Check if already present in data file */
             i = 0;
             while (i < MAX_CONV && conv_name[i][0] &&
                    strcmp (bufe1, conv_name[i][0]) != 0) i++;
             if (i >= MAX_CONV) pr_exit (A, 53, conv_list);
             /* If already present, overwrite */
             conv_name[i][0] = strsave (bufe1);
             conv_name[i][1] = strsave (bufe2);
         }
         fclose (fp_conv);
    }

    ini_modtree ();

    if (verbose) {
	PE "%s: TOOLVERSION %s\n", argv0, TOOLVERSION);
	for (i = 0; i <= MAX_GDS_LAYNR; ++i) {
	    if (masknr[i] != -1) {
		if (layset[masknr[i]] > 0)
		    PE "%s: using GDS layer# %2d for mask '%s'\n",
			argv0, i, maskname[masknr[i]]);
		else
		    PE "%s: using GDS layer# %2d for mask '%s' (has terminals)\n",
		    argv0, i, maskname[masknr[i]]);
	    }
	    if (masknr_datatype[i]) {
                for (j = 0; j < max_datatype
                            && masknr_datatype[i][j].type >= 0; ++j)
		    if (layset[masknr_datatype[i][j].mask] > 0)
		        PE "%s: using GDS layer# %2d with datatype# %2d for mask '%s'\n",
			   argv0, i, masknr_datatype[i][j].type,
                           maskname[masknr_datatype[i][j].mask]);
                    else
		        PE "%s: using GDS layer# %2d with datatype# %2d for mask '%s' (has terminals)\n",
			   argv0, i, masknr_datatype[i][j].type,
                           maskname[masknr_datatype[i][j].mask]);

            }
        }
    }

    /*
    ** A GDS file may define cells (structures) before they
    ** are used.
    ** Therefore, make two passes, on first pass skip the hierarchical
    ** references and on the second pass, skip the primitives
    */
    gnor_ini.dx = gnor_ini.dy = 0;
    gnor_ini.nx = gnor_ini.ny = 0;
    gbox.dx = gbox.dy = gterm.dx = gterm.dy = 0;
    gbox.nx = gbox.ny = gterm.nx = gterm.ny = 0;

    /* first pass */
    pass = 1;
    read_gds ();
    fclose (fp_gds);

    if (verbose) dump_data ();

    /* second pass */
    vol_nr = 1;
    open_gds ();
    pass = 2;
    read_gds ();
    fclose (fp_gds);

    if (roundingWarning) {
	PE "%s: warning: rounding of coordinates occurred.\n", argv0);
	if (silent)
	    PE "   Consider to decrease the layout grid.\n");
	else {
	    PE "   Consider the use of the tool 'clambda' to decrease\n");
	    PE "   the value of lambda for your project.\n");
	}
    }

    dmCkinAll (COMPLETE);
    dmCloseProject (dmproject, COMPLETE);
    dmQuit ();
    pr_exit (E, 0, 0);
    return (0);
}

/* For deleting buffer and fread call */
int mygetc ()
{
    int  c;
    if ((c = fgetc (fp_gds)) == EOF) {
	pr_exit (I, 30, 0);
	pr_exit (A, 3, file_name);
    }
    ++Index;
    return (c);
}

/* Replacement of old NEXT_RECORD define */
void next_rec ()
{
    while (Index++ < rec_len) fgetc (fp_gds);
    ++rec_nr;
}

/*
** Read GDS file.
*/
void read_gds ()
{
    char    rbuf[20];
    long    offset;

    rec_nr = 1;

    if (pass > 1) {      /**** pass TWO ****/
	search_id (UNITS);
	NEXT_RECORD;
	jump_file ();
	return;
    }

    /**** pass ONE ****/
    check_rec_id (0, HEADER);
    NEXT_RECORD;
    check_rec_id (0, BGNLIB);
    NEXT_RECORD;
    check_rec_id (0, LIBNAME);
    readingString = LIBNAME;
    read_rec_contents ();
    readingString = 0;
    strcpy (libname, gds_name);
    if (verbose) PE "%s: GDS library name is '%s'\n", argv0, libname);
    search_id (UNITS);
    read_rec_contents ();
    if (double_val[1] > 0.125) pr_exit (A, 5, "unit");
    db_unit = ((double) ((long) (double_val[1] * 1E12 + 0.5))) * 1E-6;
    if (verbose) PE "%s: GDS database unit is %g micron\n", argv0, db_unit);
    resolution = 1.0;
    if (db_unit != dmproject -> lambda) {
	char buf[32];
	resolution = db_unit / dmproject -> lambda;
	sprintf (rbuf, "%.8g", dmproject -> lambda);
	pr_exit (J, 31, rbuf);
	sprintf (buf, "%g", resolution);
	pr_exit (J, 63, buf);
    }

    do {
	offset = ftell (fp_gds);
	read_rec_header ();
	NEXT_RECORD;
	switch (rec_id) {
	    case BGNSTR:
		read_str (offset, (struct cell *)NULL);
		break;
	    case ENDLIB:
		break;
	    default:
		Expect2 (BGNSTR, ENDLIB);
		pr_exit (A+R, 5, "syntax");
	}
    } while (rec_id != ENDLIB);
}

/* Walk in "right" order trough the input file */
void jump_file ()
{
    register struct cell *cell_P, *help_P;
    register struct ref  *ref_P;

    /* Determine if cell has father or not */
    for (cell_P = cell_start; cell_P; cell_P = cell_P -> next) {
	for (ref_P = cell_P -> son; ref_P; ref_P = ref_P -> next) {
	    for (help_P = cell_start; help_P; help_P = help_P -> next) {
		if (strcmp (help_P -> cell_name, ref_P -> refname) == 0) {
		    help_P -> father = 1;
		    ref_P -> origin = help_P;
		    break;
		}
	    }
	}
    }

    /* For all ROOT cells, do define_cell () */
    for (cell_P = cell_start; cell_P; cell_P = cell_P -> next) {
	if (!cell_P -> father) define_cell (cell_P, 0);
    }

    /* For all NOT DEFINED cells, give message */
    for (cell_P = cell_start; cell_P; cell_P = cell_P -> next) {
	if (!cell_P -> defined) {
	    rec_nr = cell_P -> rec_no;
	    pr_exit (W+R, 18, cell_P -> cell_name);
	    dmCheckIn (cell_P -> ckey, QUIT);
	}
    }
}

/* Process cells in correct order */
int define_cell (struct cell *cell_P, int level)
{
    struct ref *ref_P;

    if (!cell_P || cell_P -> defined) return (0);
    if (++level > nr_of_cells) {
	pr_exit (W, 21, "cell recursion!");
	return (1);
    }

    for (ref_P = cell_P -> son; ref_P; ref_P = ref_P -> next) {
	if (define_cell (ref_P -> origin, level)) return (1);
    }

    if (verbose) {
	PE "%s: *** Pass 2 busy with cell: %s\n", argv0, cell_P -> cell_name);
    }
    fseek (fp_gds, cell_P -> offset, 0);
    read_rec_header ();
    NEXT_RECORD;
    read_str (0L, cell_P);
    cell_P -> defined = 1;
    return (0);
}

/* Dump the data structures */
void dump_data ()
{
    register struct cell *cell_P;
    register struct ref  *ref_P;

    for (cell_P = cell_start; cell_P; cell_P = cell_P -> next) {
	PE "\n%s: %s calls: ", argv0, cell_P -> cell_name);
	for (ref_P = cell_P -> son; ref_P; ref_P = ref_P -> next) {
	    PE "%s, ", ref_P -> refname);
	}
    }
    PE "\n");
}

/* Add reference to a cell */
void add_mc (struct cell *cell_P, char *cell_name)
{
    register struct ref *ref_P;

    if (CheckCell (cell_name)) { /* found */
	if (tree_ptr -> status && !force) {
	    return;	/* Cell already in DB */
	}
	/* Cell already in FILE */
    }
    /*else Cell not yet in FILE */

    for (ref_P = cell_P -> son; ref_P; ref_P = ref_P -> next) {
	if (strcmp (cell_name, ref_P -> refname) == 0)
	    return;		/* Cell already refered */
    }
    ALLOC (ref_P, ref);
    ref_P -> refname = strsave (cell_name);
    ref_P -> father  = cell_P;
    ref_P -> origin  = NULL;
    ref_P -> next = cell_P -> son;
    cell_P -> son = ref_P;
}

/* Add cell to the cell list */
struct cell *add_cell (long offset, char *cell_name)
{
    register struct cell *cell_P;

    ++nr_of_cells;
    ALLOC (cell_P, cell);
    if (!cell_last) {
	cell_start = cell_P;
	cell_last = cell_P;
    }
    else {
	cell_last -> next = cell_P;
	cell_last = cell_P;
    }
    cell_P -> defined = 0;
    cell_P -> father  = 0;
    cell_P -> offset  = offset;
    cell_P -> cell_name = strsave (cell_name);
    cell_P -> son  = NULL;
    cell_P -> next = NULL;
    cell_P -> ckey = NULL;
    return (cell_P);
}

char *strsave (char *str)
{
    char *cp = malloc (strlen (str) + 1);
    if (!cp) pr_exit (A, 17, 0);
    else strcpy (cp, str);
    return (cp);
}

/*
** Read a structure.
*/
void read_str (long offset, struct cell *cell_P)
{
    int MC;
    struct stat statBuf;

    check_rec_id (0, STRNAME);
    readingString = STRNAME;
    read_rec_contents ();
    readingString = 0;
    strcpy (ms_name, gds_name);

    if (pass == 2) rec_nr = cell_P -> rec_no;

    if (CheckCell (ms_name)) { /* found */
	if (pass == 1) {
	    if (!tree_ptr -> status) {
		pr_exit (A, 49, ms_name); /* already defined */
		goto skip;
	    }
	    else if (!force) {
		pr_exit (W, 19, ms_name); /* already exist */
		goto skip;
	    }
	    else
		pr_exit (W, 50, ms_name); /* overwritten */
	}
	else if (tree_ptr -> status) goto skip;
    }
    else { /* not found */
	if (pass == 2) {
	    pr_exit (A, 9, ms_name);
	    goto skip;
	}
    }

    DEBUG_PRINT "Beginning '%s', pass %d\n", ms_name, pass);
    MC = FALSE;

    if (pass == 1) {
	cell_P = add_cell (offset, ms_name);
	cell_P -> rec_no = rec_nr;
	mod_key = dmCheckOut (dmproject, ms_name,
		WORKING, DONTCARE, LAYOUT, CREATE);
	ini_bbbox = 1;
	fp_box = dmOpenStream (mod_key, "box", "w");
	fp_nor = dmOpenStream (mod_key, "nor", "w");
	fp_term = dmOpenStream (mod_key, "term", "w");
	fp_anno = dmOpenStream (mod_key, "annotations", "w");
	ganno.type = GA_FORMAT;
	ganno.o.format.fmajor = ganno.o.format.fminor = 1;
	dmPutDesignData (fp_anno, GEO_ANNOTATE);
	if (dmStat (mod_key, "torname", &statBuf) != -1) {
	    dmUnlink (mod_key, "torname");
	}
        initTruncDmNames ();
    }
    else { /* pass TWO */
	mod_key = cell_P -> ckey;
	ini_mcbbox = 1;
	fp_mc = dmOpenStream (mod_key, "mc", "w");
	fp_info = dmOpenStream (mod_key, "info", "w");
    }
    DEBUG_PRINT "%s %p\n", ms_name, mod_key);

    read_rec_header ();
    NEXT_RECORD;
    if (rec_id == STRCLASS) {
	pr_exit (W+R, 45, recordName (rec_id));
	read_rec_header ();
	NEXT_RECORD;
    }

    /* init names for duplicate test, see read_text */
    *gterm.term_name = 0;
    *ganno.o.Label.name = 0;

    while (rec_id != ENDSTR) {
	switch (rec_id) {
	    case BOUNDARY:
		if (pass == 2)  {
	    		search_id (ENDEL);
			break;
		}
		read_boundary ();
	    	check_for_prop ();
		boundary_box = 0;
		break;
	    case PATH:
		if (pass == 2) {
	    		search_id (ENDEL);
			break;
		}
		read_path ();
	    	check_for_prop ();
		break;
	    case AREF:
	    case SREF:
		if (pass == 1) {
		    MC = TRUE;
		    check_rec_id (2, SNAME);
		    readingString = SNAME;
		    read_rec_contents ();
		    readingString = 0;
		    add_mc (cell_P, gds_name);
	    	    search_id (ENDEL);
		}
		else { /* pass TWO */
		    read_ref (rec_id);
			/* check_for_prop implied by read_ref */
		}
		break;
	    case TEXT:
		if (pass == 2) {
		    search_id (ENDEL);
		    break;
		}
		readingString = TEXT;
		read_text();
		readingString = 0;
	    	check_for_prop ();
		break;
	    case NODE:
	    case BOX:
		if (pass == 2)  {
	    		search_id (ENDEL);
			break;
		}
		pr_exit (W+R, 45, recordName (rec_id));
	    	search_id (ENDEL);
		break;
	    default:
		/* unexpected record type */
		pr_exit (W+R, 46, recordName (rec_id));
	    	search_id (ENDEL);
		break;
	}

	NEXT_RECORD;
	read_rec_header ();
	NEXT_RECORD;
    }

    AppendCell (ms_name);

    if (pass == 1) {
	tree_ptr -> status = FALSE;
	cell_P -> ckey = mod_key;
	if (ini_bbbox) {
	    if (!MC) pr_exit (W+R, 26, ms_name); /* empty */
	}
	else {
	    ALLOC (tree_ptr -> bbox, mod_bbox);
	    tree_ptr -> bbox -> xl = bbnd_xl;
	    tree_ptr -> bbox -> xr = bbnd_xr;
	    tree_ptr -> bbox -> yb = bbnd_yb;
	    tree_ptr -> bbox -> yt = bbnd_yt;
	}
	dmCloseStream (fp_box, COMPLETE);
	dmCloseStream (fp_nor, COMPLETE);
	dmCloseStream (fp_term, COMPLETE);
	dmCloseStream (fp_anno, COMPLETE);
        endTruncDmNames ();
    }
    else { /* pass TWO */
	write_info ();
	dmCloseStream (fp_info, COMPLETE);
	dmCloseStream (fp_mc, COMPLETE);
	DEBUG_PRINT "Checkin %s\n", ms_name);
	dmCheckIn (mod_key, COMPLETE);
    }

    DEBUG_PRINT "Ending '%s'\n", ms_name);
    return;
skip:
    if (pass == 2 && verbose) {
	PE "%s: %d: *** Skipping cell: %s\n", argv0, rec_nr, ms_name);
    }
    search_id (ENDSTR);
    NEXT_RECORD;
}

/*
** Read a boundary-record and place a box or poly
** in the ICD database, if there are no errors.
** A syntax check is also done.
*/
void read_boundary ()
{
    int i, rv = 1;
    int j, n, xmin, xmax, ymin, ymax;
    int dx1, dy1, dx2, dy2;

    check_rec_id (2, LAYER);
    read_rec_contents ();
    lay_code = int_val[0];

    check_rec_id (0, DATATYPE);
    read_rec_contents ();
    data_type = int_val[0];

    check_rec_id (0, XY);
    nr_coor = (rec_len - 4) / LONG;
    read_rec_contents ();

    if (data_type >= 0)
        sprintf (nbuf, "'%d' with datatype '%d'", lay_code, data_type);
    else
        sprintf (nbuf, "'%d' (no datatype)", lay_code);
    if (lay_code < 0 || lay_code > MAX_GDS_LAYNR
        || (mask_nr = findMasknr (lay_code, data_type)) < 0) {
	if (!silent) pr_exit (W, 28, nbuf);
	goto skip;
    }

    if (nr_coor < 8) { pr_exit (W, 7, 0); goto skip; }
    if (nr_coor & 1) { pr_exit (W, 13, 0); goto skip; }

    if (int_val[0] != int_val[nr_coor - 2] || int_val[1] != int_val[nr_coor - 1]) {
	pr_exit (W, 4, 0); goto skip; /* last point not equal to first point */
    }

    boundary_box = 1;
    j = 0;
    xmin = xmax = int_val[0];
    ymin = ymax = int_val[1];

    /* test for equal coordinates and points on same line */
    for (i = 2; i < nr_coor; i += 2) {
	dx1 = int_val[j]   - int_val[i];
	dy1 = int_val[j+1] - int_val[i+1];
	if (dx1 == 0) {
	    if (dy1 == 0) continue; /* equal coordinates */
	    else if (int_val[i+1] < ymin) ymin = int_val[i+1];
	    else if (int_val[i+1] > ymax) ymax = int_val[i+1];
	}
	else { /* dx1 != 0 */
	    if (dy1 != 0) boundary_box = 0; /* !orthogonal */
	    else if (int_val[i] < xmin) xmin = int_val[i];
	    else if (int_val[i] > xmax) xmax = int_val[i];
	}
	if ((n = i+2) == nr_coor) n = 2;
	dx2 = int_val[i]   - int_val[n];
	dy2 = int_val[i+1] - int_val[n+1];

	/* test only on same line for the orthogonal case */
	if ((dy1 == 0 && dy2 == 0 && ((dx1 > 0 && dx2 >= 0) || (dx1 < 0 && dx2 <= 0)))
	 || (dx1 == 0 && dx2 == 0 && ((dy1 > 0 && dy2 >= 0) || (dy1 < 0 && dy2 <= 0)))) {
	    if (n == 2) { int_val[0] = int_val[j]; int_val[1] = int_val[j+1]; }
	    else { int_val[j+2] = int_val[n]; int_val[j+3] = int_val[n+1]; }
	    continue;
	}
	j += 2;
	if (j < i) { int_val[j] = int_val[i]; int_val[j+1] = int_val[i+1]; }
    }
    nr_coor = j + 2;

    if (nr_coor <= 10 && boundary_box) {
	rv = box (xmin, xmax, ymin, ymax);
    }
    else {
	boundary_box = 0;
	rv = poly ();
    }
skip:
    if (rv && !silent) pr_exit (W+R, 32, "boundary");
}

/*
** Read path element.
*/
void read_path ()
{
    int rv = 1;
    check_rec_id (2, LAYER);
    read_rec_contents ();
    lay_code = int_val[0];

    check_rec_id (0, DATATYPE);
    read_rec_contents ();
    data_type = int_val[0];

    pathtype = width = 0;
    read_rec_header ();
    if (rec_id == PATHTYPE) {
	read_rec_contents ();
	pathtype = int_val[0];
	read_rec_header ();
    }
    if (rec_id == WIDTH) {
	read_rec_contents ();
	width = int_val[0];
	read_rec_header ();
    }
    if (rec_id != XY) {
	NEXT_RECORD;
	check_rec_id (1, XY);
    }

    read_rec_contents ();
    nr_coor = (rec_len - 4) / LONG;

    if (data_type >= 0)
        sprintf (nbuf, "'%d' with datatype '%d'", lay_code, data_type);
    else
        sprintf (nbuf, "'%d' (no datatype)", lay_code);
    if (lay_code < 0 || lay_code > MAX_GDS_LAYNR
        || (mask_nr = findMasknr (lay_code, data_type)) < 0) {
	if (!silent)
	    pr_exit (W, 28, nbuf);
	goto skip;
    }
    if (nr_coor < 4) {
	pr_exit (W, 7, 0);
	goto skip;
    }
    if (nr_coor & 1) {
	pr_exit (W, 13, 0);
	goto skip;
    }

    if (width <= 0) {
	pr_exit (W, 5, "width");
	goto skip;
    }

    if (!altpath)
        rv = ese_swire ();
    else
        rv = do_swire ();   /* do_swire() was taken from dali and seems to
                               be more robust. Maybe we should use it as a
                               default. */

    if (rv == 0) return; /* successful processing of 45 degree path */

    if (pathtype != 0 && pathtype != 2) {
	sprintf (buf1, "%d", pathtype);
	pr_exit (W, 34, buf1);
	pathtype = 0;
    }
    rv = path ();
skip:
    if (rv && !silent) pr_exit (W+R, 32, "path");
}

/*
** Read an aref/sref-record.
*/
void read_ref (int id)
{
    IMPCELL    *ic;
    DM_PROJECT *proj;
    DM_CELL    *mc_key;
    DM_STREAM  *fp_mc_info;
    int     dx, nx, dy, ny; /* repetition */
    long    b_xl, b_xr, b_yb, b_yt, tmp, tx, ty;
    register long   a, b, c, d;

    /**** pass TWO ****/
    check_rec_id (2, SNAME);
    readingString = SNAME;
    read_rec_contents ();
    readingString = 0;
    strcpy (mc_name, gds_name);

    read_strans ();

    a = b = c = d = 0;
    while (angle >= 360) angle = angle - 360;
    while (angle < 0) angle = angle + 360;
    switch (angle) {	/* rotate (degrees) */
	case   0: a =  magnify; d =  magnify; break;
	case  90: b = -magnify; c =  magnify; break;
	case 180: a = -magnify; d = -magnify; break;
	case 270: b =  magnify; c = -magnify; break;
	default:
	    pr_exit (B+R, 5, "angle");
	    if (id == AREF) {
		Expect (COLROW);
		read_rec_contents ();
		read_rec_header ();
	    }
	    Expect (XY);
	    read_rec_contents ();
	    check_for_prop ();
	    goto skip;
    }
    mir &= 0X8000;
    if (mir) {		/* mirror */
	b = -b;
	d = -d;
    }

    nx = ny = 1;
    if (id == AREF) {
	Expect (COLROW);
	if (rec_id != COLROW) {
	    pr_exit (A+R, 5, "syntax");
	    goto skip;
	}
	read_rec_contents ();
	if (!b) { /* 0 or 180 degree */
	    nx = int_val[0];
	    ny = int_val[1];
	}
	else { /* 90 or 270 degree */
	    ny = int_val[0];
	    nx = int_val[1];
	}
	if (nx < 1 || ny < 1) {
	    pr_exit (W, 21, "COLROW value < 1");
	    goto skip;
	}
	read_rec_header ();
    }

    Expect (XY);
    if (rec_id != XY) {
	pr_exit (A+R, 5, "syntax");
	goto skip;
    }
    nr_coor = (rec_len - 4) / LONG;
    read_rec_contents ();

    dx = dy = 0;
    if (id == AREF) {
	if (nr_coor != 6) {
	    pr_exit (W, 25, "!= 6");
	    goto skip;
	}
	if (nx > 1) { /* x-copies */
	    if (!b) { /* 0 or 180 degree */
		dx = (int_val[2] - int_val[0]) / nx;
	    }
	    else { /* 90 or 270 degree */
		dx = (int_val[4] - int_val[0]) / nx;
	    }
	    if (dx < 0) dx = -dx;
	    if (!dx) pr_exit (W+R, 21, "AREF dx = 0");
	}
	if (ny > 1) { /* y-copies */
	    if (!b) { /* 0 or 180 degree */
		dy = (int_val[5] - int_val[1]) / ny;
	    }
	    else { /* 90 or 270 degree */
		dy = (int_val[3] - int_val[1]) / ny;
	    }
	    if (dy < 0) dy = -dy;
	    if (!dy) pr_exit (W+R, 21, "AREF dy = 0");
	}
	--nx;
	--ny;
    }
    else { /* sref */
	if (nr_coor != 2) {
	    pr_exit (W, 25, "!= 2");
	    goto skip;
	}
	nx = ny = 0;
    }

    tx = int_val[0];
    ty = int_val[1];

    /*
    ** Process aref and sref.
    */
    DEBUG_PRINT "Instantiating '%s'\n", mc_name);

    strcpy (instance, ".");
    check_for_prop ();

    if (!CheckCell (mc_name)) {
	pr_exit (W, 9, mc_name); /* not found */
	goto skip;
    }
    if (tree_ptr -> status == DEF_ERR) {
	pr_exit (W, 33, mc_name); /* cell def. error */
	goto skip;
    }

    ic = tree_ptr -> impcell;

    if (tree_ptr -> bbox) {
	b_xl = tree_ptr -> bbox -> xl;
	b_xr = tree_ptr -> bbox -> xr;
	b_yb = tree_ptr -> bbox -> yb;
	b_yt = tree_ptr -> bbox -> yt;
	DEBUG_PRINT "%s %s: bbox present %ld %ld %ld %ld\n", ms_name, mc_name, b_xl, b_xr, b_yb, b_yt);
    }
    else {
	if (ic) {
	    proj = dmOpenProject (ic -> dmpath, PROJ_READ);
	    mc_key = dmCheckOut (proj, ic -> cellname, ACTUAL, DONTCARE, LAYOUT, READONLY);
	}
	else {
	    mc_key = dmCheckOut (dmproject, mc_name, ACTUAL, DONTCARE, LAYOUT, READONLY);
	}
	if (!mc_key) {
	    pr_exit (A, 16, mc_name);
	    goto skip;
	}

	fp_mc_info = dmOpenStream (mc_key, "info", "r");
	if (dmGetDesignData (fp_mc_info, GEO_INFO) <= 0) {
	    pr_exit (A, 16, mc_name);
	    goto skip;
	}
	dmCloseStream (fp_mc_info, COMPLETE);
	dmCheckIn (mc_key, COMPLETE);

	ALLOC (tree_ptr -> bbox, mod_bbox);
	tree_ptr -> bbox -> xl = b_xl = ginfo.bxl;
	tree_ptr -> bbox -> xr = b_xr = ginfo.bxr;
	tree_ptr -> bbox -> yb = b_yb = ginfo.byb;
	tree_ptr -> bbox -> yt = b_yt = ginfo.byt;
	DEBUG_PRINT "%s %s: bbox using checkout %ld %ld %ld %ld\n", ms_name, mc_name, b_xl, b_xr, b_yb, b_yt);
    }

    gmc.imported = (ic) ? IMPORTED : LOCAL;

    tmp = b_xl;
    b_xl = a * tmp + b * b_yb;
    b_yb = c * tmp + d * b_yb;
    tmp = b_xr;
    b_xr = a * tmp + b * b_yt;
    b_yt = c * tmp + d * b_yt;
    if (b_xl > b_xr) { tmp = b_xl; b_xl = b_xr; b_xr = tmp; } /* swap */
    if (b_yb > b_yt) { tmp = b_yb; b_yb = b_yt; b_yt = tmp; } /* swap */

    switch (angle) {	/* rotate (degrees) */
	case   0:
	    if (mir) ty -= ny * dy;
	    break;
	case  90:
	    if (!mir) tx -= nx * dx;
	    break;
	case 180:
	    tx -= nx * dx;
	    if (!mir) ty -= ny * dy;
	    break;
	case 270:
	    if (mir) tx -= nx * dx;
	    ty -= ny * dy;
	    break;
    }

    tx = round_int ((int)tx, "tx");
    ty = round_int ((int)ty, "ty");
    dx = round_int (dx, "dx");
    dy = round_int (dy, "dy");

    b_xl += tx;
    b_xr += tx + nx * dx;
    b_yb += ty;
    b_yt += ty + ny * dy;

    strcpy (gmc.cell_name, mc_name);
    strcpy (gmc.inst_name, instance);
    gmc.mtx[0] = a;
    gmc.mtx[1] = b;
    gmc.mtx[2] = tx;
    gmc.mtx[3] = c;
    gmc.mtx[4] = d;
    gmc.mtx[5] = ty;
    gmc.bxl = b_xl;
    gmc.bxr = b_xr;
    gmc.byb = b_yb;
    gmc.byt = b_yt;
    gmc.dx = dx;
    gmc.nx = nx;
    gmc.dy = dy;
    gmc.ny = ny;
    DEBUG_PRINT "%s %s: calculated bbox %ld %ld %ld %ld\n\n", ms_name, mc_name, b_xl, b_xr, b_yb, b_yt);
    dmPutDesignData (fp_mc, GEO_MC);

    /* updating cellcall bounding box */
    if (ini_mcbbox) {
	mcbb_xl = b_xl;
	mcbb_xr = b_xr;
	mcbb_yb = b_yb;
	mcbb_yt = b_yt;
	ini_mcbbox = 0;
    }
    else {
	if (mcbb_xl > b_xl) mcbb_xl = b_xl;
	if (mcbb_xr < b_xr) mcbb_xr = b_xr;
	if (mcbb_yb > b_yb) mcbb_yb = b_yb;
	if (mcbb_yt < b_yt) mcbb_yt = b_yt;
    }
    return;
skip:
    if (!silent) pr_exit (W+R, 32, recordName (id));
}

/*
** Read strans and set angle, scaling and mirroring.
*/
void read_strans ()
{
    mir = 0;
    angle = 0;
    magnify = 1;
    read_rec_header ();
    if (rec_id == STRANS) {
	read_rec_contents ();
	mir = int_val[0];
	if (mir & 0X2) pr_exit (W+R, 6, "angle");
	if (mir & 0X4) pr_exit (W+R, 6, "magnification");
	read_rec_header ();
	if (rec_id == MAG) {
	    read_rec_contents ();
	    magnify = (int) (double_val[0] + 0.5);
	    if ((double) magnify != double_val[0]) {
		PE "%s: %d: warning: rounding magnification from %.3f to %d\n",
		    argv0, rec_nr, double_val[0], magnify);
	    }
	    if (magnify < 1) {
		PE "%s: %d: warning: illegal magnification factor %d (set to 1)\n",
		    argv0, rec_nr, magnify);
		magnify = 1;
	    }
	    read_rec_header ();
	}
	if (rec_id == ANGLE) {
	    read_rec_contents ();
	    if (double_val[0] < 0)
		angle = ((long) (double_val[0] - 0.5));
	    else
		angle = ((long) (double_val[0] + 0.5));
	    read_rec_header ();
	}
    }
}

/*
** Search for record-type id.
*/
void search_id (int id)
{
    for (;;) {
	read_rec_header ();
	if (rec_id == id) return;
	if (rec_id == ENDLIB || rec_id == -1) break;
	NEXT_RECORD;
    }
    pr_exit (I, 47, recordName (id)); /* cannot find */
    pr_exit (A+R, 5, "syntax");
}

/*
** Read two- or four-byte integers (length SHORT or LONG).
*/
void read_int (int length)
{
    register int nr, i, value;

    nr = (rec_len - 4) / length;
    if (nr > NOINTS) {
	pr_exit (A, 29, 0);
	return;
    }

    for (i = 0; i < nr; ++i) {
	value = mygetc ();
	value = (value << 8) | mygetc ();
	if (length == LONG) {
	    value = (value << 8) | mygetc ();
	    value = (value << 8) | mygetc ();
	}
	int_val[i] = value;
    }
}

/*
** Read eight-byte real numbers.
*/
void read_double ()
{
    double  ln;
    register int i, nr, e_h;
    unsigned int m_l, m_h;

    nr = (rec_len - 4) / 8;
    if (nr > MAX_DOUBLE) {
	pr_exit (A, 21, "too many values");
	return;
    }

    for (i = 0; i < nr; ++i) {
	e_h = mygetc ();
	m_h = mygetc ();
	m_h = (m_h << 8) | mygetc ();
	m_h = (m_h << 8) | mygetc ();
	m_l = mygetc ();
	m_l = (m_l << 8) | mygetc ();
	m_l = (m_l << 8) | mygetc ();
	m_l = (m_l << 8) | mygetc ();

	if (m_h) {
	    ln = m_l;
	    ln = ldexp (ln + 4294967296.0 * m_h, -56);
	    ln = ldexp (ln, 4 * ((e_h & 0X7F) - 64));
	    if (e_h & 0X80) ln = -ln;
	}
	else ln = 0;
	double_val[i] = ln;
    }
}

/*
** Read ASCII string.
*/
void read_string ()
{
    register int nr, c, i, j = 0;

    if ((nr = rec_len - 4) > MAX_STRLEN) {
	pr_exit (A, 21, "too long string");
	goto skip;
    }

    for (i = 0; i < nr; ++i) {
	if ((c = mygetc ()) == '/') j = 0;
	else gds_name[j++] = c;
    }
    if (j && gds_name[j-1] == '\0') --j;

    /* The 'gds_name' string is ended explicitly,
    ** which wasn't the case before (elias)
    */
    gds_name[j] = '\0';

    /* Compare extracted cell name with conversion table
    ** Change name if specified (elias)
    */
    if (conv_list) {
        i = 0;
        while (conv_name[i][0] && strcmp (gds_name, conv_name[i][0]) != 0) i++;
        if (conv_name[i][0]) {
            strcpy (gds_name, conv_name[i][1]);
	    j = 0;
	    while (gds_name[j] != '\0') ++j;
	}
    }

    if (convert_dollar) {
        /* Check on $-signs is positioned after
        ** (possible) cell-name conversions (elias)
        */
        for (i = 0; i < j; ++i) {
             static int char_conv = 0;
	     if (gds_name[i] == '$') {
	         if (!char_conv) pr_exit (W, 52, 0);
	         char_conv = 1;
	         gds_name[i] = '_';
	     }
        }
    }

    if (j == 0) {
	pr_exit (A, 21, "no string found");
    }
    else if (j > db_maxname) {
	if (readingString == TEXT && convert_long_text)
	    truncDmName (gds_name, 1, 1);
	else if (readingString == TEXT) {
	    if (!silent) pr_exit (W, 54, gds_name);
	} else if (readingString == STRNAME || readingString == SNAME) {
	    if (!silent) pr_exit (W, 55, gds_name);
	} else if (readingString == LIBNAME) {
	    if (!silent) pr_exit (W, 56, gds_name);
	} else {
	    if (!silent) pr_exit (W, 8, gds_name);
	}
	j = db_maxname;
    }
skip:
    gds_name[j] = '\0';    /* although sometimes useless, it will never harm. */
}

/*
** Read the header (length and id) of a GDS record.
*/
void read_rec_header ()
{
    Index = 0;
    rec_len = mygetc () << 8;
    rec_len |= mygetc ();
    if (rec_len == 0) rec_len += 2;

    if (rec_len == 2) rec_id = -1;
    else {
	rec_id = mygetc () << 8;
	rec_id |= mygetc ();
    }

    if (!N_VOL && rec_id == TAPENUM) {
	next_volume ();
	read_rec_header ();
    }
}

/*
** Read contents of a GDS record.
*/
void read_rec_contents ()
{
    switch (rec_id & 0XFF) {
	case 0XFF:
	case 0:
	case 4:
	    break;
	case 1:
	case 2:
	    read_int (SHORT);
	    break;
	case 3:
	    read_int (LONG);
	    break;
	case 5:
	    read_double ();
	    break;
	case 6:
	    read_string ();
	    break;
    }
    NEXT_RECORD;
}

/*
** Check record id.
*/
void check_rec_id (int nr, int id)
{
    for (;;) {
	read_rec_header ();
	if (rec_id == id) return;
	if (--nr < 0 || rec_id == ENDLIB || rec_id == -1) break;
	NEXT_RECORD;
    }
    Expect (id);
    pr_exit (A+R, 5, "syntax");
}

/*
** Process the path type.
*/
int path ()
{
    int xr, xl, yb, yt;
    int dir, prev_dir;
    register int i, delta_x, delta_y;

    for (i = 2; i < nr_coor; i += 2) {
	if (int_val[i]   != int_val[i-2]
	 && int_val[i+1] != int_val[i-1]) return (swire ());
    }

    delta_y = 0; /* for compiler uninit warning */

    if (width & 1) pr_exit (W, 21, "odd width");
    width /= 2;
    prev_dir = -1;
    for (i = 2; i < nr_coor;) {
	if (!(delta_x = int_val[i] - int_val[i-2])) {
	    if (!(delta_y = int_val[i+1] - int_val[i-1])) {
		pr_exit (W, 25, "dx=0,dy=0");
		return (1);
	    }
	    dir = 1; /* y-direction */
	}
	else {
	    dir = 0; /* x-direction */
	}
	if (dir == prev_dir) {
	    pr_exit (W, 25, "dir=prev_dir");
	    return (1);
	}
	prev_dir = dir;

	if (!dir) {		/* x-direction */
	    if (delta_x > 0) {
		xl = int_val[i] - delta_x - width;
		xr = int_val[i] + width;
	    }
	    else {
		xl = int_val[i] - width;
		xr = int_val[i] - delta_x + width;
	    }
	    yb = int_val[i+1] - width;
	    yt = int_val[i+1] + width;
	}
	else {			/* y-direction */
	    xl = int_val[i] - width;
	    xr = int_val[i] + width;
	    if (delta_y > 0) {
		yb = int_val[i+1] - delta_y - width;
		yt = int_val[i+1] + width;
	    }
	    else {
		yb = int_val[i+1] - width;
		yt = int_val[i+1] - delta_y + width;
	    }
	}
	i += 2;
	if (pathtype == 0) {
	    if (i == 4) { /* first box */
		if (!dir) xl += width;
		else      yb += width;
	    }
	    else if (i == nr_coor) { /* last box */
		if (!dir) xr -= width;
		else      yt -= width;
	    }
	}
	if (box (xl, xr, yb, yt)) return (1);
    }
    return (0); /* ok */
}

double scale_coord (int v)
/* 'v' is multiplied by 'resolution' to obtain */
/* the (unrounded) database coordinate value.  */
{
    double tmp_d;

    tmp_d = resolution * v;
    if (tmp_d >= 0.25 * MAX32 - 1 || tmp_d <= -0.25 * MAX32 + 1) {
        char buf[32];
        sprintf (buf, "%ld", (long)(0.25 * MAX32 - 1));
	if (silent)
	    pr_exit (A, 62, buf);
	else
	    pr_exit (A, 57, buf);
    }
    return (tmp_d);
}

double round_float (int v, char *s)
/* After scaling v, the resulting coordinate value is rounded to a multiple
   of 0.25 (since only these values can be handled by the layout tools). */
{
    double tmp_d = scale_coord (v);
    double tmp2_d = (tmp_d > 0.0 ? 4 * tmp_d + 0.5 : 4 * tmp_d - 0.5);
    double new_d = 0.25 * (long) tmp2_d;

    /* The decimal precision of doubles is approx. 1e-15.  Therefore, we only
       report relative differences that are larger than 1e-14.
    */
    if (Abs (tmp_d - new_d) > 1e-14 * Abs (tmp_d)) {
	if (!silent) /* SdeG4.69 */
	PE "%s: %d: warning: rounding %s from %.8f to %.2f\n",
	    argv0, rec_nr, s, tmp_d, new_d);
	roundingWarning = 1;
    }
    return (new_d);
}

int round_int (int v, char *s)
/* After scaling v, the resulting coordinate value is rounded to an integer. */
{
    double tmp_d = scale_coord (v);
    v = (int) ((v < 0) ? (tmp_d - 0.5) : (tmp_d + 0.5));

    /* The decimal precision of doubles is approx. 1e-15.  Therefore, we only
       report relative differences that are larger than 1e-14.
    */
    if (Abs (tmp_d - v) > 1e-14 * Abs (tmp_d)) {
	if (!silent) /* SdeG4.69 */
	PE "%s: %d: warning: rounding %s from %.8f to %d\n",
	    argv0, rec_nr, s, tmp_d, v);
	roundingWarning = 1;
    }
    return (v);
}

void update_cell_bbox (long xl, long xr, long yb, long yt)
{
    /* updating cell bounding box */
    if (ini_bbbox) {
	bbnd_xl = xl;
	bbnd_xr = xr;
	bbnd_yb = yb;
	bbnd_yt = yt;
	ini_bbbox = 0;
    }
    else {
	if (xl < bbnd_xl) bbnd_xl = xl;
	if (xr > bbnd_xr) bbnd_xr = xr;
	if (yb < bbnd_yb) bbnd_yb = yb;
	if (yt > bbnd_yt) bbnd_yt = yt;
    }
}

int box (int xl, int xr, int yb, int yt)
{
    int tmp_i;

    xl = round_int (xl, "xl");
    xr = round_int (xr, "xr");
    yb = round_int (yb, "yb");
    yt = round_int (yt, "yt");

    /* We already assign gbox.xl etc. here so that we can use the
       values for doLabel() and doTerm() even when x=x,y=y.
    */

    if (xl > xr) { tmp_i = xl; xl = xr; xr = tmp_i; } /* swap */
    if (yb > yt) { tmp_i = yb; yb = yt; yt = tmp_i; } /* swap */

    gbox.layer_no = mask_nr;
    gbox.bxl = gbox.xl = xl;
    gbox.bxr = gbox.xr = xr;
    gbox.byb = gbox.yb = yb;
    gbox.byt = gbox.yt = yt;

    if (xl == xr || yb == yt) {
	pr_exit (W, 25, "x=x,y=y"); /* illegal box co-ordinates */
	return (1);
    }

    update_cell_bbox (gbox.xl, gbox.xr, gbox.yb, gbox.yt);

    dmPutDesignData (fp_box, GEO_BOX);
    return (0); /* ok */
}

/*
** Check the poly co-ordinates, calculate the bounding-box
** and place the data in the ICD database.
*/
int poly ()
{
    long    b_xl, b_xr, b_yb, b_yt;
    register int    i;
    int     ind_4;
    int     x0, y0, x1, y1, flag = mode45;
#ifdef CHECK_INTERSECT
    int     j;
    double  xa, ya, xb, yb, xp, yp, xq, yq;
    double  DXab, DYab, DXpq, DYpq;
    double  numnab, numnpq, numxs, numys, denomxs, denomys;
#endif				/* CHECK_INTERSECT */
    double d1, d2, d3, d4;

/*
** DY contains the difference between the y-values.
** DX between the x-values.  numn contains the value of
** the numerator of n; denomn contains the value of the
** denominator of n (see the main expression of a line:
** y = mx + n).  numxs till denomys contain the values of
** the numerator and the denominator of the co-ordinates of
** the intersection.  result denotes whether a certain point
** is an element of a linepart (1) or not (0).
*/
    ind_4 = nr_coor - 4;

#if 0
    /* check on co-ordinates */ /* done by read_boundary! */
    for (i = 0; i <= ind_4; i += 2)
	if (int_val[i] == int_val[i + 2] && int_val[i + 1] == int_val[i + 3]) {
	    pr_exit (W, 12, 0);
	    return (1);
	}
#endif

#ifdef CHECK_INTERSECT
 /* check on intersections */

    for (i = 0; i < ind_4; i += 2) {
	xa = int_val[i];
	ya = int_val[i + 1];
	xb = int_val[i + 2];
	yb = int_val[i + 3];

	for (j = i + 2; j <= ind_4; j += 2) {
	    xp = int_val[j];
	    yp = int_val[j + 1];
	    xq = int_val[j + 2];
	    yq = int_val[j + 3];

	    if ((yb - ya) * (xq - xp) == (yq - yp) * (xb - xa)) {
	    /* the same direction coefficients */
		if (j == i + 2 || j == i + ind_4) {
		/* two adjacent lineparts:illegal direction change */
		    pr_exit (W, 11, 0);
		    return (1);
		}
	    /* real parallel lineparts or lineparts with the same carrier
	    */
		if ((xb * ya - xa * yb) * (xq - xp) ==
			(xq * yp - xp * yq) * (xb - xa)) {
		/* the lineparts have the same carrier; check whether the
		   lineparts overlap or not */
		/* test==1 if the lineparts (partly overlap */

		/* point p on linepart ab ? */
		    if (test (xa, ya, xb, yb, xp, 1.0, yp, 1.0) == 1) {
			pr_exit (W, 14, 0);
			return (1);
		    }
		/* point q on linepart ab ? */
		    if (test (xa, ya, xb, yb, xq, 1.0, yq, 1.0) == 1) {
			pr_exit (W, 14, 0);
			return (1);
		    }
		/* point a on linepart pq ? */
		    if (test (xp, yp, xq, yq, xa, 1.0, ya, 1.0) == 1) {
			pr_exit (W, 14, 0);
			return (1);
		    }
		/* point b on linepart pq ? */
		    if (test (xp, yp, xq, yq, xb, 1.0, yb, 1.0) == 1) {
			pr_exit (W, 14, 0);
			return (1);
		    }
		}
	    }
	    else {		/* not the same directioncoefficients; the
				   LINES intersect, the lineparts maybe */

		if (j != i + 2 && j != i + ind_4) {
		/* No adjacent lineparts; check on intersecting or
		   touching */
		    DYab = yb - ya;
		    DXab = xb - xa;
		    numnab = xb * ya - xa * yb;
		    DYpq = yq - yp;
		    DXpq = xq - xp;
		    numnpq = xq * yp - xp * yq;

		/* determining the intersection of the LINES */
		/* first the x co-ordinate */
		    numxs = numnpq * DXab - numnab * DXpq;
		    denomxs = DYab * DXpq - DYpq * DXab;

		/* the y co-ordinate */
		    numys = numnpq * DYab - numnab * DYpq;
		    denomys = denomxs;

		/* check whether the intersection is an element of both
		   lineparts or not */
		    if (test (xa, ya, xb, yb, numxs, denomxs, numys, denomys) == 1) {
		    /* the intersection is an element of the linepart ab
		    */
			if (test (xp, yp, xq, yq, numxs, denomxs, numys, denomys) == 1) {
			/* the intersection is an element of both
			   lineparts */
			    pr_exit (W, 10, 0);
			    return (1);
			}
		    }
		}
	    }
	}
    }
#endif				/* CHECK_INTERSECT */

    /* calculating the bounding box */
    x0 = b_xr = b_xl = int_val[0];
    y0 = b_yt = b_yb = int_val[1];

    for (i = 2; i < nr_coor;) {
	x1 = int_val[i++];
	y1 = int_val[i++];
	if (x1 < b_xl) b_xl = x1;
	else if (x1 > b_xr) b_xr = x1;
	if (y1 < b_yb) b_yb = y1;
	else if (y1 > b_yt) b_yt = y1;
	if (flag) {
	    if ((x0 -= x1) < 0) x0 = -x0;
	    if ((y0 -= y1) < 0) y0 = -y0;
	    if (x0 && y0 && x0 != y0) {
		flag = 0;
		pr_exit (W+R, 35, 0); /* non-45 degree */
	    }
	    x0 = x1;
	    y0 = y1;
	}
    }

    d1 = floor (scale_coord (b_xl));
    d2 = ceil (scale_coord (b_xr));
    d3 = floor (scale_coord (b_yb));
    d4 = ceil (scale_coord (b_yt));

    b_xl = gnor_ini.bxl = (long) d1;
    b_xr = gnor_ini.bxr = (long) d2;
    b_yb = gnor_ini.byb = (long) d3;
    b_yt = gnor_ini.byt = (long) d4;

    update_cell_bbox (b_xl, b_xr, b_yb, b_yt);

    nr_coor -= 2;  /* first point == last point */
    gnor_ini.layer_no = mask_nr;
    gnor_ini.elmt = POLY_NOR;
    gnor_ini.no_xy = nr_coor / 2;
    dmPutDesignData (fp_nor, GEO_NOR_INI);

    for (i = 0; i < nr_coor;) {
	gnor_xy.x = round_float (int_val[i++], "x");
	gnor_xy.y = round_float (int_val[i++], "y");
	dmPutDesignData (fp_nor, GEO_NOR_XY);
    }
    return (0); /* ok */
}

int swire ()
{
    double tmp_d;
    double rad45;
    long   b_xl, b_xr, b_yb, b_yt;
    double bxl, bxr, byb, byt;
    double d_x, d_y, a1, a2;
    double dx1, dy1, dx2, dy2;
    double c1xr, c1yr, a1xy, b1xy, half_width;
    double c2xl, c2yl, c2xr, c2yr, a2xy, b2xy;
    double aspx, aspy, bspx, bspy;
    register int i;
    int x, y, flag = mode45;
    double td1, td2, td3, td4;

    if (pathtype == 2) {
	pr_exit (W, 21, "pathtype 2 not supported at this moment");
	pr_exit (W, 21, "using pathtype 0 for swire");
    }

    half_width = (double) width / 2;
    rad45 = atan (1.0);
    c1xr = int_val[0];
    c1yr = int_val[1];

    bxl = bxr = byb = byt = 0;  /* added for compiler uninit warning */
    a1 = dx1 = dy1 = a1xy = b1xy = 0; /* for compiler uninit warning */

    /* calculating the bounding box */
    for (i = 2;;) {
	dx2 = x = int_val[i]   - int_val[i-2];
	dy2 = y = int_val[i+1] - int_val[i-1];
	if (x == 0) {
	    if (y == 0) {
		pr_exit (W, 24, 0); /* incr. values are 0 */
		return (1);
	    }
	    if (y > 0) a2 = 2 * rad45;
	    else a2 = 6 * rad45;
	}
	else {
	    a2 = atan (dy2 / dx2);
	    if (x > 0) {
		if (y < 0) { a2 += 8 * rad45; y = -y; }
	    }
	    else { /* x < 0 */
		a2 += 4 * rad45;
		if (y > 0) y = -y;
	    }
	    if (flag && y && x != y) {
		flag = 0;
		pr_exit (W+R, 35, 0); /* non-45 degree */
	    }
	}
	d_x = half_width * sin (a2);
	d_y = half_width * cos (a2);
	c2xl = c1xr;
	c2yl = c1yr;
	c2xr = c2xl + dx2;
	c2yr = c2yl + dy2;
	a2xy = (c2xr - d_x) * (c2yl + d_y) - (c2xl - d_x) * (c2yr + d_y);
	b2xy = (c2xr + d_x) * (c2yl - d_y) - (c2xl + d_x) * (c2yr - d_y);

	if (i == 2) { /* begin of swire */
	    if (dx2 > 0) {
		bxl = (d_x > 0) ? (c2xl - d_x) : (c2xl + d_x);
		bxr = (d_x > 0) ? (c2xr + d_x) : (c2xr - d_x);
	    }
	    else {
		bxl = (d_x > 0) ? (c2xr - d_x) : (c2xr + d_x);
		bxr = (d_x > 0) ? (c2xl + d_x) : (c2xl - d_x);
	    }
	    if (dy2 > 0) {
		byb = (d_y > 0) ? (c2yl - d_y) : (c2yl + d_y);
		byt = (d_y > 0) ? (c2yr + d_y) : (c2yr - d_y);
	    }
	    else {
		byb = (d_y > 0) ? (c2yr - d_y) : (c2yr + d_y);
		byt = (d_y > 0) ? (c2yl + d_y) : (c2yl - d_y);
	    }
	}
	else {
	    tmp_d = (a1 > a2) ? (a1 - a2) : (a2 - a1);
	    if (tmp_d > (2 * rad45) && tmp_d < (6 * rad45)) {
		pr_exit (W, 15, 0); /* too big direction change */
		return (1);
	    }
	    tmp_d = dx2 * dy1 - dx1 * dy2;
	    if (tmp_d == 0) {
		pr_exit (W, 25, "dir=prev_dir");
		return (1);
	    }
	    else {
		aspx = (dx1 * a2xy - dx2 * a1xy) / tmp_d;
		aspy = (dy1 * a2xy - dy2 * a1xy) / tmp_d;
		bspx = (dx1 * b2xy - dx2 * b1xy) / tmp_d;
		bspy = (dy1 * b2xy - dy2 * b1xy) / tmp_d;
		if (aspx > bspx) {
		    if (bspx < bxl) bxl = bspx;
		    if (aspx > bxr) bxr = aspx;
		}
		else {
		    if (aspx < bxl) bxl = aspx;
		    if (bspx > bxr) bxr = bspx;
		}
		if (aspy > bspy) {
		    if (bspy < byb) byb = bspy;
		    if (aspy > byt) byt = aspy;
		}
		else {
		    if (aspy < byb) byb = aspy;
		    if (bspy > byt) byt = bspy;
		}
	    }
	}
	if ((i += 2) >= nr_coor) break;
	a1 = a2;
	dx1 = dx2;
	dy1 = dy2;
	a1xy = a2xy;
	b1xy = b2xy;
	c1xr = c2xr;
	c1yr = c2yr;
    }

    if (dx2 > 0) {
	tmp_d = (d_x > 0) ? (c2xr + d_x) : (c2xr - d_x);
	if (tmp_d > bxr) bxr = tmp_d;
    }
    else {
	tmp_d = (d_x > 0) ? (c2xr - d_x) : (c2xr + d_x);
	if (tmp_d < bxl) bxl = tmp_d;
    }
    if (dy2 > 0) {
	tmp_d = (d_y > 0) ? (c2yr + d_y) : (c2yr - d_y);
	if (tmp_d > byt) byt = tmp_d;
    }
    else {
	tmp_d = (d_y > 0) ? (c2yr - d_y) : (c2yr + d_y);
	if (tmp_d < byb) byb = tmp_d;
    }

    td1 = floor (scale_coord ((int)bxl));
    td2 = ceil (scale_coord ((int)bxr));
    td3 = floor (scale_coord ((int)byb));
    td4 = ceil (scale_coord ((int)byt));

    b_xl = gnor_ini.bxl = (long) td1;
    b_xr = gnor_ini.bxr = (long) td2;
    b_yb = gnor_ini.byb = (long) td3;
    b_yt = gnor_ini.byt = (long) td4;

    update_cell_bbox (b_xl, b_xr, b_yb, b_yt);

    gnor_ini.layer_no = mask_nr;
    gnor_ini.elmt = WIRE_NOR;
    gnor_ini.no_xy = nr_coor / 2 + 1;
    dmPutDesignData (fp_nor, GEO_NOR_INI);

    gnor_xy.x = round_float (width, "x");
    gnor_xy.y = 0;
    dmPutDesignData (fp_nor, GEO_NOR_XY);
    gnor_xy.x = round_float (int_val[0], "x");
    gnor_xy.y = round_float (int_val[1], "y");
    dmPutDesignData (fp_nor, GEO_NOR_XY);
    for (i = 2; i < nr_coor; i += 2) {
	x = int_val[i]   - int_val[i-2];
	y = int_val[i+1] - int_val[i-1];
	gnor_xy.x = round_float (x, "x");
	gnor_xy.y = round_float (y, "y");
	dmPutDesignData (fp_nor, GEO_NOR_XY);
    }
    return (0); /* ok */
}

#ifdef CHECK_INTERSECT
/*
** The following function tests whether a point (denoted by
** numx till denomy) is an element of a linepart (denoted by
** x0 till y1) or not.  If it is an element of the linepart,
** then the return code is 1, otherwise 0.
*/
int test (double x0, double y0, double x1, double y1, double numx, double denomx, double numy, double denomy)
{
    double  xmin, xmax, ymin, ymax;

    xmin = Min (x0, x1);
    xmax = Max (x0, x1);
    ymin = Min (y0, y1);
    ymax = Max (y0, y1);

 /* check whether the point is an element of the linepart ** between the
    points (x0,y0) and (x1,y1) */
    if (denomx >= 0) {
	if (numx < xmin * denomx || numx > xmax * denomx)
	    return (0);
	if (numy < ymin * denomy || numy > ymax * denomy)
	    return (0);
    }
    else {			/* negative denominators, the signs have
				   to be switched */
	if (numx > xmin * denomx || numx < xmax * denomx)
	    return (0);
	if (numy > ymin * denomy || numy < ymax * denomy)
	    return (0);
    }
    return (1);
}
#endif				/* CHECK_INTERSECT */

/*
** Routines, which handle the internal tree structures.
*/
int append_tree (char *name, struct name_tree **head)
{
    register int cmp;

    if ((tree_ptr = *head)) {
	cmp = strcmp (name, tree_ptr -> name);
	if (cmp > 0)
	    return (append_tree (name, &(tree_ptr -> rchild)));
	if (cmp < 0)
	    return (append_tree (name, &(tree_ptr -> lchild)));
	return (1);		/* found */
    }

    ALLOC (tree_ptr, name_tree);
    tree_ptr -> name = strsave (name);
    tree_ptr -> impcell = NULL;
    tree_ptr -> bbox    = NULL;
    tree_ptr -> status  = TRUE;
    tree_ptr -> rchild  = NULL;
    tree_ptr -> lchild  = NULL;
    *head = tree_ptr;
    return (0);			/* not found */
}

int check_tree (char *name, struct name_tree *ptr)
{
    register int cmp;

    if (ptr) {
	cmp = strcmp (name, ptr -> name);
	if (cmp > 0)
	    return (check_tree (name, ptr -> rchild));
	if (cmp < 0)
	    return (check_tree (name, ptr -> lchild));
	tree_ptr = ptr;
	return (1);		/* found */
    }
    return (0);			/* not found */
}

void ini_modtree ()
{
    register char **ml;
    register IMPCELL **iml;

    mod_tree = NULL;

    if ((ml = (char **) dmGetMetaDesignData (CELLLIST, dmproject, LAYOUT))
    && (iml = (IMPCELL **) dmGetMetaDesignData (IMPORTEDCELLLIST, dmproject, LAYOUT))) {
	for (; *ml; ++ml) {
	    if (AppendCell (*ml)) pr_exit (W, 23, *ml);
	}

	for (; *iml; ++iml) {
	    if (AppendCell ((*iml) -> alias)) {
		pr_exit (W, 23, (*iml) -> alias);
	    }
	    tree_ptr -> impcell = *iml;
	}
    }
}

/*
** Write the 3 bounding-boxes to the info-file.
*/
void write_info ()
{
    /**** pass TWO ****/
    if (!tree_ptr -> bbox) { /* no element bbox */
	bbnd_xl = bbnd_xr = bbnd_yb = bbnd_yt = 0;
	if (ini_mcbbox) { /* no cellcalls */
	    mcbb_xl = mcbb_xr = mcbb_yb = mcbb_yt = 0;
	    pr_exit (W+R, 26, ms_name); /* empty */
	}
	ALLOC (tree_ptr -> bbox, mod_bbox);
	tree_ptr -> bbox -> xl = ginfo.bxl = mcbb_xl;
	tree_ptr -> bbox -> xr = ginfo.bxr = mcbb_xr;
	tree_ptr -> bbox -> yb = ginfo.byb = mcbb_yb;
	tree_ptr -> bbox -> yt = ginfo.byt = mcbb_yt;
    }
    else {
	bbnd_xl = tree_ptr -> bbox -> xl;
	bbnd_xr = tree_ptr -> bbox -> xr;
	bbnd_yb = tree_ptr -> bbox -> yb;
	bbnd_yt = tree_ptr -> bbox -> yt;
	if (ini_mcbbox) { /* no cellcalls */
	    mcbb_xl = mcbb_xr = mcbb_yb = mcbb_yt = 0;
	    ginfo.bxl = bbnd_xl;
	    ginfo.bxr = bbnd_xr;
	    ginfo.byb = bbnd_yb;
	    ginfo.byt = bbnd_yt;
	}
	else {
	    ginfo.bxl = Min (bbnd_xl, mcbb_xl);
	    ginfo.bxr = Max (bbnd_xr, mcbb_xr);
	    ginfo.byb = Min (bbnd_yb, mcbb_yb);
	    ginfo.byt = Max (bbnd_yt, mcbb_yt);
	    tree_ptr -> bbox -> xl = ginfo.bxl;
	    tree_ptr -> bbox -> xr = ginfo.bxr;
	    tree_ptr -> bbox -> yb = ginfo.byb;
	    tree_ptr -> bbox -> yt = ginfo.byt;
	}
    }

    DEBUG_PRINT "%s: encapsul bbox %ld %ld %ld %ld\n",
	ms_name, ginfo.bxl, ginfo.bxr, ginfo.byb, ginfo.byt);
    dmPutDesignData (fp_info, GEO_INFO);

    ginfo.bxl = mcbb_xl;
    ginfo.bxr = mcbb_xr;
    ginfo.byb = mcbb_yb;
    ginfo.byt = mcbb_yt;
    DEBUG_PRINT "%s: mc bbox %ld %ld %ld %ld\n",
	ms_name, ginfo.bxl, ginfo.bxr, ginfo.byb, ginfo.byt);
    dmPutDesignData (fp_info, GEO_INFO);

    ginfo.bxl = bbnd_xl;
    ginfo.bxr = bbnd_xr;
    ginfo.byb = bbnd_yb;
    ginfo.byt = bbnd_yt;
    DEBUG_PRINT "%s: box  bbox %ld %ld %ld %ld\n",
	ms_name, ginfo.bxl, ginfo.bxr, ginfo.byb, ginfo.byt);
    dmPutDesignData (fp_info, GEO_INFO);
}

/*
** Open GDS file.
*/
void open_gds ()
{
    if (vol_nr > nr_files) pr_exit (A, 1, 0);
    strcpy (file_name, vector[vol_nr]);
    if (stat (file_name, &stat_buf) == -1) pr_exit (A, 37, file_name);
    if ((stat_buf.st_mode & S_IFREG) != S_IFREG) pr_exit (A, 38, file_name);
    /* open in binary mode for reading !!!!!!!! */
    if (!(fp_gds = fopen (file_name, "rb"))) pr_exit (A, 2, file_name);
}

/*
** Check for end of volume and open next volume.
*/
void next_volume ()
{
    N_VOL = TRUE;
    fclose (fp_gds);
    if (pass == 1) {
	if (vol_nr > 1) {
	    read_rec_contents ();
	    if (vol_nr != int_val[0])
		pr_exit (A, 36, file_name);
	}
	else
	    read_tape_id ();
    }
    vol_nr++;
    open_gds ();
    check_rec_id (0, TAPENUM);
    read_tape_id ();
    N_VOL = FALSE;
}

/*
** Read tape id.
*/
void read_tape_id ()
{
    register int i;

    read_rec_contents ();
    if (vol_nr != int_val[0]) pr_exit (A, 36, file_name);
    check_rec_id (0, TAPECODE);
    read_rec_contents ();
    if (vol_nr == 1) {
	t_code[0] = int_val[0];
	t_code[1] = int_val[1];
	t_code[2] = int_val[2];
    }
    else
	for (i = 0; i < 3; ++i)
	    if (t_code[i] != int_val[i])
		pr_exit (A, 36, file_name);
    check_rec_id (0, LIBNAME);
    readingString = LIBNAME;
    read_rec_contents ();
    readingString = 0;
    if (vol_nr > 1 && strcmp (libname, gds_name))
	pr_exit (A, 36, file_name);
}

/*
** DB-error routines.
*/
void dmError (char *s)
{
    dmPerror (s);
    pr_exit (A, 22, 0);
}

/*
** Process interrupts.
*/
void sig_handler (int sig) /* signal handler */
{
    char    rbuf[6];
    signal (SIGINT, SIG_IGN);	/* ignore intr signal */
#ifdef SIGQUIT
    signal (SIGQUIT, SIG_IGN);	/* ignore quit signal */
#endif
    sprintf (rbuf, "%d", sig);
    pr_exit (A, 20, rbuf);
}

/*
** Give an error message (mode=A(bort)) or a warning (mode=W(arning))
** When the mode is E(xit), the program exits without error message.
** When the mode is W or I(nfo), the program does not an exit.
*/
void pr_exit (int mode, int err_no, char *cs)
{
    if ((err_no == 28 || err_no == 32) && allow_unknown_numbers) return;

    if (mode == J) if (silent) return;

    PE "%s: ", argv0);
    if (mode & R) { PE "%d: ", rec_nr); mode -= R; }
    if (mode == W) PE "warning: ");
    if (mode == A || mode == B) PE "error: ");

    if (err_no < 0 || err_no >= sizeof (err_list) / sizeof (char *)) {
	PE "due to number '%d'", err_no);
	if (cs && *cs) PE ", %s", cs);
    }
    else
	PE err_list[err_no], cs);
    PE "\n");

    if (debug) return;
    if (mode == A || (mode == B && !go_on)) {
	dmQuit ();
	PE "%s: -- program aborted --\n", argv0);
	exit (1);
    }
    if (mode == E) exit (0);
}

static char *recordNames[] =
{
    "header", "bgnlib", "libname", "units", "endlib",
    "bgnstr", "strname", "endstr", "boundary", "path",
    "sref", "aref", "text", "layer", "datatype",
    "width", "xy", "endel", "sname", "colrow",
    "textnode", "node", "texttype", "presentation", "spacing",
    "string", "strans", "mag", "angle", "uinteger",
    "ustring", "reflibs", "fonts", "pathtype", "generations",
    "attrtable", "styptable", "strtype", "elflags", "elkey",
    "linktype", "linkkeys", "nodetype", "propattr", "propvalue",
    "box", "boxtype", "plex", "bgnextn", "endextn",
    "tapenum", "tapecode", "strclass", "reserved", "format",
    "mask", "endmasks"
};

char *recordName (int id)
{
    static char rbuf[16];

    id = (id & 0XFF00) >> 8;
    if (id >= sizeof (recordNames) / sizeof (char *)) {
	sprintf (rbuf, "#%d", id);
	return (rbuf);
    }
    return (recordNames[id]);
}

/*
** Check and execute for properties.
*/
void check_for_prop ()
{
    static   int termside;
    static   int labelside;
    register int i, foundprop = 0;
    int terminal, label, val0;

    val0 = int_val[0]; /* save */

loop1:
    read_rec_header ();
    switch (rec_id) {
	case PROPATTR:
	    DEBUG_PRINT "check_for_prop %x propattr\n", rec_id);
	    read_rec_contents ();
	    read_rec_header ();
	    switch (rec_id) {
		case PROPVALUE:
		    DEBUG_PRINT "check_for_prop %x propval\n", rec_id);
		    read_rec_contents ();
		    break;
		default:
		    pr_exit (I, 21, "no property value found");
	    }
	    property[foundprop].attr = int_val[0];
	    strcpy (property[foundprop].value, gds_name);
	    ++foundprop;
	    goto loop1;
	case ENDEL:
	    break;
	default:
	    /* expected property attribute not found */
	    pr_exit (I, 48, recordName (rec_id));
	    pr_exit (A+R, 5, "syntax");
	    return;
    }

#ifdef PROP_DEBUG
    PE "found %d properties\n", foundprop);
#endif /* PROP_DEBUG */

    terminal = label = -1;

    /* Execute properties */
    for (i = 0; i < foundprop; ++i) {
#ifdef PROP_DEBUG
	 PE "prop: %d %s\n", property[i].attr, property[i].value);
#endif /* PROP_DEBUG */
	 if (property[i].attr == prop_termside) {
	     termside = atoi (property[i].value);
	     DEBUG_PRINT "PROP_TERMSIDE %d\n", termside);
         }
	 else
	 if (property[i].attr == prop_termlay) {
	     lay_code = atoi (property[i].value);
	     DEBUG_PRINT "PROP_TERMLAY  %d\n", lay_code);
         }
	 else
	 if (property[i].attr == prop_instance) {
	     DEBUG_PRINT "PROP_INSTANCE %s\n", property[i].value);
	     strncpy (instance, property[i].value, db_maxname);
         }
	 else
	 if (property[i].attr == prop_term) {
	     DEBUG_PRINT "PROP_TERMINAL %s\n", property[i].value);
	     terminal = i;
         }
	 else
	 if (property[i].attr == prop_labelside) {
	     labelside = atoi (property[i].value);
	     DEBUG_PRINT "PROP_LABELSIDE %d\n", labelside);
         }
	 else
	 if (property[i].attr == prop_labellay) {
	     lay_code = atoi (property[i].value);
	     DEBUG_PRINT "PROP_LABELLAY  %d\n", lay_code);
         }
	 else
	 if (property[i].attr == prop_label) {
	     DEBUG_PRINT "PROP_LABEL %s\n", property[i].value);
	     label = i;
         }
	 else {
	    sprintf (nbuf, "propattr(%d)", property[i].attr);
	    pr_exit (W, 32, nbuf);
	 }
    }

    int_val[0] = val0; /* restore */

    if (terminal >= 0) {
	if (!silent && label >= 0) pr_exit (W, 21, "found propattr terminal and label, label attr skipped!");
	doTerm (property[terminal].value, termside);
    }
    else if (label >= 0) {
	doLabel (property[label].value, labelside);
    }
}

void doTerm (char *termname, int termside)
{
    int no;

    DEBUG_PRINT "%s %d %d\n", termname, lay_code, termside);
    if (data_type >= 0)
        sprintf (nbuf, "'%d' with datatype '%d'", lay_code, data_type);
    else
        sprintf (nbuf, "'%d' (no datatype)", lay_code);
    if (lay_code < 0 || lay_code > MAX_GDS_LAYNR
        || (no = findMasknr (lay_code, data_type)) < 0) {
	if (!silent) {
	    pr_exit (W, 28, nbuf);
	    pr_exit (W, 32, "propattr(terminal)");
	}
	return;
    }

    if (!boundary_box) {
	if (!silent) pr_exit (W, 21, "propattr(terminal) only possible for boundary box, element skipped!");
	return;
    }

    gterm.layer_no = no;
    strcpy (gterm.term_name, termname);
    gterm.bxl = gterm.xl = gbox.xl;
    gterm.bxr = gterm.xr = gbox.xr;
    gterm.byb = gterm.yb = gbox.yb;
    gterm.byt = gterm.yt = gbox.yt;
    dmPutDesignData (fp_term, GEO_TERM);

    update_cell_bbox (gbox.xl, gbox.xr, gbox.yb, gbox.yt);
}

void doLabel (char *labelname, int labelside)
{
    int no;

    DEBUG_PRINT "%s %d %d\n", labelname, lay_code, labelside);
    if (data_type >= 0)
        sprintf (nbuf, "'%d' with datatype '%d'", lay_code, data_type);
    else
        sprintf (nbuf, "'%d' (no datatype)", lay_code);
    if (lay_code < 0 || lay_code > MAX_GDS_LAYNR
        || (no = findMasknr (lay_code, data_type)) < 0) {
	if (!silent) {
	    pr_exit (W, 28, nbuf);
	    pr_exit (W, 32, "propattr(label)");
	}
	return;
    }

    if (!boundary_box) {
	if (!silent) pr_exit (W, 21, "propattr(label) only possible for boundary box, element skipped!");
	return;
    }

    ganno.type = GA_LABEL;
    ganno.o.Label.maskno = no;
    strcpy (ganno.o.Label.name, labelname);
    strcpy (ganno.o.Label.Class, "");
    ganno.o.Label.x = gbox.xl;
    ganno.o.Label.y = gbox.yb;
    ganno.o.Label.ay = 0;
    ganno.o.Label.ax =  -1;  /* left adjusted */
    dmPutDesignData (fp_anno, GEO_ANNOTATE);

    update_cell_bbox (gbox.xl, gbox.xl, gbox.yb, gbox.yb);
}

int _quadragon (double x1, double y1, double x2, double y2, double x3, double y3, double x4, double y4)
{
    long b_xl, b_xr, b_yb, b_yt;

    /* calculating the bounding box */

    double d1 = floor (Min (x1, Min (x2, Min (x3, x4))));
    double d2 = ceil (Max (x1, Max (x2, Max (x3, x4))));
    double d3 = floor (Min (y1, Min (y2, Min (y3, y4))));
    double d4 = ceil (Max (y1, Max (y2, Max (y3, y4))));

    b_xl = gnor_ini.bxl = (long) d1;
    b_xr = gnor_ini.bxr = (long) d2;
    b_yb = gnor_ini.byb = (long) d3;
    b_yt = gnor_ini.byt = (long) d4;

    update_cell_bbox (b_xl, b_xr, b_yb, b_yt);

    gnor_ini.layer_no = mask_nr;
    gnor_ini.elmt = POLY_NOR;
    gnor_ini.no_xy = 1;
    if (x2 != x1 || y2 != y1) gnor_ini.no_xy++;
    if (x3 != x2 || y3 != y2) gnor_ini.no_xy++;
    if ((x4 != x3 || y4 != y3)
	&& (x4 != x1 || y4 != y1)) gnor_ini.no_xy++;
    dmPutDesignData (fp_nor, GEO_NOR_INI);

    gnor_xy.x = 1.0 * x1;
    gnor_xy.y = 1.0 * y1;
    DEBUG_PRINT "Writing: %.3f %.3f", gnor_xy.x, gnor_xy.y);
    dmPutDesignData (fp_nor, GEO_NOR_XY);
    if (x2 != x1 || y2 != y1) {
        gnor_xy.x = 1.0 * x2;
        gnor_xy.y = 1.0 * y2;
        DEBUG_PRINT " %.3f %.3f", gnor_xy.x, gnor_xy.y);
        dmPutDesignData (fp_nor, GEO_NOR_XY);
    }
    if (x3 != x2 || y3 != y2) {
        gnor_xy.x = 1.0 * x3;
        gnor_xy.y = 1.0 * y3;
        DEBUG_PRINT " %.3f %.3f", gnor_xy.x, gnor_xy.y);
        dmPutDesignData (fp_nor, GEO_NOR_XY);
    }
    if ((x4 != x3 || y4 != y3) && (x4 != x1 || y4 != y1)) {
        gnor_xy.x = 1.0 * x4;
        gnor_xy.y = 1.0 * y4;
        DEBUG_PRINT " %.3f %.3f", gnor_xy.x, gnor_xy.y);
        dmPutDesignData (fp_nor, GEO_NOR_XY);
    }
    DEBUG_PRINT "\n");

    return (0); /* ok */
}

void read_text()
{
    long xl, xr, yb, yt;
    static int text_warning = 0;
    int no;
    int text_type;

    xl = bbnd_xl;
    xr = bbnd_xr;
    yb = bbnd_yb;
    yt = bbnd_yt;

    check_rec_id(2, LAYER);
    read_rec_contents();
    lay_code = int_val[0];
    search_id(TEXTTYPE);
    read_rec_contents();
    text_type = int_val[0];

    search_id(XY);
    nr_coor = (rec_len - 4) / LONG;
    read_rec_contents();

    check_rec_id(0, STRING);
    read_rec_contents();

#if 0
    if (text_type >= 0)
        sprintf (nbuf, "'%d' with texttype '%d'", lay_code, text_type);
    else
        sprintf (nbuf, "'%d' (no texttype)", lay_code);
#endif
    no = findMasknr (lay_code, text_type);

    if (no >= 0 && ((text_as_term && !findIsText) || findIsText == 2)) {
        /* The text structure is used as terminal. */
	xl = round_int (int_val[0], "x");
	yb = round_int (int_val[1], "y");
	/* name equal previous name? */
	if (!strcmp (gds_name, gterm.term_name)) {
	    if (gterm.layer_no == no && xl == gterm.xl && yb == gterm.yb) {
		PE "%s: warning: %s: duplicate text record, terminal '%s' skipped!\n", argv0, ms_name, gds_name);
		return;
	    }
	    PE "%s: warning: %s: duplicate terminal name '%s' in text record\n", argv0, ms_name, gds_name);
	}
	gterm.layer_no = no;
	strcpy(gterm.term_name, gds_name);
	gterm.bxl = gterm.xl = xl;
	gterm.bxr = gterm.xr = xr = xl + t_width;
	gterm.byb = gterm.yb = yb;
	gterm.byt = gterm.yt = yt = yb + t_width;
	dmPutDesignData(fp_term, GEO_TERM);
    }
    else if (no >= 0 && ((text_as_anno && !findIsText) || findIsText == 1)) {
        /* The text structure is used as label. */
	xl = round_int (int_val[0], "x");
	yb = round_int (int_val[1], "y");
	/* name equal previous name? */
	if (!strcmp (gds_name, ganno.o.Label.name)) {
	    if (ganno.o.Label.maskno == no && xl == ganno.o.Label.x && yb == ganno.o.Label.y) {
		PE "%s: warning: %s: duplicate text record, label '%s' skipped!\n", argv0, ms_name, gds_name);
		return;
	    }
	    PE "%s: warning: %s: duplicate label name '%s' in text record\n", argv0, ms_name, gds_name);
	}
	ganno.type = GA_LABEL;
	strcpy (ganno.o.Label.name, gds_name);
	strcpy (ganno.o.Label.Class, "");
	ganno.o.Label.x = xr = xl;
	ganno.o.Label.y = yt = yb;
	ganno.o.Label.ay = 0;
	ganno.o.Label.ax =  -1;  /* left adjusted */
	ganno.o.Label.maskno = no;
	dmPutDesignData (fp_anno, GEO_ANNOTATE);
    }
    else {
        /* The text structure is used as comment. */
	char *s, *t;
	ganno.type = GA_TEXT;
	t = ganno.o.text.text;
	for (s = gds_name; *s; ++s) {
	    if (*s == '~') {
		*t++ = ' ';
		if (!silent && !text_warning) {
		    PE "%s: warning: removed ~ from text record(s)\n", argv0);
		    text_warning = 1;
		}
	    }
	    else *t++ = *s;
	}
	*t = 0;
	xl = xr = (long)(ganno.o.text.x = round_int (int_val[0], "x"));
	yb = yt = (long)(ganno.o.text.y = round_int (int_val[1], "y"));
	ganno.o.text.ay = 0;
	ganno.o.text.ax = -1; /* left adjusted */
	dmPutDesignData (fp_anno, GEO_ANNOTATE);
    }

    update_cell_bbox (xl, xr, yb, yt);
}

int findMasknr (int gds_nr, int gds_datatype)
{
    int j;

    findMatchType = 0;

    if (gds_nr < 0 || gds_nr > MAX_GDS_LAYNR)
        return (-1);

    if (gds_datatype >= 0) {
        if (masknr_datatype[gds_nr] != NULL) {
	    for (j = 0; j < max_datatype; j++) {
		if (masknr_datatype[gds_nr][j].type < 0) break;
		if (masknr_datatype[gds_nr][j].type == gds_datatype) break;
	    }
            if (j < max_datatype
                && masknr_datatype[gds_nr][j].type == gds_datatype) {
                findIsText = masknr_datatype[gds_nr][j].istext;
                findMatchType = 1;
                return (masknr_datatype[gds_nr][j].mask);
            }
        }

        /* If no mask is defined for the specified datatype,
           we try the mask for which no datatype is defined,
           which is given below (if it is defined).
        */
    }

    findIsText = istext[gds_nr];
    return (masknr[gds_nr]);
}

static char fn_nmp[DM_MAXNAME + 8];
static FILE * fp_nmp;
static int nmp_cnt;

void initTruncDmNames ()
{
    struct stat statBuf;

    sprintf (fn_nmp, "%s.nmp", ms_name);

    if (stat (fn_nmp, &statBuf) == 0) {
        if (unlink (fn_nmp) != 0) {
            pr_exit (W, 61, fn_nmp);
        }
    }

    fp_nmp = NULL;
    nmp_cnt = 0;
}

void endTruncDmNames ()
{
    if (fp_nmp) fclose (fp_nmp);
    fp_nmp = NULL;
    fn_nmp[0] = '\0';
}

char *truncDmName (char *s, int head, int reuse)
{
    int i, l, m;
    static char buf[DM_MAXNAME + 1];

    l = strlen (s);

    if (l > db_maxname) {
        sprintf (buf, "t%d_", ++nmp_cnt);
        m = strlen (buf);
	if (head) {
	    /* truncate on head */
	    for (i = 0; i < db_maxname - m; i++) {
		buf[m + i] = s[i + l - db_maxname + m];
	    }
	}
	else {
	    /* truncate on tail */
	    for (i = 0; i < db_maxname - m && i < l; i++) {
		buf[m + i] = s[i];
	    }
	}
	buf[m + i] = '\0';
    }
    else
        strcpy (buf, s);

    if (l > db_maxname && fn_nmp[0] != '\0') {
        if (!fp_nmp) {
	    if (!(fp_nmp = fopen (fn_nmp, "w"))) {
                pr_exit (A, 59, fn_nmp);
	    }
	    pr_exit (W, 60, fn_nmp);
        }
        fprintf (fp_nmp, "%s %s\n", buf, s);
    }

    if (reuse) {
        if (l > db_maxname) strcpy (s, buf);

        return (s);
    }

    return (buf);
}
