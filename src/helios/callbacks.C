/*
 * ISC License
 *
 * Copyright (C) 1995-2018 by
 *	Xianfeng Ni
 *	Ulrich Geigenmuller
 *	Simon de Graaf
 * Delft University of Technology
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
** Generated by X-Designer Educational version
** This code may not be used in any program
** offered for resale or commercial use.
*/

/*
** X-Designer-generated prelude.
** Do not edit lines before "End of X-Designer generated prelude"
** Lines beginning ** X-Designer Stub indicate a stub
** which will not be output on re-generation
*/

/*
**LIBS: -lXm -lXt -lX11
*/

#include <X11/Xatom.h>
#include <X11/Intrinsic.h>
#include <X11/Shell.h>

#include <Xm/Xm.h>
#include <Xm/CascadeB.h>
#include <Xm/FileSB.h>
#include <Xm/List.h>
#include <Xm/PushB.h>
#include <Xm/SelectioB.h>
#include <Xm/Text.h>
#include <Xm/TextF.h>
#include <Xm/ToggleB.h>
#include <Xm/CascadeBG.h>
#include <Xm/PushBG.h>
#include <Xm/ToggleBG.h>
#undef atexit /* Motif header files make this malicious definition */

#include "src/helios/option.h"

/* End of X-Designer generated prelude */

/*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <time.h>
#include <signal.h>
#include <ctype.h>
#include <fnmatch.h>
#include <X11/cursorfont.h>
#include <X11/IntrinsicP.h>
#include <Xm/Text.h>
#include "src/space/auxil/auxil.h"

#include "src/helios/realist.h"
#include "src/helios/externs.h"

#define csDEFAULT (XmStringCharSet)XmFONTLIST_DEFAULT_TAG
#define csNORMAL  (XmStringCharSet)"normal"
#define csBOLD    (XmStringCharSet)"bold"

#define BBRACE '{'
#define CBRACE '}'

#define DBRCFILE ".dmrc"

static XmString db_dir = (XmString) NULL;
static XmString fi_dir = (XmString) NULL;
static unsigned char FileTypeMask = XmFILE_ANY_TYPE;

static int cIndicator = 1, rIndicator = 1;
static int GeneralDefaultFlag = 0;
static int FactoryDefaultFlag = 0;
static int UserDefaultFlag = 0;
static Cursor FDflt_cursor = 0;
static char FileSelectorTitle[101];
static char ListSelectorTitle[101];
static char *cell_msks;
static char *TechnologyName = NULL;
static char TechnologyPath[DM_MAXPATHLEN];
static char *new_db;
static char *rem_db;
extern char *Namefile;
extern int HighlayOptEnabled;
extern int InitialSetValues;
extern int loadAlsoOpenForms;
extern int promptType;
static int pleaseMapWidget = 0;
static int current_view_nr = 0;
static int NOdmErrorMsg = 0;
static int interfacetype = 0;
static int interfaceremote = 0;
static time_t timestamp = 0;
static int new_proj = 1;

/* Function prototypes */
extern void ADD_TO_CMDLINE (char *);
extern void AdmVariable (int, int, FILE *);
extern void ExecuteSpaceCommand (char *CommandLine_in, char *tempFileName, void (*callOnCompletion)());
extern void SetMenuSensitive (Boolean status);
extern void sort (char **cell_list);
extern void asort (char **namelist, int n);
extern char *giveICD (char *);
extern char *trim (char *);
extern char *trimPath (char *);
extern void terminateProgram (int);
extern void ReadUserDefaults (char *);
extern void WriteDeviceFile (FILE *fp, char *device, char *terminals, char *prefix,
                             char *context, char *description);

void AddToOutputWindow (char *);
void DisplayProjlist (Widget, XtPointer, XtPointer);
void PopupFileSelectWin (Widget, XtPointer, XtPointer);
void SetMasksText (Widget, XtPointer, XtPointer);
void ChangeToOtherDatabase();
void UpdateLibraryList();
void AdmWindow (int, int);
void UpdateAfterLoadLayout();
int ManageCellStatus (char *cell, int oldct, int ct, int it, IMPCELL *);
void ChangeCursor (int activateDefault);
void ReadDeviceModel ();
void ReadTechnologyDefaults();
void SubmitCmdLine (char *cmdLine);
void PopupConfirmWin(char *text);
FILE *OpenForWrite (char *filename);
void BringUpWindow (Widget shell, Widget dialog, int label);
char *CurrentGMT();
int IsDatabase (char *);

typedef struct {
    char *cmdLine;
    char *tempFileName;
    void (*callOnCompletion)();
    void (*callOnDenial)();
} CommandInfo_t;

static CommandInfo_t ConfirmedCommandInfo;

typedef struct xyz {
    char *path;		/* path of the project */
    char *relpath;	/* rel.path of the project */
    int mode;		/* 0=!opened(prev), 1=opened(read), 2=opened(write) */
    long t_lcl[2];	/* last mtime local cl */
    long t_icl[2];	/* last mtime imported cl */
    char **lcl[2];	/* local cl */
    IMPCELL **icl[2];	/* imported cl */
    struct xyz *next;
} Project_t;

static Project_t *ProjectLt;
static Project_t *readProject;

/*****************************************************************
* Popup a Message Dialog Box and display a message.
* Whenever errors are encountered, this function should be called.
*/
void PopupMessageBox (char *message)
{
    XmString xmstring;
    static char *mess;

    /* ring the bell with the volume 30 */
    XBell (XtDisplay (Shell->Shell), 30);

    if (XtIsManaged (MessageWin->MessageDialog)) {
	char *m = strsave (message);
	message = mprintf ("%s\n\n%s", mess, m);
	DISPOSE (m, 0);
    }
    if (mess) DISPOSE (mess, 0);
    mess = strsave (message);
    xmstring = XmStringCreateLtoR (message, csDEFAULT);
    XtVaSetValues (MessageWin->MessageLabel, XmNlabelString, xmstring, NULL);
    XmStringFree (xmstring);

    XtManageChild (MessageWin->MessageDialog);
}

void dmError (char *s)
{
#if defined (sun)
    extern char *sys_errlist[];
    extern int sys_nerr;
#endif
    char buf[40];
    char *a, *e;

    if (NOdmErrorMsg) return;

    if (s && *s) a = (char*)": ";
    else s = a = (char*)"";

    if (dmerrno > 0 && dmerrno <= dmnerr)
        e = dmerrlist[dmerrno];
    else
        sprintf (e = buf, "DMI error number: %d", dmerrno);

#if defined (sun)
    if (dmerrno == DME_SYS && errno > 0 && errno <= sys_nerr)
	PopupMessageBox (mprintf ("%s%s%s: %s", s, a, e, sys_errlist[errno]));
    else
	PopupMessageBox (mprintf ("%s%s%s", s, a, e));
#else
    if (dmerrno == DME_SYS)
	PopupMessageBox (mprintf ("%s%s%s: %s", s, a, e, strerror (errno)));
    else
	PopupMessageBox (mprintf ("%s%s%s", s, a, e));
#endif
}

/********************************
* Save helios defaults to file.
*/
void SaveUserDefaults (char *fileName)
{
    FILE *fp;
    int item;

    if ((fp = fopen (fileName, "w"))) {
fprintf (fp, "#######################################################################################\n");
fprintf (fp, "#\n# helios.defaults - options file for the \"helios\" graphical user interface.\n");
fprintf (fp, "# Saved automatically by helios on %s\n#\n", CurrentGMT());
fprintf (fp, "########################################################################################\n");

	for (item = FIRST_PARAMETER+1; item <= LAST_PARAMETER; item++)
	    AdmVariable (item, WRITE_HELIOS, fp);
	fprintf (fp, "\n#EOF\n");
	fclose (fp);
    }
    else {
	fileName = strsave (fileName);
	PopupMessageBox (mprintf (
	"Cannot open user-defaults file\n\"%s\"\nto write to!  Nothing saved!", fileName));
	DISPOSE (fileName, 0);
    }
}

/*
** X-Designer Stub SaveDefaults
*/

/************************************************************************
* Save defaults to file in the directory from which you invoked "helios".
*/
void SaveDefaults (Widget , XtPointer , XtPointer )
{
    SaveUserDefaults (mprintf ("%s/helios.defaults", OpenedDatabase));
}

/*
** X-Designer Stub quit
*/

/**************************************************************************
* Quit realist callback.  Finish up, close database, kill running programs.
*/
void quit (Widget w, XtPointer client_data, XtPointer xt_call_data)
{
    XmPushButtonCallbackStruct *call_data = (XmPushButtonCallbackStruct *) xt_call_data;
    char *State = (char *) client_data;
    FILE *fp;

    /* terminate all child processes, as far as possible */
    terminateProgram (-1);

    if (!strcmp (State, "Save"))
        SaveDefaults (w, client_data, call_data);

    if (dmproject)
        dmCloseProject (dmproject, COMPLETE);

    if (dmQuit ())    /* check-in all cells, quit database interactions */
	say ("Database could not be closed properly!");

    if ((fp = OpenForWrite (mprintf ("%s/.helios", UsersHomeDirectory)))) {
	Project_t *p;
	for (p = ProjectLt; p && p -> mode != 1; p = p -> next) {
	    fprintf (fp, "%s %s\n", p -> mode? "OpenedDatabase" : "PrevisDatabase",
		p -> relpath? p -> relpath : p -> path);
	}
        fclose (fp);
    }

    printf ("\n\nLeaving `helios' on %s\n\n", CurrentGMT());
    exit (0);
}

int isProcessName (char *name)
{
    int nr;
    for (nr = 0; nr < NumberOfProcesses; ++nr)
	if (!strcmp (name, ProcessItems[nr].name)) return 1;
    return 0;
}

char *strip_blanks (char *name)
{
  char *s;

  if (name) {
    /* strip leading blanks */
    while (*name == ' ') ++name;
    if (*name) {
	s = name + strlen (name) - 1;
	/* strip trailing blanks */
	while (*s == ' ') *s-- = '\0';
	/* strip trailing slashes */
	while (*s == '/' && s > name) *s-- = '\0';
    }
  }
  return (name);
}

char *strip2 (char *name)
{
    if (name) {
	char *s;
	while (*name == ' ') ++name;
	if ((s = strchr (name, ' '))) *s = '\0';
    }
    return name;
}

char *lambdaStr (char *s)
{
    static char buf[20];
    sprintf (buf, "%f", atof (s));
    s = buf + strlen (buf);
    while (*--s == '0') *s = '\0';
    if (*s == '.') *++s = '0';
    return buf;
}

/*
** X-Designer Stub MakeNewDataBase
*/

/************************************************************************
* Make a new NELSIS database, i.e. a Unix directory with certains
* files and subdirectories.
*/
void MakeNewDataBase (Widget , XtPointer , XtPointer )
{
    struct stat buf;
    char *lambda, *marker, *newDatabaseName, *databaseName, *processName;

    marker = XmTextFieldGetString (NewDbWin->LambdaText);
    lambda = lambdaStr (marker);
    XtFree (marker);
    XmTextFieldSetString (NewDbWin->LambdaText, lambda);

    databaseName = XmTextFieldGetString (NewDbWin->DatabaseNameText);
    processName = XmTextFieldGetString (NewDbWin->ProcessNameText);

    newDatabaseName = strip_blanks (databaseName);
    if (!newDatabaseName || !*newDatabaseName ||
	(*newDatabaseName == '/' && !newDatabaseName[1])) {
	PopupMessageBox ((char*)"You must specify a database name!");
	goto ret;
    }
    if (strchr (newDatabaseName, ' ')) {
	PopupMessageBox ((char*)"Incorrect database name!\nThere may not be space in it.");
	goto ret;
    }
    if (stat (newDatabaseName, &buf) == 0) {
	if (!S_ISDIR (buf.st_mode) || IsDatabase (newDatabaseName)) {
	    PopupMessageBox ((char*)"New database name already exist!\nYou must specify another path.");
	    goto ret;
	}
    }

    if (!processName || !*processName) {
	PopupMessageBox ((char*)"You must specify a process.\nPress [Process] button for a list.");
	goto ret;
    }

    if (!isProcessName (processName)) {
	DIR *dp;
	if ((dp = opendir (processName))) {
	    /* processName represents a process path */
	    closedir (dp);
	}
	else {
	    PopupMessageBox ((char*)"Invalid process.\nPress [Process] button for a list of supported processes.");
	    goto ret;
	}
    }
    if (atof (lambda) <= 0.0) {
	PopupMessageBox ((char*)"Illegal lambda value!");
	goto ret;
    }
    XtUnmanageChild (NewDbWin->NewDbDialog);

    sprintf (CmdLine, "mkpr -p %s -l %s %s", processName, lambda, newDatabaseName);

    new_db = strsave (newDatabaseName);
    ExecuteSpaceCommand (CmdLine, NULL, ChangeToOtherDatabase);
ret:
    XtFree (processName);
    XtFree (databaseName);
}

/*********************************************************************
* Open a file with write-access, or display window with a warning
* if this failed.  Return file pointer.
*/
FILE *OpenForWrite (char *filename)
{
    FILE *fp;
    if (!(fp = fopen (filename, "w"))) {
	filename = strsave (filename);
	PopupMessageBox (mprintf ("Could not open file\n\"%s\"\nfor writing!", filename));
	DISPOSE (filename, 0);
    }
    return fp;
}

/*
** X-Designer Stub DisplayDescription
*/

/****************************************************************************
* Display short message in the DescriptionText.
* KeyWord is argument client_data.
* See helios.message
*/
void DisplayDescription (Widget , XtPointer client_data, XtPointer )
{
    typedef struct quickRef {
	char *keyword;
	char *headline;
	char *description;
    } quickRef_t;

#define MAX_NR_QUICKREFS 320
    static quickRef_t qref[MAX_NR_QUICKREFS+1];
    static bool_t firstCall = TRUE;
    static char *missing_brace =(char*)
	"Quick reference file corrupted:\nclosing brace for %s '%s' not found!";
    XmString xmstring;
    char *marker, *s;
    int counter, man_pages_read;
    int is_managed, len;

    if (firstCall) {
	firstCall = FALSE;
	counter = 0;
	man_pages_read = 0;

	ASSERT (MessageFilePointer);

	if (MessageFilePointer)
	while (fgets (globalTextBuffer, sizeof (globalTextBuffer), MessageFilePointer)) {

	    /* find next keyword */
	    if (*globalTextBuffer == '#') {
		if (!man_pages_read && globalTextBuffer[1] == 'M' &&
			globalTextBuffer[2] == 'A' && globalTextBuffer[3] == 'N') {
		    /*
			Read manual page lines:
		    */
		    man_pages_read = 1;
		    while (fgets (globalTextBuffer, sizeof (globalTextBuffer), MessageFilePointer)) {
			marker = globalTextBuffer;
			if (*marker++ != '#') break;
			if (*marker++ != BBRACE) continue;
			s = marker;
			while (*s != CBRACE && *s) ++s;
			*s = '\0';
			xmstring = XmStringCreateLtoR (marker, csNORMAL);
			XmListAddItem (ManPageWin->ManPagesIndex_Lst, xmstring, 0);
			XmStringFree (xmstring);
		    }
		}
		continue;
	    }
	    if (*globalTextBuffer == '\n') continue;

	    Debug (fprintf (stderr, "looking for next keyword\n"));
	    Debug (fprintf (stderr, "%s", globalTextBuffer));

	    if (!(marker = strchr (globalTextBuffer, BBRACE))) continue;
key:
	    ++marker;
	    if ((s = strchr (marker, CBRACE))) *s = '\0';
	    else {
		if ((s = strchr (marker, '\n'))) *s = '\0';
		say (missing_brace, "keyword", marker);
	    }
	    if (counter == MAX_NR_QUICKREFS) {
		say ("WARNING: Too many quick references in file!");
		break;
	    }
	    qref[counter].keyword = strsave (marker);
	    qref[counter].headline = NULL;
	    qref[counter].description = NULL;

	    /* find next headline */
	    for (;;) {
		if (!fgets (globalTextBuffer, sizeof (globalTextBuffer), MessageFilePointer)) {
		    say (missing_brace, "headline to keyword", qref[counter++].keyword);
		    goto ret;
		}
		if (*globalTextBuffer == '#') continue;

		Debug (fprintf (stderr, "looking for next headline\n"));
		Debug (fprintf (stderr, "%s", globalTextBuffer));

		if ((marker = strchr (globalTextBuffer, BBRACE))) {
		    ++marker;
		    if ((s = strchr (marker, CBRACE))) *s = '\0';
		    else {
			if ((s = strchr (marker, '\n'))) *s = '\0';
			say (missing_brace, "headline", marker);
		    }
		    qref[counter].headline = strsave (marker);
		    break;
		}
	    }

	    /* find description belonging to keyword */
	    len = 0;
	    marker = s = 0;
	    while (!s) {
		if (!fgets (globalTextBuffer, sizeof (globalTextBuffer), MessageFilePointer)) {
		    say (missing_brace, "description to keyword", qref[counter++].keyword);
		    goto ret;
		}
		if (*globalTextBuffer == '#' || *globalTextBuffer == '\n') continue;

		Debug (fprintf (stderr, "looking for %s of text\n", len? "end" : "begin"));
		Debug (fprintf (stderr, "%s", globalTextBuffer));

		if (!marker) {
		    if (!(marker = strchr (globalTextBuffer, BBRACE))) continue;
		    ++marker;
		}
		else {
		    marker = globalTextBuffer;
		    if (*globalTextBuffer == BBRACE) { /* for synchronization */
			/* this must be start of new keyword */
			say (missing_brace, "description to keyword", qref[counter++].keyword);
			goto key;
		    }
		}

		if (!(s = strchr (marker, CBRACE))) {
		    if ((s = strchr (marker, '\n'))) {
			if (*(s-1) == '\\') *(s-1) = '\n';
			else *s++ = ' ';
			*s = '\0';
			len += s - marker;
			s = 0;
		    }
		    else len += strlen (marker);
		}
		else {
		    *s = '\0';
		    len += s - marker;
		}

		if (qref[counter].description) {
		    char *old = qref[counter].description;
		    qref[counter].description = NEW (char, len + 1);
		    sprintf (qref[counter].description, "%s%s", old, marker);
		    DISPOSE (old, 0);
		}
		else
		    qref[counter].description = strsave (marker);
	    }
	    ++counter;
	}
ret:
	qref[counter].keyword = NULL;
	return;
    }

    is_managed = XtIsManaged (QuickRefWin->QuickRefDialog);

    if (is_managed && (pleaseMapWidget ||
	    XmToggleButtonGetState (QuickRefWin->DescriptionFloatOnTop_Tggl))) {
	XtUnmapWidget (QuickRefWin->QuickRefWin);
	XtMapWidget (QuickRefWin->QuickRefWin);
    }
    if (pleaseMapWidget && !is_managed) {
	ShowQuickReference.value = 1;
	XtManageChild (QuickRefWin->QuickRefDialog);
	is_managed = 1;
    }
    pleaseMapWidget = 0;

    if (client_data && is_managed) {
	counter = 0;
	marker = (char *)client_data;
	s = (char*)"DescriptionText not found!";
	while (qref[counter].keyword) {
	    if (!strcmp (qref[counter].keyword, marker)) {
		marker = qref[counter].headline;
		s = qref[counter].description;
		break;
	    }
	    ++counter;
	}
	XmTextSetString (QuickRefWin->DescriptionItem_Txt, marker);
	XmTextSetString (QuickRefWin->QuickRefText_Frame->DescriptionText, s);
    }
}

/*
** X-Designer Stub DisplayFileselectorDescription
*/

/****************************************************************************
* Display quick reference for file selector.
*/
void DisplayFileselectorDescription (Widget , XtPointer , XtPointer )
{
    pleaseMapWidget = 1;
    if (strstr (FileSelectorTitle, "Database"))
        DisplayDescription (NULL, (XtPointer) "HELP_DATABASE", NULL);
    else
        DisplayDescription (NULL, (XtPointer) "HELP_FILE", NULL);
}

/***********************************************************
* The "file selection box" filter procedure.
* It is called sometimes twice. A timestamp is used to do it
* only one time. By program start-up it is also called, we
* reject this first call.
*/
void FileSearchProc (Widget w, XtPointer a, XtPointer b)
{
    static time_t oldt;
    time_t newt;
    XmFileSelectionBoxCallbackStruct *in;
    DIR *dirp;
    struct dirent *dp;
    XmString *Items;
    struct stat sbuf;
    char *namelist[200];
    char *current_dir_path, *current_pattern, *filename;
    char filepath[512];
    Arg args[4];
    int n, i;

    newt = time ((time_t) 0);
    if (oldt == 0 || newt < oldt + 2) { oldt = newt; return; }

    in = (XmFileSelectionBoxCallbackStruct *)a;
    XmStringGetLtoR (in -> dir, XmSTRING_DEFAULT_CHARSET, &current_dir_path);
    XmStringGetLtoR (in -> pattern, XmSTRING_DEFAULT_CHARSET, &current_pattern);

    n = 0;
    if ((dirp = opendir (current_dir_path))) {
	while ((dp = readdir (dirp))) {
	    if (dp -> d_ino == 0) continue; /* empty slot */
	    filename = dp -> d_name;
	    if (fnmatch (current_pattern, filename, 0)) continue;
	    sprintf (filepath, "%s%s", current_dir_path, filename);
	    if (stat (filepath, &sbuf) == 0) {
		if (S_ISDIR (sbuf.st_mode)) {
		    if (FileTypeMask == XmFILE_DIRECTORY && IsDatabase (filepath))
			if (n < 200) namelist[n++] = strsave (filename);
		}
		else if (FileTypeMask != XmFILE_DIRECTORY)
			if (n < 200) namelist[n++] = strsave (filename);
	    }
	}
	closedir (dirp);
    }

    if (!n) namelist[n++] = strsave ("         ");
    else if (n > 1) asort (namelist, n);

    Items = NEW (XmString, n);

    for (i = 0; i < n; ++i) {
	sprintf (filepath, "%s%s", current_dir_path, namelist[i]);
	DISPOSE (namelist[i], 0);
	Items[i] = XmStringCreateLtoR (filepath, csDEFAULT);
    }

    XtSetArg (args[0], XmNlistUpdated, 1);
    XtSetArg (args[1], XmNfileListItemCount, n);
    XtSetArg (args[2], XmNfileListItems, Items);
    XtSetValues (w, args, 3);

    DISPOSE (Items, 0);
    XtFree (current_pattern);
    XtFree (current_dir_path);
    oldt = newt;
}

/************************************************************************
* The file selection box is used to choose a database, which is recognized
* as a directory containing a ".dmrc" file.  This routine serves to
* only display directories containing such a file.
* The FileSearchProc routine is added to the "file selection box" to do
* this filtering directly. See above (SdeG).
*/
void ListDatabaseFilter (Widget w)
{
    Arg args[2];
    XmFileSelectionBoxCallbackStruct a;
    XmString dir, pat;

    XtSetArg (args[0], XmNdirectory, &dir);
    XtSetArg (args[1], XmNpattern, &pat);
    XtGetValues (w, args, 2);

    a.dir = dir;
    a.pattern = pat;
    FileSearchProc (w, (XtPointer)&a, (XtPointer)0);
}

#define IS_ROOT 0200

void cellIsRoot (DM_PROJECT *proj, char *view)
{
#ifndef NOPACK
#define _dmDoget _dmUnpack
#endif
    char path[256];
    char buf2[256];
    char buf3[256];
    char str[256];
    long dim, tmp, imported;
    FILE *dmfp;
    struct stat buf;
    int  i, min, max, rv, n;
    char  *cell, *pcell1, *pcell2;
    char **celllist_array;
    register char **clp;
    int nr = (strcmp (view, CIRCUIT) == 0);

    celllist_array = proj -> celllist[nr];

    n = 0;
    for (clp = celllist_array; *clp; ++clp, ++n) **clp += IS_ROOT;
    if (n < 2) return;

    for (clp = celllist_array; *clp; ++clp) {

	if ((unsigned)**clp > IS_ROOT) {
	    **clp &= 0177;
	    sprintf (path, "%s/%s/%s/mc", proj -> dmpath, view, *clp);
	    **clp += IS_ROOT;
	}
	else
	    sprintf (path, "%s/%s/%s/mc", proj -> dmpath, view, *clp);
	if (stat (path, &buf) || buf.st_size == 0) continue;

	if (!(dmfp = fopen (path, "r"))) continue;

	pcell1 = pcell2 = 0;
	cell = path;
	for (;;) {
	    if (nr == 0) { /* GEO_MC */
		if (_dmDoget (dmfp, (char*)"SDDDDSDDDDDDDDDDD",
			str, &tmp, &tmp, &tmp, &tmp, cell, &imported,
			&tmp, &tmp, &tmp, &tmp, &tmp, &tmp, &tmp, &tmp, &tmp, &tmp) != 17) {
		    if (feof (dmfp)) goto ret;
		    goto read_error;
		}
	    }
	    else {
		if (_dmDoget (dmfp, (char*)"SDSAD", cell, &imported, str, str, &dim) != 5) {
		    if (feof (dmfp)) goto ret;
		    goto read_error;
		}
		while (dim-- > 0) if (_dmDoget (dmfp, (char*)"DD", &tmp, &tmp) != 2) goto read_error;
	    }
	    if (imported) continue;
	    if (pcell1) {
		if (!strcmp (pcell1, cell)) continue;
		if (pcell2 && !strcmp (pcell2, cell)) continue;
	    }
	    pcell2 = pcell1;
	    pcell1 = cell;

	    min = 0;
	    max = n;
	    while ((i = (min + max)/2) < max) {
		if ((unsigned)*celllist_array[i] > IS_ROOT) {
		    *celllist_array[i] &= 0177;
		    if (!(rv = strcmp (cell, celllist_array[i]))) break; /* leaf */
		    *celllist_array[i] += IS_ROOT;
		}
		else
		    if (!(rv = strcmp (cell, celllist_array[i]))) break; /* leaf */
		if (rv < 0)
		    max = i;
		else
		    min = ++i;
	    }
	    cell = (cell == path)? buf2 : ((cell == buf2)? buf3 : path);
	}
read_error:
	dmerrno = DME_GET;
	dmError (nr == 0 ? (char *)"GEO_MC" : (char *)"CIR_MC");
ret:
	fclose (dmfp);
    }
}

void dmDispose_cl (char **cl)
{
    char **clp;
    if ((clp = cl)) {
	while (*clp) { _dmStrFree (*clp++); }
	free (cl);
    }
}

void dmDispose_icl (IMPCELL **icl)
{
    IMPCELL **iclp;
    if ((iclp = icl)) {
	while (*iclp) {
	    _dmStrFree ((*iclp) -> cellname);
	    _dmStrFree ((*iclp) -> alias);
	    _dmStrFree ((*iclp) -> dmpath);
	    free (*iclp++);
	}
	free (icl);
    }
}

DM_PROJECT *open_project (char *path)
{
    Project_t *p, *q;
    DM_PROJECT *pkey = NULL;

    if (chdir (path) == -1 ||
	!(path = getcwd (NULL, MAXLENGTH_OF_FILENAME+1))) goto ret;

    if (IsDatabase (path) && (pkey = dmOpenProject (path, PROJ_READ))) {
	for (q = p = ProjectLt; p; q = p, p = p -> next)
	    if (!strcmp (path, p -> path)) break;
	if (!p) { /* new path not found */
	    p = NEW (Project_t, 1);
	    p -> path = path;
	    p -> relpath = 0;
	    p -> mode = 1;
	    p -> t_lcl[0] = 0; p -> t_lcl[1] = 0;
	    p -> t_icl[0] = 0; p -> t_icl[1] = 0;
	    p -> lcl[0] = 0; p -> lcl[1] = 0;
	    p -> icl[0] = 0; p -> icl[1] = 0;
	    p -> next = 0;
	    q -> next = p;
	}
	readProject = p;
    }
    else
	DISPOSE (path, 0);
ret:
    if (chdir (OpenedDatabase) == -1)
	PopupMessageBox (mprintf
	("Could not chdir back to CWD:\n\"%s\"", OpenedDatabase));
    return (pkey);
}

static int n_lcl[2];

char **getCellList (DM_PROJECT *proj, char *view)
{
    static long iLlcl[2];
    static long tLlcl[2];
    struct stat buf;
    long nt_lcl, ni_lcl;
    char **cl;
    Project_t *p = 0;
    Widget button;
    XmString xmstring;
    char path[1024];
    int n, vnr = *view == 'c' ? 1 : 0;

    if (!proj) { /* special case for dmproject */
	ni_lcl = nt_lcl = 1;
	cl = 0;
    }
    else {
	p = proj == dmproject ? ProjectLt : readProject;
	sprintf (path, "%s/%s/celllist", p -> path, view);
	nt_lcl = stat (path, &buf) ? 1 : buf.st_mtime;
	ni_lcl = nt_lcl == 1 ? 0 : buf.st_ino;

	if (p -> t_lcl[vnr] == nt_lcl) {
	    cl = p -> lcl[vnr];
	}
	else {
	    p -> t_lcl[vnr] = nt_lcl;
	    dmDispose_cl (p -> lcl[vnr]); /* free old one */
	    if (proj) {
		if ((cl = (char **) dmGetMetaDesignData (CELLLIST, proj, view))) {
		    sort (cl);
		    cellIsRoot (proj, view);
		}
		proj -> celllist[vnr] = NULL;
	    }
	    else cl = 0;
	    p -> lcl[vnr] = cl;
	}
    }

    if (proj == dmproject) { /* update CellsList Widget */

	if (current_view_nr == vnr && (iLlcl[vnr] != ni_lcl || tLlcl[vnr] != nt_lcl)) {
	    iLlcl[vnr] = ni_lcl;
	    tLlcl[vnr] = nt_lcl;
	    button = vnr ? Shell->Cell_Frame->CirCellsList : Shell->Cell_Frame->LayCellsList;
	    if (n_lcl[vnr]) XmListDeleteItemsPos (button, n_lcl[vnr], 1);
	    n = 0;
	    if (cl) {
		while (*cl) {
		    if ((unsigned)**cl > IS_ROOT) {
			**cl &= 0177;
			xmstring = XmStringCreateLtoR (*cl, csBOLD);
			**cl += IS_ROOT;
		    }
		    else
			xmstring = XmStringCreateLtoR (*cl, csNORMAL);
		    XmListAddItem (button, xmstring, ++n);
		    XmStringFree (xmstring);
		    ++cl;
		}
		cl = p -> lcl[vnr];
	    }
	    n_lcl[vnr] = n;
	}
    }

    return (cl);
}

IMPCELL **getImpCellList (DM_PROJECT *proj, char *view)
{
    static long iLicl[2];
    static long tLicl[2];
    static int  n_icl[2];
    struct stat buf;
    IMPCELL **il;
    Project_t *p = 0;
    Widget button;
    XmString xmstring;
    char path[1024];
    long nt_icl, ni_icl;
    int n, vnr = *view == 'c' ? 1 : 0;

    if (!proj) { /* special case for dmproject */
	ni_icl = nt_icl = 1;
	il = 0;
    }
    else {
	p = proj == dmproject ? ProjectLt : readProject;
	sprintf (path, "%s/%s/impcelllist", p -> path, view);
	nt_icl = stat (path, &buf) ? 1 : buf.st_mtime;
	ni_icl = nt_icl == 1 ? 0 : buf.st_ino;

	if (p -> t_icl[vnr] == nt_icl) {
	    il = p -> icl[vnr];
	}
	else {
	    p -> t_icl[vnr] = nt_icl;
	    dmDispose_icl (p -> icl[vnr]); /* free old one */
	    if (proj) {
		il = (IMPCELL **) dmGetMetaDesignData (IMPORTEDCELLLIST, proj, view);
		proj -> impcelllist[vnr] = NULL;
	    }
	    else il = 0;
	    p -> icl[vnr] = il;
	}
    }

    if (proj == dmproject) { /* update CellsList Widget */

	if (current_view_nr == vnr && (iLicl[vnr] != ni_icl || tLicl[vnr] != nt_icl)) {
	    iLicl[vnr] = ni_icl;
	    tLicl[vnr] = nt_icl;
	    button = vnr ? Shell->Cell_Frame->CirCellsList : Shell->Cell_Frame->LayCellsList;
	    if (n_icl[vnr]) XmListDeleteItemsPos (button, n_icl[vnr], n_lcl[vnr] + 1);
	    n = 0;
	    if (il) {
		while (*il) {
		    xmstring = XmStringCreateLtoR (mprintf ("%s   (import from: %s, cell: %s)",
			(*il)->alias, (*il)->dmpath, (*il)->cellname), csNORMAL);
		    XmListAddItem (button, xmstring, 0);
		    XmStringFree (xmstring);
		    ++il; ++n;
		}
		il = p -> icl[vnr];
	    }
	    n_icl[vnr] = n;
	}
    }

    return (il);
}

/*****************************************************************************
* List all cells in the main window, according the specified view (layout or circuit).
* Update the list if needed after a command is done.
*/
void ListCells ()
{
    static char *pview;
    char *view;
    Widget button;
    Widget butold;

    if (current_view_nr == 0) {
	view = (char*)LAYOUT;
	button = Shell->Cell_Frame->LayCellsList;
	butold = Shell->Cell_Frame->CirCellsList;
    }
    else {
	view = (char*)CIRCUIT;
	button = Shell->Cell_Frame->CirCellsList;
	butold = Shell->Cell_Frame->LayCellsList;
    }
    if (view != pview) {
	pview = view;
	XtMapWidget (XtParent (button));
	XtUnmapWidget (XtParent (butold));
    }

    (void) getCellList (dmproject, view);
    (void) getImpCellList (dmproject, view);
}

/*
** X-Designer Stub ListCellsCb
*/

void ListCellsCb (Widget w, XtPointer , XtPointer )
{
    static Widget pw;
    if (pw != w) {
	pw = w;
	current_view_nr = (w == Shell->Cell_Frame->circuit_Bttn);
	ListCells ();
    }
}

/*
** X-Designer Stub LoadLayoutFilterCallback
*/

/**********************************************************************
* Set the correct filter for the file selection dialog, depending on
* the chosen layout file format.
***********************************************************************/
void LoadLayoutFilterCallback (Widget w, XtPointer , XtPointer )
{
    XmString xmstring;
    char *s;
    int b1, b2;

    if (!w)
	XtVaGetValues (LoadWin->LoadLayout_OptnMn, XmNmenuHistory, &w, NULL);

    b1 = b2 = FALSE;
    if (w == LoadWin->CIF_Bttn) {
	s = (char*)"*.cif"; b1 = TRUE;
    }
    else if (w == LoadWin->LDM_Bttn) {
	s = (char*)"*.ldm";
    }
    else {
	s = (char*)"*.gds"; b2 = TRUE;
    }
    XtSetSensitive (LoadWin->CIFSpecials_Frm, b1);
    XtSetSensitive (LoadWin->GDSSpecials_Frm, b2);
    XtSetSensitive (LoadWin->NonGDS_Frm, b2 == TRUE ? FALSE : TRUE);

    xmstring = XmStringCreateLtoR (s, csDEFAULT);
    XtVaSetValues (FileSelectionWin->FileSelectionDialog, XmNpattern, xmstring, NULL);
    XmStringFree (xmstring);
}

/*
** X-Designer Stub LoadLayoutOKCallback
*/

/*******************************************************************
* Load a non-NELSIS layout-file into a NELSIS database
*/
void LoadLayoutOKCallback (Widget , XtPointer , XtPointer )
{
    char *LayoutFile;
    struct stat buf;

    LayoutFile = XmTextFieldGetString (LoadWin->LoadFileText);

    if (stat (LayoutFile, &buf) == 0 && !S_ISDIR (buf.st_mode)) {
        AdmVariable (LOAD_LAYOUT_OPTION, WRITE_PARAMS, NULL);
        ADD_TO_CMDLINE (mprintf (" %s", LayoutFile));
	if (ShowCommandLine.value) {
	    XmTextFieldSetString (CmdLineWin->CmdLine_Txt, CmdLine);
	    BringUpWindow (CmdLineWin->CmdLineWin, CmdLineWin->CmdLineDialog, NO_OPERATION);
	}
	else
	    ExecuteSpaceCommand(CmdLine, NULL, UpdateAfterLoadLayout);
    }
    else
        PopupMessageBox (mprintf ("File\n\"%s\"\ndoes not exist, or cannot be read!", LayoutFile));

    XtFree (LayoutFile);
}

void UpdateAfterLoadLayout()
{
    XtVaSetValues (Shell->Cell_Frame->ViewType_OptnMn, XmNmenuHistory, Shell->Cell_Frame->layout_Bttn, NULL);
    ListCells ();
}

/*
** X-Designer Stub CancelExtract
*/

void CancelExtract (Widget , XtPointer client_data, XtPointer )
{
    long mode = (long) client_data;

    if (XtIsManaged (ParCapFastWin->ParCapFastDialog)) {
	if (mode) AdmWindow (CAPACITANCE_FAST, ACC_VALUES);
	XtUnmanageChild (ParCapFastWin->ParCapFastDialog);
    }
    if (XtIsManaged (ParCapAccurateWin->ParCapAccurateDialog)) {
	if (mode) AdmWindow (CAPACITANCE_ACCURATE, ACC_VALUES);
	XtUnmanageChild (ParCapAccurateWin->ParCapAccurateDialog);
    }
    if (XtIsManaged (ParResWin->ParResDialog)) {
	if (mode) AdmWindow (RESISTANCE_EXTRACT, ACC_VALUES);
	XtUnmanageChild (ParResWin->ParResDialog);
    }
    if (XtIsManaged (ParSubAccrtWin->ParSubAccrtDialog)) {
	if (mode) AdmWindow (SUBRES_ACCRT_FINE, ACC_VALUES);
	XtUnmanageChild (ParSubAccrtWin->ParSubAccrtDialog);
    }
    if (XtIsManaged (ParSubCapFastWin->ParSubCapFastDialog)) {
	if (mode) AdmWindow (SUBCAP_FAST_FINE, ACC_VALUES);
	XtUnmanageChild (ParSubCapFastWin->ParSubCapFastDialog);
    }
    if (XtIsManaged (ParSubCapAccrtWin->ParSubAccrtDialog)) {
	if (mode) AdmWindow (SUBCAP_ACCRT_FINE, ACC_VALUES);
	XtUnmanageChild (ParSubCapAccrtWin->ParSubAccrtDialog);
    }
    if (XtIsManaged (ParHeuristicsWin->ParHeuristicsDialog)) {
	if (mode) AdmWindow (CIRCUIT_REDUCTION, ACC_VALUES);
	XtUnmanageChild (ParHeuristicsWin->ParHeuristicsDialog);
    }
    if (XtIsManaged (ParMisWin->ParMisDialog)) {
	if (mode) AdmWindow (MISCELLANEOUS_FINE, ACC_VALUES);
	XtUnmanageChild (ParMisWin->ParMisDialog);
    }
}

/*
** X-Designer Stub RunSpace
*/

/********************************************************************
* Prepare parameter file and command line, run Space program
*/
void RunSpace (Widget , XtPointer , XtPointer )
{
    char *cell;
    FILE *fp;

    cell = XmTextFieldGetString (Shell->Cell_Frame->SelectedCell_Txt);
    if (!cell || !*cell) {
	PopupMessageBox ((char*)"No cell is selected");
    }
    else if ((fp = fopen ("helios.def.p", "w"))) {
	fprintf (fp, "#\n# space parameter file produced by helios on %s\n#\n\n",  CurrentGMT());
	fprintf (fp, "debug.allow_dmrun3 off\n"); // _dmRun3 does not work
	strcpy (CmdLine, "space3d");
	AdmVariable (EXTRACTION_OPTION, WRITE_PARAMS, fp);
	fclose (fp);
	ADD_TO_CMDLINE ((char*)" -Phelios.def.p ");
	ADD_TO_CMDLINE (cell);
	SubmitCmdLine (CmdLine);
    }
    else
	PopupMessageBox ((char*)"Cannot open parameter file \"helios.def.p\" to write to!\n\nNo extraction done!");

    XtFree (cell);
}

/*
** X-Designer Stub MenuListCallback
*/

/*****************************************
* List contents of the database
*/
void MenuListCallback (Widget , XtPointer , XtPointer )
{
    char *cmd = (char*)"dblist -cl -h -d";
    char *cell = XmTextFieldGetString (Shell->Cell_Frame->SelectedCell_Txt);

    if (cell && *cell)
	SubmitCmdLine (mprintf ("%s %s", cmd, cell));
    else
	SubmitCmdLine (cmd);

    XtFree (cell);
}

/*
** X-Designer Stub MenuDaliCallback
*/

/**************
*  Run dali
*/
void MenuDaliCallback (Widget , XtPointer , XtPointer )
{
    char *cmd = (char*)"dali";
    char *cell = XmTextFieldGetString (Shell->Cell_Frame->SelectedCell_Txt);

    if (cell && *cell)
	SubmitCmdLine (mprintf ("%s %s", cmd, cell));
    else
	SubmitCmdLine (cmd);

    XtFree (cell);
}

/*
** X-Designer Stub ClearIntermediateData
*/

/******************
* Run "dbclean"
*/
void ClearIntermediateData (Widget , XtPointer client_data, XtPointer )
{
    char *format = (char *) client_data;
    char *cell;

    strcpy (CmdLine, "dbclean");
    if (!strcmp (format, "layout"))
	ADD_TO_CMDLINE ((char*)" -lv ");
    else if (!strcmp (format, "circuit"))
	ADD_TO_CMDLINE ((char*)" -cv ");
    else
	ADD_TO_CMDLINE ((char*)" -lcv ");

    cell = XmTextFieldGetString (Shell->Cell_Frame->SelectedCell_Txt);
    if (cell && *cell)
	ADD_TO_CMDLINE (cell);
    else
	ADD_TO_CMDLINE ((char*)"-a");

    SubmitCmdLine (CmdLine);

    XtFree (cell);
}

void remove_project (char *path)
{
    Project_t *p, *q;

    for (q = p = ProjectLt; p; q = p, p = p -> next)
    if (!strcmp (path, p -> path)) {
	if (p == ProjectLt)
	    ProjectLt = p -> next;
	else
	    q -> next = p -> next;
	DISPOSE (p -> path, 0);
	if (p -> relpath) DISPOSE (p -> relpath, 0);
	dmDispose_cl (p -> lcl[0]);
	dmDispose_cl (p -> lcl[1]);
	dmDispose_icl (p -> icl[0]);
	dmDispose_icl (p -> icl[1]);
	DISPOSE (p, 0);
	break;
    }
}

/********************************************************
* Remove database after the command has been confirmed.
*/
void RemoveDatabase ()
{
  if (!strcmp (rem_db, OpenedDatabase)) {
    if (dmproject && !chdir ("..")) {
	char *q;
	OpenedDatabase = strsave (rem_db); /* Bug fix (SdeG) */
	remove_project (rem_db);
	dmCloseProject (dmproject, COMPLETE);
	dmproject = (DM_PROJECT *) NULL;

	sprintf (CmdLine, "rmpr -fs %s", OpenedDatabase);
	if ((q = strrchr (OpenedDatabase, '/'))) *q = 0;
	new_db = NULL;
	ExecuteSpaceCommand (CmdLine, NULL, ChangeToOtherDatabase);
    }
    else
	PopupMessageBox ((char*)"Cannot remove the current database directory!");
  }
  else {
	remove_project (rem_db);
	sprintf (CmdLine, "rmpr -fs %s", rem_db);
	ExecuteSpaceCommand (CmdLine, NULL, NULL);

    if (PrevisDatabase) {
	Project_t *p = ProjectLt -> next;
	if (p && p -> path == PrevisDatabase) return;
	PrevisDatabase = (p && p -> mode != 1)? p -> path : NULL;
	XmTextFieldSetString (UsedFilesWin->PrevDir_Txt, PrevisDatabase);
	if (!PrevisDatabase) XtSetSensitive (Shell->PreviousButton, FALSE);
    }
  }
}

/*
** X-Designer Stub ClearSelectedCell
*/

void ClearSelectedCell (Widget , XtPointer , XtPointer )
{
    XmTextFieldSetString (Shell->Cell_Frame->SelectedCell_Txt, (char*)"");
}

void add_to_proj_list (char *path, char *addpath)
{
    Project_t *p, *q;
    char *s, *msg;
    char *relpath = 0;

    if (addpath) {
	if (*path != '/')
	    path = mprintf ("%s/%s", addpath, relpath = path);
    }
    else
	path = strip_blanks (path);

    if (chdir (path) == -1) {
	msg = (char*)"Could not chdir to"; goto ret;
    }
    if (!(s = getcwd (NULL, MAXLENGTH_OF_FILENAME+1))) {
	msg = (char*)"Could not getcwd for"; goto ret;
    }
    if (!IsDatabase (s)) {
	DISPOSE (s, 0);
	msg = (char*)"Could not open .dmrc for"; goto ret;
    }

    q = 0;
    for (p = ProjectLt; p; q = p, p = p -> next) {
	if (!strcmp (s, p -> path)) break;
    }
    if (!p) { /* new path not found */
	p = NEW (Project_t, 1);
	p -> path = s;
	p -> relpath = relpath? strsave (relpath) : relpath;
	p -> mode = 0;
	p -> t_lcl[0] = 0; p -> t_lcl[1] = 0;
	p -> t_icl[0] = 0; p -> t_icl[1] = 0;
	p -> lcl[0] = 0; p -> lcl[1] = 0;
	p -> icl[0] = 0; p -> icl[1] = 0;
	p -> next = 0;
	if (q)
	    q -> next = p;
	else
	    ProjectLt = p;
    }
    return;
ret:
    if (relpath)
	PopupMessageBox (mprintf ("%s:\n\"%s/%s\"", msg, addpath, relpath));
    else
	PopupMessageBox (mprintf ("%s:\n\"%s\"", msg, path));
}

/**********************************************************
* After the path stored in "OpenedDatabase" has been changed,
* change the working directory to this new path (if possible,
* otherwise go to startup directory).  Adapt technology
* defaults, dmproject variable etc. in case the new directory
* is a NELSIS database.
*/
void ChangeToOtherDatabase ()
{
    FILE *fp;
    int processNumber, processIndex, isDB;
    char *dbpath, *s, c;
    Project_t *p, *q;

    /* new_db cannot be directly the OpenedDatabase, because it is always a strsave */
    dbpath = new_db;
    while (!dbpath || chdir (dbpath) == -1) {
	if (dbpath) {
	    PopupMessageBox (mprintf ("Could not chdir to:\n\"%s\"", dbpath));
	    if (dbpath == OriginalPath) break;
again:
	    remove_project (dbpath); /* try to remove */
	}
	if (ProjectLt && ProjectLt -> mode != 1) {
	    dbpath = ProjectLt -> path;
	    if (dbpath == OpenedDatabase) goto set_prev;
	}
	else
	    dbpath = OriginalPath;
    }

    if (!(isDB = IsDatabase (dbpath))) {
	PopupMessageBox (mprintf ("The following directory is not a database:\n\"%s\"", dbpath));
	if (dbpath != OriginalPath) goto again;
    }

    if (!(OpenedDatabase = getcwd (NULL, MAXLENGTH_OF_FILENAME+1))) {
	PopupMessageBox (mprintf ("Could not get current working directory:\n\"%s\"", dbpath));
	OpenedDatabase = strsave (OriginalPath);
    }

    if (dmproject) {
	dmCloseProject (dmproject, COMPLETE);
	dmproject = (DM_PROJECT *) NULL;
    }

    if (isDB && !(dmproject = dmOpenProject (OpenedDatabase, DEFAULT_MODE))) {
	if (dbpath != OriginalPath) {
	    DISPOSE (OpenedDatabase, 0);
	    goto again;
	}
    }
    if (dmproject) {
	if (!ProjectLt || dbpath != ProjectLt -> path) { /* SdeG3.13 */
	    for (q = p = ProjectLt; p; q = p, p = p -> next) {
		if (!strcmp (OpenedDatabase, p -> path)) { /* found */
		    if (p != ProjectLt) { /* place current project on top */
			q -> next = p -> next;
			p -> next = ProjectLt;
			ProjectLt = p;
		    }
		    DISPOSE (p -> path, 0);
		    break;
		}
	    }
	    if (!p) { /* new project not found */
		p = NEW (Project_t, 1);
		p -> relpath = 0;
		p -> t_lcl[0] = 0; p -> t_lcl[1] = 0;
		p -> t_icl[0] = 0; p -> t_icl[1] = 0;
		p -> lcl[0] = 0; p -> lcl[1] = 0;
		p -> icl[0] = 0; p -> icl[1] = 0;
		p -> next = ProjectLt;
		ProjectLt = p;
	    }
	}
	else
		DISPOSE (ProjectLt -> path, 0);
	ProjectLt -> path = OpenedDatabase;
	ProjectLt -> mode = 2;
set_prev:
	p = ProjectLt -> next;
	PrevisDatabase = (p && p -> mode != 1)? p -> path : NULL;
    }
    else
	PrevisDatabase = NULL;

    if (new_db) DISPOSE (new_db, 0);

    if (dbpath == OpenedDatabase) return;

    ClearSelectedCell (NULL, NULL, NULL);

    if (XtIsManaged (ImportWin->ImportDialog)) XtUnmapWidget (ImportWin->ImportWin);
    if (XtIsManaged (DeleteWin->DeleteDialog)) XtUnmapWidget (DeleteWin->DeleteWin);
    if (XtIsManaged (MacroWin->MacroDialog  )) XtUnmapWidget (MacroWin->MacroWin);

    AddToOutputWindow (mprintf (">>>> CWD=%s\n", OpenedDatabase));

    c = 0;
    if ((s = strrchr (OpenedDatabase, '/'))) {
	c = *++s;
	*s = '\0';
    }
    XmTextFieldSetString (NewDbWin->DatabaseNameText, OpenedDatabase);
    if (db_dir) XmStringFree (db_dir);
    db_dir = XmStringCreateLtoR (OpenedDatabase, csDEFAULT);
    if (s) *s = c;
    if (fi_dir) XmStringFree (fi_dir);
    fi_dir = XmStringCreateLtoR (OpenedDatabase, csDEFAULT);

    if (FileTypeMask == XmFILE_DIRECTORY)
	XtVaSetValues (FileSelectionWin->FileSelectionDialog, XmNdirectory, db_dir, NULL);
    else if (FileTypeMask == XmFILE_REGULAR)
	XtVaSetValues (FileSelectionWin->FileSelectionDialog, XmNdirectory, fi_dir, NULL);

    XtVaSetValues(Shell->Shell, XmNtitle, mprintf ("helios - %s", OpenedDatabase), NULL);
    XmTextFieldSetString (UsedFilesWin->PWD_Txt, OpenedDatabase);
    XmTextFieldSetString (UsedFilesWin->PrevDir_Txt, PrevisDatabase);

    if (dmproject) {
	SetMenuSensitive (TRUE);

	ReadTechnologyDefaults();

	ListCells ();

	ReadUserDefaults (mprintf ("%s/helios.defaults", OpenedDatabase));

	fp = fopen (mprintf ("%s/%s", OpenedDatabase, DBRCFILE), "r");

	fgets (globalTextBuffer, sizeof(globalTextBuffer), fp);
	XmTextFieldSetString (UsedFilesWin->Version_Txt, mprintf ("%d", atoi (globalTextBuffer)));

	fgets (globalTextBuffer, sizeof(globalTextBuffer), fp);
	if (sscanf (globalTextBuffer, "%d", &processIndex) == 1) {
	    /* a process id is specified. */

	    for (processNumber = 0;  processNumber < NumberOfProcesses; processNumber++) {
		if (ProcessItems[processNumber].index == processIndex) break;
	    }
	    if (processNumber < NumberOfProcesses) {
		TechnologyName = ProcessItems[processNumber].name;
		XmTextFieldSetString (UsedFilesWin->Technology_Txt, TechnologyName);
		TechnologyPath[0] = '\0';
	    }
	    else {
		XmTextFieldSetString (UsedFilesWin->Technology_Txt, (char*)"");
		PopupMessageBox (mprintf (
		    "Invalid process in project-database to be opened.\n%s%d%s\n%s\n%s \"%s\".",
		    "Process with id# ", processIndex, " is unknown.",
		    "Check that the environment variable ICDPATH is set correctly;",
		    "the current setting is", icdpath));
	    }
	}
	else {
	    /* a process directory path is specified. */
	    sscanf (globalTextBuffer, "%s", TechnologyPath);
	    TechnologyName = NULL;
	    XmTextFieldSetString (UsedFilesWin->Technology_Txt, TechnologyPath);
	}

	fgets (globalTextBuffer, sizeof(globalTextBuffer), fp);
	XmTextFieldSetString (UsedFilesWin->Lambda_Txt, lambdaStr (globalTextBuffer));
	fclose (fp);
    }
    else {
	SetMenuSensitive (FALSE);
	ListCells ();
    }
}

/*
** X-Designer Stub CancelRetrieval
*/

void CancelRetrieval (Widget , XtPointer client_data, XtPointer )
{
    long mode = (long) client_data;

    if (XtIsManaged (RetrieveOptionSPICEWin->RetrieveOptionSPICEDialog)) {
	if (mode) AdmWindow (SPICE_ADVANCED_OPTION, ACC_VALUES);
	XtUnmanageChild (RetrieveOptionSPICEWin->RetrieveOptionSPICEDialog);
    }
    if (XtIsManaged (RetrieveOptionSLSWin->RetrieveOptionSLSDialog)) {
	if (mode) AdmWindow (SLS_ADVANCED_OPTION, ACC_VALUES);
	XtUnmanageChild (RetrieveOptionSLSWin->RetrieveOptionSLSDialog);
    }
    if (XtIsManaged (RetrieveOptionEDIFWin->RetrieveOptionEDIFDialog)) {
	if (mode) AdmWindow (EDIF_ADVANCED_OPTION, ACC_VALUES);
	XtUnmanageChild (RetrieveOptionEDIFWin->RetrieveOptionEDIFDialog);
    }
    if (XtIsManaged (RetrieveOptionNLEWin->RetrieveOptionNLEDialog)) {
	if (mode) AdmWindow (NLE_ADVANCED_OPTION, ACC_VALUES);
	XtUnmanageChild (RetrieveOptionNLEWin->RetrieveOptionNLEDialog);
    }
    if (XtIsManaged (RetrieveOptionVHDLWin->RetrieveOptionVHDLDialog)) {
	if (mode) AdmWindow (VHDL_ADVANCED_OPTION, ACC_VALUES);
	XtUnmanageChild (RetrieveOptionVHDLWin->RetrieveOptionVHDLDialog);
    }
}

/*
** X-Designer Stub RunRetrieveCallback
*/

/******************************************************************
* Retrieve a netlist from the circuit part of the NELSIS database
*/
void RunRetrieveCallback (Widget , XtPointer , XtPointer )
{
    char *cell;

    cell = XmTextFieldGetString (Shell->Cell_Frame->SelectedCell_Txt);
    if (!cell || !*cell)
	PopupMessageBox ((char*)"You have to select a cell to be retrieved.");
    else {
	AdmVariable (RETRIEVE_OPTION, WRITE_PARAMS, NULL);
	ADD_TO_CMDLINE (mprintf (" %s", cell));
	if (Namefile) ADD_TO_CMDLINE (mprintf (" > %s", Namefile));
	SubmitCmdLine (CmdLine);
    }
    XtFree (cell);
}

/*
** X-Designer Stub DisplayCellStatus
*/

/********************************************************
* Display alphabetically ordered lists of cells with and
* without macro status.
*/
void DisplayCellStatus (Widget w, XtPointer , XtPointer )
{
    struct stat buf;
    IMPCELL **importedCells;
    char **cell_list;
    char *s1, *s2;
    XmString xmstring;
    int i;

    if (w) {
	i = (dmStatXData (dmproject, &buf) == 0);
	if (i != new_proj) {
	    if ((new_proj = i)) {
		s1 = (char*)"Library";
		s2 = (char*)"Library Status";
		XtMapWidget (MacroWin->SetRemote_Bttn);
	    }
	    else {
		s1 = (char*)"Device+Macro";
		s2 = (char*)"Device+Macro Status";
		XtUnmapWidget (MacroWin->SetRemote_Bttn);
	    }
	    xmstring = XmStringCreateLtoR (s1, csDEFAULT);
	    XtVaSetValues (MacroWin->Library_Bttn, XmNlabelString, xmstring, NULL);
	    XmStringFree (xmstring);
	    xmstring = XmStringCreateLtoR (s2, csDEFAULT);
	    XtVaSetValues (MacroWin->LibStatus_Lbl, XmNlabelString, xmstring, NULL);
	    XmStringFree (xmstring);
	}
    }
    XtVaSetValues (MacroWin->Itype_OptnMn, XmNmenuHistory, MacroWin->Default_Bttn, NULL);
    SetMasksText (MacroWin->Default_Bttn, NULL, NULL);
    XmTextFieldSetString (MacroWin->Timestamp_Txt, (char*)"");

    XmListDeleteAllItems (MacroWin->RegularSetList);
    XmListDeleteAllItems (MacroWin->MacroSetList);
    XmListDeleteAllItems (MacroWin->DeviceSetList);
    XmListDeleteAllItems (MacroWin->LibrarySetList);

    if ((cell_list = getCellList (dmproject, (char*)LAYOUT))) {
        while ((s1 = *cell_list)) {
	    if ((i = ((unsigned)*s1 > IS_ROOT))) *s1 &= 0177;
	    switch (ManageCellStatus (s1, -1, -1, -1, NULL)) {
	    case  1: w = MacroWin->MacroSetList; break;
	    case  2: w = MacroWin->DeviceSetList; break;
	    case  3: w = MacroWin->LibrarySetList; break;
	    default: w = MacroWin->RegularSetList;
	    }
	    switch (interfacetype) {
	    case  1: s2 = mprintf ("%s (F)", s1); break;
	    case  2: s2 = mprintf ("%s (FM)", s1); break;
	    default: s2 = s1;
	    }
	    xmstring = XmStringCreateLtoR (s2, csDEFAULT);
	    XmListAddItemUnselected (w, xmstring, 0);
            XmStringFree (xmstring);
	    if (i) *s1 += IS_ROOT;
            ++cell_list;
        }
    }

    if ((importedCells = getImpCellList (dmproject, (char*)LAYOUT))) {
	while (*importedCells) {
	    s1 = (*importedCells)->alias;
	    switch (ManageCellStatus (s1, -1, -1, -1, *importedCells)) {
	    case  1: w = MacroWin->MacroSetList; break;
	    case  2: w = MacroWin->DeviceSetList; break;
	    case  3: w = MacroWin->LibrarySetList; break;
	    default: w = MacroWin->RegularSetList;
	    }
	    if (interfaceremote) {
		switch (interfacetype) {
		case  1: s2 = mprintf ("*%s (*F)", s1); break;
		case  2: s2 = mprintf ("*%s (*FM)", s1); break;
		default: s2 = mprintf ("*%s (*S)", s1);
		}
	    }
	    else {
		switch (interfacetype) {
		case  1: s2 = mprintf ("*%s (F)", s1); break;
		case  2: s2 = mprintf ("*%s (FM)", s1); break;
		default: s2 = mprintf ("*%s", s1);
		}
	    }
	    xmstring = XmStringCreateLtoR (s2, csDEFAULT);
	    XmListAddItemUnselected (w, xmstring, 0);
	    XmStringFree (xmstring);
	    ++importedCells;
	}
    }
}

int SetCellMasks ()
{
    DM_PROCDATA *mdata;
    char *s;
    int   i;

    mdata = (DM_PROCDATA *) dmGetMetaDesignData (PROCESS, dmproject);
    if (!mdata) {
	PopupMessageBox ((char*)"Cannot set interfacetype: no maskdata!");
	return 1;
    }

    cell_msks = XmTextFieldGetString (MacroWin->FMasks_Txt);
    if (!cell_msks || !*cell_msks) goto ret;

    s = strtok (cell_msks, " ,+");
    for (i = 0; i < mdata->nomasks; ++i) mdata->mask_no[i] = 0;
    while (s) {
	for (i = 0; i < mdata->nomasks; ++i) {
	    if (strcmp (s, mdata->mask_name[i]) == 0) {
		mdata->mask_no[i] = 1;
		break;
	    }
	}
	s = strtok (NULL, " ,+");
    }
    s = cell_msks;
    for (i = 0; i < mdata->nomasks; ++i) {
	if (mdata->mask_no[i]) {
	    if (new_proj) {
		if (s > cell_msks) *s++ = ' ';
		sprintf (s, "%d", i);
	    }
	    else {
		if (s > cell_msks) *s++ = '+';
		strcpy (s, mdata->mask_name[i]);
	    }
	    s += strlen (s);
	}
    }
    *s = 0;
    if (*cell_msks) return 0;
ret:
    PopupMessageBox ((char*)"Cannot set interfacetype: no masklist!");
    if (cell_msks) XtFree (cell_msks);
    return 1;
}

/*
** X-Designer Stub StatusSetCallback
*/

/*
* Set status of the selected cells to celltype.
*/
void StatusSetCallback (Widget w, XtPointer client_data, XtPointer )
{
    long type = (long)client_data;
    int ok = 0;

    if (type >= 0 && type <= 4) {
	char *cell, *s;
	Arg args[2];
	XmString *xmstring;
	int i, it, count, oldtype;
	int skip_loc, skip_imp;

	it = -1;
	if (type != 4) {
	    cell_msks = (char*)"";
	    XtVaGetValues (MacroWin->Itype_OptnMn, XmNmenuHistory, &w, NULL);
	    if (w == MacroWin->Strict_Bttn) it = 0;
	    else if (w == MacroWin->Free_Bttn) it = 1;
	    else if (w == MacroWin->FMasks_Bttn) {
		it = SetCellMasks () ? -1 : 2;
	    }
	}

	skip_loc = skip_imp = 0;

	for (oldtype = 0; oldtype <= 3; ++oldtype) {
	    switch (oldtype) {
	    case 0: w = MacroWin->RegularSetList; break;
	    case 1: w = MacroWin->MacroSetList; break;
	    case 2: w = MacroWin->DeviceSetList; break;
	    case 3: w = MacroWin->LibrarySetList;
	    }
	    XtSetArg (args[0], XmNselectedItemCount, &count);
	    XtSetArg (args[1], XmNselectedItems, &xmstring);
	    XtGetValues (w, args, 2);
	    /* set status of selected cells */
	    for (i = 0; i < count; ++i) {
		XmStringGetLtoR (xmstring[i], XmSTRING_DEFAULT_CHARSET, &cell);
		if (cell) {
		    IMPCELL *icle = NULL;
		    s = strchr (cell, '(');
		    if (s) *(s-1) = '\0';
		    s = cell;
		    if (*cell == '*') {
			IMPCELL **icl;
			++cell;
			if ((icl = getImpCellList (dmproject, (char*)LAYOUT)))
			    while ((icle = *icl++))
				if (!strcmp (icle->alias, cell)) break;
			if (!icle) {
			    PopupMessageBox (mprintf ("Cannot find imported cell:\n\"%s\"", cell));
			    goto skip;
			}
			else if (!new_proj) {
			    skip_imp = 1;
			    goto skip;
			}
		    }
		    else if (type == 4) {
			skip_loc = 1;
			goto skip;
		    }
		    (void) ManageCellStatus (cell, oldtype, type, it, icle);
		    ok = 1;
skip:
		    XtFree (s);
		}
	    }
	}

	if (skip_imp) PopupMessageBox ((char*)"Cannot set status for imported cells!");
	if (skip_loc) PopupMessageBox ((char*)"Cannot set local cells to remote status!");

	if (it == 2) XtFree (cell_msks);
    }
    if (ok) {
	NOdmErrorMsg = 1;
	DisplayCellStatus (NULL, NULL, NULL);
	NOdmErrorMsg = 0;
    }
}

/*************************************************************
* Perform selected tasks for  a l l  variables of a window.
* Used e.g. for setting factory defaults everywhere.
*/
void AdmWindow (int item, int action)
{
    int end;

    switch (item) {
    case EXTRACTION_OPTION:	end = END_EXTRACTION_OPTION;	break;
    case CAPACITANCE_FAST:	end = END_CAPACITANCE_FAST;	break;
    case CAPACITANCE_ACCURATE:	end = END_CAPACITANCE_ACCURATE;	break;
    case RESISTANCE_EXTRACT:	end = END_RESISTANCE_EXTRACT;	break;
    case SUBRES_ACCRT_FINE:	end = END_SUBRES_ACCRT_FINE;	break;
    case SUBCAP_FAST_FINE:	end = END_SUBCAP_FAST_FINE;	break;
    case SUBCAP_ACCRT_FINE:	end = END_SUBCAP_ACCRT_FINE;	break;
    case CIRCUIT_REDUCTION:	end = END_CIRCUIT_REDUCTION;	break;
    case MISCELLANEOUS_FINE:	end = END_MISCELLANEOUS_FINE;	break;
    case RETRIEVE_OPTION:	end = END_RETRIEVE_OPTION;	break;
    case XSPACE:
	AdmVariable (item, action, NULL);
	AdmVariable (XSPACE_REST, action, NULL);
	return;
    default:
	AdmVariable (item, action, NULL);
	return;
    }
    while (++item < end) AdmVariable (item, action, NULL);
}

/*
** X-Designer Stub PopupListSelectWin
*/

/******************************************************************************
* Popup window to select from a list.
*/
void PopupListSelectWin (Widget , XtPointer client_data, XtPointer )
{
    int i;
    char **cell_list, *project, *description, *s;
    XmString xmstring;
    DM_PROJECT *readDevModproject;
    DM_CELL *cell_key;
    DM_STREAM *dsp;
    struct stat buf;

    strncpy (ListSelectorTitle, (char *) client_data, sizeof(ListSelectorTitle)-1);

    XmListDeleteAllItems (SelectionWin->SelectionList);

    if (strstr (ListSelectorTitle, "Select Process")) {
	for (i = 0; i < NumberOfProcesses; ++i) {
	    s = strlen (ProcessItems[i].name) > 10 ? (char *)"%-20s %s" : (char *)"%-10s %s";
	    xmstring = XmStringCreateLtoR (
		mprintf (s, ProcessItems[i].name, ProcessItems[i].comment), csDEFAULT);
	    XmListAddItem (SelectionWin->SelectionList, xmstring, 0);
	    XmStringFree (xmstring);
	}
    }
    else if (strstr (ListSelectorTitle, "Select Device Model")) {
	project = XmTextFieldGetString (DeviceModelWin->DbaseWithDevMod_Txt);
	if (!project || !*project) {
	    PopupMessageBox ((char*)
		"You must first select the database from which you\nwant to read the device model");
	    XtFree (project);
	    return;
	}
	/* open database containing device model */
	if (!(readDevModproject = open_project (project))) {
	    PopupMessageBox (mprintf ("\"%s\"\nis not a valid database!", project));
	    XtFree (project);
	    return;
	}
	XtFree (project);

	/* add all cells that are device models into selection list */
	if ((cell_list = getCellList (readDevModproject, (char*)CIRCUIT))) {
	    while (*cell_list) {
		if ((i = ((unsigned)**cell_list > IS_ROOT))) **cell_list &= 0177;
		cell_key = dmCheckOut (readDevModproject, *cell_list, ACTUAL, DONTCARE, CIRCUIT, READONLY);
		if (!cell_key) goto next_cell;
		if (dmStat (cell_key, "devmod", &buf) == 0) {
		    description = (char*)"";
		    /* get the description from device file */
		    dsp = dmOpenStream (cell_key, "devmod", "r");
		    while (fgets (globalTextBuffer, sizeof(globalTextBuffer), dsp->dmfp) != NULL) {
			if (strstr (globalTextBuffer, "* description") == globalTextBuffer) {
			    description = globalTextBuffer + strlen ("* description");
			    if ((s = strchr (description, '\n'))) *s = '\0';
			    while (isspace (*description)) ++description;
			    if (*description) {
				*--description = ' ';
				*--description = '#';
				*--description = ' ';
			    }
			    break;
			}
		    }
		    dmCloseStream (dsp, COMPLETE);

		    s = strlen (*cell_list) > 10 ? (char *)"%-20s%s" : (char *)"%-10s%s";
		    xmstring = XmStringCreateLtoR (mprintf (s, *cell_list, description), csDEFAULT);
		    XmListAddItem (SelectionWin->SelectionList, xmstring, 0);
		    XmStringFree (xmstring);
		}
		dmCheckIn (cell_key, COMPLETE);
next_cell:
		if (i) **cell_list += IS_ROOT;
		++cell_list;
	    }
	}
	/* close database containing device model */
	if (readDevModproject != dmproject)
	    dmCloseProject (readDevModproject, COMPLETE);
    }
    else if (strstr (ListSelectorTitle, "Open Imported")) {
	FILE *fp = fopen ("projlist", "r");
	i = 0;
	if (fp) {
	    char LibraryProject[1000];
	    while (fgets (LibraryProject, sizeof(LibraryProject), fp)) {
		++i;
		if ((s = strchr (LibraryProject, '\n'))) *s = '\0';
		xmstring = XmStringCreateLtoR (LibraryProject, csDEFAULT);
		XmListAddItem (SelectionWin->SelectionList, xmstring, 0);
		XmStringFree (xmstring);
	    }
	    fclose (fp);
	}
	if (!i) {
	    PopupMessageBox ((char*)"No imported database projects found.");
	    return;
	}
    }
    else if (strstr (ListSelectorTitle, "Open Previous")) {
	if (PrevisDatabase) {
	    Project_t *p;
	    for (p = ProjectLt -> next; p && p -> mode != 1; p = p -> next) {
		xmstring = XmStringCreateLtoR (p -> path, csDEFAULT);
		XmListAddItem (SelectionWin->SelectionList, xmstring, 0);
		XmStringFree (xmstring);
	    }
	    XmListSelectPos (SelectionWin->SelectionList, 1, TRUE);
	}
	else return;
    }

    /* Now popup the selection dialog box */
    XtManageChild (SelectionWin->SelectionDialog);
    XtVaSetValues (SelectionWin->SelectionWin, XmNtitle, ListSelectorTitle, NULL);
}

/*
** X-Designer Stub ListSelectionOKCallback
*/

/****************************************************************************
*  Pass on the text describing the selection to the appropriate text field.
*/
void ListSelectionOKCallback (Widget , XtPointer , XtPointer )
{
    XmString *xmstring;
    char *s, *selectionText;

    XtVaGetValues (SelectionWin->SelectionList, XmNselectedItems, &xmstring, NULL);

    if (!strcmp (ListSelectorTitle, "Select Process for New Database")) {
	char buf[BUFSIZ];
	FILE *fp;

	if (!xmstring)
	    selectionText = XmTextFieldGetString (NewDbWin->ProcessNameText);
	else
	    XmStringGetLtoR (*xmstring, XmSTRING_DEFAULT_CHARSET, &selectionText);

	if (!(s = strip2 (selectionText))) return;

	XmTextFieldSetString (NewDbWin->ProcessNameText, s);
	if (*s) {
	    if (isProcessName (s))
		sprintf (buf, "%s/share/lib/process/%s/default_lambda", icdpath, s);
	    else
		sprintf (buf, "%s/default_lambda", s);
	    if ((fp = fopen (buf, "r"))) {
		*buf = '\0';
		fscanf (fp, "%s", buf);
		fclose (fp);
		XmTextFieldSetString (NewDbWin->LambdaText, lambdaStr (buf));
	    }
	}
	XtFree (selectionText);
	return;
    }

    if (!xmstring) return;
    XmStringGetLtoR (*xmstring, XmSTRING_DEFAULT_CHARSET, &selectionText);

    /* Cut possible comment information */
    if ((s = strchr (selectionText, ' '))) *s = '\0';

    if (!strcmp (ListSelectorTitle, "Select Process for New Technology")) {
	XmTextFieldSetString (NewTechWin->NewTechProcess_Txt, selectionText);
    }
    else if (strstr (ListSelectorTitle, "Select Device Model")) {
	XmTextFieldSetString (DeviceModelWin->DevModFromDbase_Txt, selectionText);
	ReadDeviceModel ();
    }
    else if (strstr (ListSelectorTitle, "Open Imported")) {
	if (IsDatabase (selectionText)) {
	    new_db = strsave (selectionText);   /* refresh the database string */
	    ChangeToOtherDatabase ();
	}
	else
	    PopupMessageBox (mprintf ("\"%s\"\nis no valid database.", selectionText));
    }
    else if (strstr (ListSelectorTitle, "Open Previous")) {
	new_db = strsave (selectionText);   /* refresh the database string */
	ChangeToOtherDatabase ();
    }
    XtFree (selectionText);
}

/*
** X-Designer Stub NewTechDefaultCallback
*/

/*******************************************************************************
* Insert for process and maskdata-file those used corresponding in the
* presently active database (if any).
*/
void NewTechDefaultCallback (Widget , XtPointer , XtPointer )
{
    char *name, *path;

    path = 0;
    if ((name = getenv ("ICDPROCESS"))) {
	if (!isProcessName (name)) path = name;
    }
    else if (dmproject && TechnologyName) {
	name = TechnologyName;
    }
    else if (dmproject && TechnologyPath[0]) {
	path = name = TechnologyPath;
    }
    else {
	path = (char*)"."; name = (char*)"";
    }
    if (path)
	path = mprintf ("%s/maskdata", path);
    else
	path = mprintf ("$ICDPATH/share/lib/process/%s/maskdata", name);
    XmTextFieldSetString (NewTechWin->NewTechMask_Txt, path);
    XmTextFieldSetString (NewTechWin->NewTechProcess_Txt, name);
    XmToggleButtonSetState (NewTechWin->NewTechOptionButton, TRUE, TRUE);
    XmToggleButtonSetState (NewTechWin->NewTechUseProcess, TRUE, TRUE);
}

/*
** X-Designer Stub NewTechOKCallback
*/

/*******************************************************
* Call technology compiler tecc
*/
void NewTechOKCallback (Widget , XtPointer , XtPointer )
{
    char *s, *string;
    struct stat buf;

    if (!XmToggleButtonGetState (NewTechWin->NewTechOptionButton))
        strcpy (CmdLine, "tecc -n ");
    else
        strcpy (CmdLine, "tecc ");

    if (XmToggleButtonGetState (NewTechWin->NewTechUseProcess)) {
	string = XmTextFieldGetString (NewTechWin->NewTechProcess_Txt);
	if ((s = strip2 (string)) && *s)
	    ADD_TO_CMDLINE (mprintf ("-p %s ", s));
    }
    else {
	string = XmTextFieldGetString (NewTechWin->NewTechMask_Txt);
	if (!string || !*string) {
	    PopupMessageBox ((char*)"No maskdata file specified!");
	    goto ret;
	}
	ADD_TO_CMDLINE (mprintf ("-m %s ", trimPath (string)));
    }
    XtFree (string);

    string = XmTextFieldGetString (NewTechWin->NewTechElemDef_Txt);
    if (!string || !*string) {
	PopupMessageBox ((char*)"No element definition file specified!");
	goto ret;
    }
    if (stat (string, &buf) == 0 && !S_ISDIR (buf.st_mode)) {
	ADD_TO_CMDLINE (trimPath (string));
	SubmitCmdLine (CmdLine);
    }
    else
        PopupMessageBox (mprintf ("File\n\"%s\"\ndoes not exist, or cannot be read!", string));
ret:
    XtFree (string);
}

/*
** X-Designer Stub SelectItemCallback
*/

/******************************************************************
* When you browse the selection list, the selected item will be
* shown in the text field pointed by client_dat.
*/
void SelectItemCallback (Widget , XtPointer , XtPointer )
{
    XtUnmanageChild (SelectionWin->SelectionDialog);
    ListSelectionOKCallback (NULL, NULL, NULL);
}

/*
** X-Designer Stub SelectCellCallback
*/

/******************************************************************
* When you browse the cell list, the selected cell will be
* shown in the text field SelectedCell_Txt.
*/
void SelectCellCallback (Widget , XtPointer , XtPointer xt_call_data)
{
    XmListCallbackStruct *call_data = (XmListCallbackStruct *) xt_call_data;
    char *cell, *marker;

    if (XmStringGetLtoR (call_data->item, csBOLD, &cell) ||
        XmStringGetLtoR (call_data->item, csNORMAL, &cell)) {

        /* Cut the comment information */
	if ((marker = strchr (cell, ' '))) *marker = '\0';

        XmTextFieldSetString (Shell->Cell_Frame->SelectedCell_Txt, cell);
    }
    XtFree (cell);
}

/*
** X-Designer Stub AddDatabaseToLibraryList
*/

/******************************************************************
* Add a database to the project list.
*/
void AddDatabaseToLibraryList (Widget , XtPointer , XtPointer )
{
    char *projectToBeImported, *string;
    int i, nrOfListedItems, found;
    Arg args[2];
    XmString *xmstring;

    projectToBeImported = XmTextFieldGetString (ImportWin->ImportRemoteDatabaseText);
    if (!projectToBeImported || !*projectToBeImported)
        PopupMessageBox ((char*)"No remote database is specified!");
    else {
	/* If selected project is already in the Libr.List, then do nothing! */
	XtSetArg (args[0], XmNitemCount, &nrOfListedItems);
	XtSetArg (args[1], XmNitems, &xmstring);
	XtGetValues (ImportWin->ImportProjectList, args, 2);
	for (i = 0; i < nrOfListedItems; i++) {
	    XmStringGetLtoR (xmstring[i], XmSTRING_DEFAULT_CHARSET, &string);
	    found = !strcmp (string, projectToBeImported);
	    XtFree (string);
	    if (found) goto ret;
	}
        if (IsDatabase (projectToBeImported)) {
	    strcpy (CmdLine, "addproj ");
	    ADD_TO_CMDLINE (projectToBeImported);
	    ExecuteSpaceCommand (CmdLine, NULL, UpdateLibraryList);
        }
        else
            PopupMessageBox (mprintf ("\"%s\"\nis no valid database!", projectToBeImported));
    }
ret:
    XtFree (projectToBeImported);
}

/****************************************************************
* "callOnCompletion" function for AddDatabaseToLibraryList
*/
void UpdateLibraryList ()
{
	DisplayProjlist (NULL, NULL, NULL);
}

/*
** X-Designer Stub RemoveDatabaseFromLibraryList
*/

/*************************************************************************
* Remove a database from the projlist. If a cell has been imported
* from a remote database, then this database cannot be removed.
*/
void RemoveDatabaseFromLibraryList (Widget , XtPointer , XtPointer )
{
    Arg args[2];
    XmString *DbToBeRemoved;
    FILE *fp1, *fp2;
    IMPCELL **importedCells;
    char *s, *RemoteDatabase;
    int count;

    /* X/Motif-settings are chosen such that at most one item can be selected from ImportProjectList
     * Check that one item has been selected, and get the name of the selected library database.
     */
    XtSetArg (args[0], XmNselectedItems, &DbToBeRemoved);
    XtSetArg (args[1], XmNselectedItemCount, &count);
    XtGetValues (ImportWin->ImportProjectList, args, 2);
    if (count == 0) return; /* No project item is selected */

    if (!XmStringGetLtoR (*DbToBeRemoved, XmSTRING_DEFAULT_CHARSET, &RemoteDatabase)) {
        PopupMessageBox ((char*)"Cannot get selected remote database string!");
	return;
    }
    /* Has any cell from the selected library database been imported? */

    if ((importedCells = getImpCellList (dmproject, (char*)LAYOUT))) {
	while (*importedCells) {
	    if (!strcmp ((*importedCells)->dmpath, RemoteDatabase)) goto ret;
	    ++importedCells;
	}
    }
    if ((importedCells = getImpCellList (dmproject, (char*)CIRCUIT))) {
	while (*importedCells) {
	    if (!strcmp ((*importedCells)->dmpath, RemoteDatabase)) goto ret;
	    ++importedCells;
	}
    }

    fp1 = fopen ("projlist", "r");
    fp2 = fopen ("projlist.new", "w");

    if (!fp1 || !fp2) {
	PopupMessageBox ((char*)
	"Cannot open file \"projlist\" to write to!\n\nRemote database not removed from library list!");
	if (fp1) fclose (fp1);
	if (fp2) {
	    fclose (fp2);
	    unlink ("projlist.new");
	}
	return;
    }

    count = 0;
    while (fgets (globalTextBuffer, sizeof(globalTextBuffer), fp1)) {
	if ((s = strchr (globalTextBuffer, '\n'))) *s = '\0';
	if (!strcmp (globalTextBuffer, RemoteDatabase)) { ++count; continue; }
	fprintf (fp2, "%s\n", globalTextBuffer);
    }
    fclose (fp1);
    fclose (fp2);

    if (!count) {
	PopupMessageBox (mprintf ("Remote database \"%s\"\nnot found in file \"projlist\"!", RemoteDatabase));
	unlink ("projlist.new");
    }
    else {
	rename ("projlist", "projlist.bak");
	rename ("projlist.new", "projlist");
    }
    XtFree (RemoteDatabase);

    UpdateLibraryList ();
    return;
ret:
    PopupMessageBox (mprintf ("%s%s%s",
	"You can only remove a remote database from the library list\n",
	"if none of its cells have been imported in any view.  First delete\n",
	"from the working database all cells imported from the remote database."));
}

/*
** X-Designer Stub DisplayRemoteCellList
*/

/**********************************************************************
* When you select a remote database from library list, the cells of
* the remote database will be listed in the remote cell list box, and
* the already imported cells will be marked.
*/
void DisplayRemoteCellList (Widget , XtPointer , XtPointer )
{
    XmString *xmstring, xmstr;
    Widget selectedButton;
    int isroot;
    char *RemoteDatabase, **remoteCells, *textBuffer, *view;
    DM_PROJECT *dmRemoteProject;
    IMPCELL **importedCells, **iCell;

    /* Get name of remote database which is selected */ /* DON'T free xmstring! */
    XtVaGetValues (ImportWin->ImportProjectList, XmNselectedItems, &xmstring, NULL);
    if (!xmstring) return;
    if (!XmStringGetLtoR (*xmstring, XmSTRING_DEFAULT_CHARSET, &RemoteDatabase)) return;
    XmTextFieldSetString (ImportWin->ImportRemoteDatabaseText, RemoteDatabase);

    /* List cells of remote database */
    XmListDeleteAllItems (ImportWin->ImportCellList);
    if (!(dmRemoteProject = open_project (RemoteDatabase))) {
	PopupMessageBox (mprintf ("Cannot open project:\n\"%s\"", RemoteDatabase));
    }

    XtVaGetValues (ImportWin->ImpView_OptnMn, XmNmenuHistory, &selectedButton, NULL);
    if (selectedButton == ImportWin->ImpViewCircuit_Bttn)
        view = (char*)CIRCUIT;
    else
        view = (char*)LAYOUT;

    remoteCells = dmRemoteProject? getCellList (dmRemoteProject, view) : 0;

    if ((importedCells = getImpCellList (dmproject, view))) {
	while (*importedCells) {
	    if (!strcmp ((*importedCells)->dmpath, RemoteDatabase)) break;
	    ++importedCells;
	}
    }

    /* Mark in the list of remote cells those that have been imported */

    if (remoteCells) {
        while (*remoteCells) {
	    if ((isroot = ((unsigned)**remoteCells > IS_ROOT))) **remoteCells &= 0177;

            textBuffer = NULL;
            if (importedCells) {
                iCell = importedCells;
                while (*iCell) {
                    if (!strcmp ((*iCell)->dmpath, RemoteDatabase) &&
                        !strcmp ((*iCell)->cellname, *remoteCells)) {
                        textBuffer = mprintf ("%s    (imported as %s)",
				*remoteCells, (*iCell)->alias);
                        break;
                    }
		    ++iCell;
                }
            }
            if (!textBuffer) textBuffer = *remoteCells;

            if (isroot) {
		xmstr = XmStringCreateLtoR (textBuffer, csBOLD);
		**remoteCells += IS_ROOT;
	    }
            else
		xmstr = XmStringCreateLtoR (textBuffer, csNORMAL);
            XmListAddItem (ImportWin->ImportCellList, xmstr, 0);
            XmStringFree (xmstr);
            ++remoteCells;
        }
    }
    else if ((iCell = importedCells)) {
	while (*iCell) {
	    if (!strcmp ((*iCell)->dmpath, RemoteDatabase)) {
		xmstr = XmStringCreateLtoR (mprintf ("%s    (imported as %s)",
			(*iCell)->cellname, (*iCell)->alias), csNORMAL);
		XmListAddItem (ImportWin->ImportCellList, xmstr, 0);
		XmStringFree (xmstr);
	    }
	    ++iCell;
	}
    }

    XtFree (RemoteDatabase);
    if (dmRemoteProject != dmproject) dmCloseProject (dmRemoteProject, COMPLETE);
}

/*
** X-Designer Stub DisplayProjlist
*/

/*******************************************************************
* Read library project file "projlist" and show the items in the
* library list box.
*/
void DisplayProjlist (Widget , XtPointer , XtPointer )
{
    FILE *fp;
    int count = 0;
    XmString xmstring;

    if (!XtIsManaged (ImportWin->ImportDialog)) return;

    XmListDeleteAllItems (ImportWin->ImportProjectList);
    XmListDeleteAllItems (ImportWin->ImportCellList);

    if ((fp = fopen ("projlist", "r"))) {
        char LibraryProject[1000], *s;

        while (fgets (LibraryProject, sizeof(LibraryProject), fp) != NULL) {
            if ((s = strrchr (LibraryProject, '\n'))) *s = '\0';
	    ++count;
	    xmstring = XmStringCreateLtoR (LibraryProject, csDEFAULT);
	    XmListAddItem (ImportWin->ImportProjectList, xmstring, 0);
	    XmStringFree (xmstring);
        }
        fclose (fp);

        /* if there is at least one item in the library list, select the last one */
        if (count) XmListSelectPos (ImportWin->ImportProjectList, 0, TRUE);
    }
    else
        PopupMessageBox (mprintf ("Cannot open file\n\"%s/projlist\"", OpenedDatabase));
}

/*
** X-Designer Stub AvoidDoubleImport
*/

/*********************************************************************************
*  Make unselectable those cells in ImportCellList that have been imported already.
*/
void AvoidDoubleImport (Widget w, XtPointer , XtPointer xt_call_data)
{
    XmListCallbackStruct *call_data = (XmListCallbackStruct *) xt_call_data;
    char *cellName;

    if (XmStringGetLtoR (call_data->item, csNORMAL, &cellName) ||
	XmStringGetLtoR (call_data->item, csBOLD, &cellName)) {
        if (strchr (cellName, ' '))  {
            XmListDeselectItem (w, call_data->item);
            DisplayDescription (NULL, (XtPointer) "Import Select cell", NULL);
        }
    }
    XtFree (cellName);
}

/*
** X-Designer Stub SetImportCellSelectionPolicy
*/

/********************************************************************
*  Set selection policy for the list from which cells may be selected for import.
*  When the local name for an imported cell is to be specified explicitly,
*  only one cell at a time may be selected for import.
*  With other options for the local cell name, multiple selections are possible.
*/
void SetImportCellSelectionPolicy (Widget w, XtPointer , XtPointer )
{
    if (w == ImportWin->ImpCellNewName_Bttn) {
        XmListDeselectAllItems (ImportWin->ImportCellList);
        XtVaSetValues (ImportWin->ImportCellList, XmNselectionPolicy, XmSINGLE_SELECT, NULL);
    }
    else {
        XtVaSetValues (ImportWin->ImportCellList, XmNselectionPolicy, XmMULTIPLE_SELECT, NULL);
    }
    XtSetSensitive (ImportWin->ImportName_Txt, w != ImportWin->ImpCellRemName_Bttn);
}

/****************************************************************
* An auxiliary function, encapsulating "DisplayRemoteCellList"
* for submission as "callOnCompletion" function of ExecuteSpaceCommand.
*/
void UpdateImportCellList ()
{
    DisplayRemoteCellList (NULL, NULL, NULL);
    ListCells ();
}

/*
** X-Designer Stub ImportRemoteCell
*/

/*******************************************************************
*  Import remote cell into present database (i.e., make a link).
*/
void ImportRemoteCell (Widget , XtPointer , XtPointer )
{
    char *importName, *prefix, *cell, *RemoteDatabase, *ScriptFileName;
    int i, count;
    Arg args[2];
    XmString *xmstring;
    Widget selectedButton;
    FILE *fp;

    /* Get the name of remote database */
    XtVaGetValues (ImportWin->ImportProjectList, XmNselectedItems, &xmstring, NULL);
    if (!xmstring) {
        PopupMessageBox ((char*)"No remote database is specified in the current library list.");
        return;
    }
    XmStringGetLtoR (*xmstring, XmSTRING_DEFAULT_CHARSET, &RemoteDatabase);

    /* Get all selected cells */
    XtSetArg (args[0], XmNselectedItemCount, &count);
    XtSetArg (args[1], XmNselectedItems, &xmstring);
    XtGetValues (ImportWin->ImportCellList, args, 2);
    if (count == 0) {
        PopupMessageBox ((char*)"No remote cell is selected for import.");
        return;
    }

    /* Prepare general part of command line */
    XtVaGetValues (ImportWin->ImpView_OptnMn, XmNmenuHistory, &selectedButton, NULL);
    if (selectedButton == ImportWin->ImpViewCircuit_Bttn)
        strcpy (CmdLine, "impcell -c ");
    else
        strcpy (CmdLine, "impcell -l ");
    ADD_TO_CMDLINE (RemoteDatabase);

    XtVaGetValues (ImportWin->ImpCellName_OptnMn, XmNmenuHistory, &selectedButton, NULL);
    if (selectedButton == ImportWin->ImpCellRemName_Bttn || /* use remote name as local name */
        selectedButton == ImportWin->ImpCellPrefixedRemName_Bttn) { /* use prefixed remote name as local name */
        char buf[80];

        if (selectedButton == ImportWin->ImpCellPrefixedRemName_Bttn) {
	    prefix = trim (XmTextFieldGetString (ImportWin->ImportName_Txt));
	    if (!prefix || !*prefix) {
                 PopupMessageBox ((char*)"Prefix not specified - nothing imported.");
                 XtFree (RemoteDatabase);
                 XtFree (prefix);
                 return;
            }
        }
	else prefix = NULL;

         /* Gather commands for all selected cells in a script file, in order to avoid problems
          * due to the limited  number of program slots.
          */
        ScriptFileName = tempname ("temp_", buf, 80);
        if ((fp = OpenForWrite (ScriptFileName))) {
            for (i = 0; i < count; ++i) {
		if (XmStringGetLtoR (xmstring[i], csNORMAL, &cell) ||
		    XmStringGetLtoR (xmstring[i], csBOLD, &cell)) {
                    if (prefix)
                        fprintf (fp, "%s %s %s%s\n", CmdLine, cell, prefix, cell);
                    else
                        fprintf (fp, "%s %s\n", CmdLine, cell);
		    XtFree (cell);
                }
            }
            fclose(fp);
            ExecuteSpaceCommand (mprintf ("sh %s", ScriptFileName), ScriptFileName, UpdateImportCellList);
        }
	unlink (ScriptFileName);
	XtFree (prefix);
    }
    else if (selectedButton == ImportWin->ImpCellNewName_Bttn) { /* use explicitly specified local name */
	importName = trim (XmTextFieldGetString (ImportWin->ImportName_Txt));
	if (!importName || !*importName)
            PopupMessageBox ((char*)"No local cell name specified - nothing imported.");
        else {
	    if (XmStringGetLtoR (xmstring[0], csNORMAL, &cell) ||
		XmStringGetLtoR (xmstring[0], csBOLD, &cell)) {
                ADD_TO_CMDLINE (mprintf (" %s %s", cell, importName));
                ExecuteSpaceCommand (CmdLine, NULL, UpdateImportCellList);
		XtFree (cell);
            }
        }
        XtFree (importName);
    }
    XtFree (RemoteDatabase);
}

/*
** X-Designer Stub ImportCellMakeSelection
*/

/****************************************************************
* (De)select all (root)cells in ImportCellList
*/
void ImportCellMakeSelection (Widget w, XtPointer , XtPointer )
{
    int all, i, nrOfItems;
    Arg args[2];
    char *cell;
    XmString *items;

    XmListDeselectAllItems (ImportWin->ImportCellList);

    if (w == ImportWin->ImportAllRootCells_Bttn ||
	w == ImportWin->ImportAllCells_Bttn) {

	all = (w == ImportWin->ImportAllCells_Bttn);
	XtSetArg (args[0], XmNitemCount, &nrOfItems);
	XtSetArg (args[1], XmNitems, &items);  /* don't free XmString items */
	XtGetValues (ImportWin->ImportCellList, args, 2);

	for (i = 0; i < nrOfItems; ++i) {
	    if (XmStringGetLtoR (items[i], csBOLD, &cell) || /* A root cell is BOLD */
		(all && XmStringGetLtoR (items[i], csNORMAL, &cell))) {
		if (!strchr (cell, ' '))             /* reject already imported cells */
		    XmListSelectPos (ImportWin->ImportCellList, i + 1, FALSE);
		XtFree (cell);
	    }
	}
    }
}

/*
** X-Designer Stub ClearProgramOutputWindow
*/

/*******************************
* Erase ProgramOutput window
*/
void ClearProgramOutputWindow (Widget , XtPointer , XtPointer )
{
	XmTextSetString (Shell->WorkArea_Frame->WorkAreaText, (char*)"");
}

/*
** X-Designer Stub DeleteListCallback
*/

/**********************************************
* Displays/selects cells that can be deleted.
*/
void DeleteListCallback (Widget , XtPointer client_data, XtPointer )
{
    char *view, **cell_list, *cell;
    IMPCELL **impcell;
    int i, nrOfItems;
    Arg args[2];
    XmString xmstring, *items;
    Widget selectedButton;

    if (!strcmp("list", (char *) client_data)) {
        XtVaGetValues (DeleteWin->Delete_Frame->DeleteView_OptnMn, XmNmenuHistory, &selectedButton, NULL);
        if (selectedButton == DeleteWin->Delete_Frame->DeleteLayoutView_Bttn)
            view = (char*)LAYOUT;
        else
            view = (char*)CIRCUIT;

        XmListDeleteAllItems (DeleteWin->Delete_Frame->DeleteCellList);

        if ((cell_list = getCellList (dmproject, view))) {
            while (*cell_list) {
		if ((unsigned)**cell_list > IS_ROOT) {
		    **cell_list &= 0177;
		    xmstring = XmStringCreateLtoR (*cell_list, csBOLD);
		    **cell_list += IS_ROOT;
		}
                else
		    xmstring = XmStringCreateLtoR (*cell_list, csNORMAL);
                XmListAddItem (DeleteWin->Delete_Frame->DeleteCellList, xmstring, 0);
                XmStringFree (xmstring);
                ++cell_list;
            }
        }
        if ((impcell = getImpCellList (dmproject, view))) {
            while (*impcell) {
		xmstring = XmStringCreateLtoR (mprintf ("%s   (import from: %s, cell: %s)",
			(*impcell)->alias, (*impcell)->dmpath, (*impcell)->cellname), csNORMAL);
                XmListAddItem (DeleteWin->Delete_Frame->DeleteCellList, xmstring, 0);
                XmStringFree (xmstring);
                ++impcell;
            }
        }
    }
    else {
        XmListDeselectAllItems (DeleteWin->Delete_Frame->DeleteCellList);
        XtSetArg (args[0], XmNitemCount, &nrOfItems);
        XtSetArg (args[1], XmNitems, &items);
        XtGetValues (DeleteWin->Delete_Frame->DeleteCellList, args, 2);

        if (!strcmp("selectImported", (char *) client_data) ) {        /* Select all imported cells */
            for (i = 0; i < nrOfItems; ++i) {
		if (XmStringGetLtoR (items[i], csNORMAL, &cell) && strstr (cell, "(import from"))
                    XmListSelectItem (DeleteWin->Delete_Frame->DeleteCellList, items[i], FALSE);
                XtFree (cell);
            }
        }
        else if (!strcmp("selectRoot", (char *) client_data) ) {        /* Select all root cells */
            for (i = 0; i < nrOfItems; ++i) {
                /* only root cells are "bold" */
		if (XmStringGetLtoR (items[i], csBOLD, &cell))
                    XmListSelectPos (DeleteWin->Delete_Frame->DeleteCellList, i + 1, FALSE);
                XtFree (cell);
            }
        }
    }
}

void UpdateAfterDelete ()
{
    DeleteListCallback (NULL, (char *)"list", NULL);
    ListCells ();
    XtSetSensitive (DeleteWin->DeleteDialog, TRUE);
}

void CancelAfterDelete ()
{
    XtSetSensitive (DeleteWin->DeleteDialog, TRUE);
}

/*
** X-Designer Stub DeleteCellOKCallback
*/

/******************************************************************************
*  Deletes the specified cells - those selected,  a l l  root cells, ...
*/
void DeleteCellOKCallback (Widget w, XtPointer , XtPointer )
{
    char *cell, *view, *ScriptFileName, *flags;
    int i, nrOfItems;
    FILE *fp;
    Arg args[2];
    XmString *items;
    Widget selectedButton;

    XtVaGetValues (DeleteWin->Delete_Frame->DeleteView_OptnMn, XmNmenuHistory, &selectedButton, NULL);
    if (selectedButton == DeleteWin->Delete_Frame->DeleteLayoutView_Bttn)
        view = (char*)LAYOUT;
    else
        view = (char*)CIRCUIT;

    if (w == DeleteWin->DeleteSelectedCells_Bttn) {
        char buf[80];
        XtSetArg (args[0], XmNselectedItemCount, &nrOfItems);
        XtSetArg (args[1], XmNselectedItems, &items);
        XtGetValues (DeleteWin->Delete_Frame->DeleteCellList, args, 2);

        ScriptFileName = tempname ("temp_", buf, 80);
	fp = NULL;
	for (i = 0; i < nrOfItems; ++i) {
	    /* root cells are printed bold.
	     * rmdb currently does not allow removal of
	     * individual imported cells
	     */
	    if (XmStringGetLtoR (items[i], csBOLD, &cell) &&  !strstr (cell, "imported from:")) {
		if (!fp && !(fp = OpenForWrite (ScriptFileName))) break;
		fprintf (fp, "rmdb -fc %s %s\n", cell, view);
	    }
	    XtFree (cell);
	}
	if (fp) {
	    fclose(fp);
	    XtSetSensitive (DeleteWin->DeleteDialog, FALSE);
	    ExecuteSpaceCommand (mprintf ("sh %s", ScriptFileName), ScriptFileName, UpdateAfterDelete);
	}
	unlink (ScriptFileName);
    }
    else if (w == DeleteWin->DeleteLocalCells_Bttn ||
	w == DeleteWin->DeleteImportedCells_Bttn ||
	w == DeleteWin->DeleteAllCells_Bttn) {

	if (w == DeleteWin->DeleteLocalCells_Bttn) {
	    flags = (char*)"af"; cell = (char*)" local";
	}
	else if (w == DeleteWin->DeleteImportedCells_Bttn) {
	    flags = (char*)"if"; cell = (char*)" imported";
	}
	else {
	    flags = (char*)"aif"; cell = (char*)"";
	}
	sprintf (CmdLine, "rmdb -%s %s", flags, view);
	ConfirmedCommandInfo.cmdLine = strsave (CmdLine);
	ConfirmedCommandInfo.tempFileName = NULL;
	ConfirmedCommandInfo.callOnCompletion = UpdateAfterDelete;
	ConfirmedCommandInfo.callOnDenial = CancelAfterDelete;
	XtSetSensitive (DeleteWin->DeleteDialog, FALSE);
	sprintf (CmdLine, "Do you really want to\ndelete all%s cells?", cell);
	PopupConfirmWin (CmdLine);
    }
}

/*
** X-Designer Stub DeleteListSelectCallback
*/

/*******************************************************************
* Disable selection of all but root cells in the list of cells
* which can be deleted.
*/
void DeleteListSelectCallback (Widget w, XtPointer , XtPointer xt_call_data)
{
    XmListCallbackStruct *call_data = (XmListCallbackStruct *) xt_call_data;
    char *cell;

    if (!XmStringGetLtoR (call_data->item, csBOLD, &cell)) {
        XmListDeselectItem (w, call_data->item);
        DisplayDescription (NULL, (XtPointer) "Delete Select cell", NULL);
    }
    XtFree (cell);
}

/*
** X-Designer Stub DeviceModelSaveCallback
*/

/****************************************************************************
*  Save a device model from the screen to either a ".dev" file,
*  or a subdirectory of the circuit directory of the present working database.
*/
void DeviceModelSaveCallback (Widget w, XtPointer client_data, XtPointer )
{
    char *device, *prefix, *terminals, *formalDescription, *informalDescription, *DeviceFile;
    FILE *fp;

    if (w && XmToggleButtonGetState (DeviceModelWin->SaveInFile)) {
	PopupFileSelectWin (NULL, (void *)"Save Device Model in File", NULL);
	return;
    }

    device = trim (XmTextFieldGetString (DeviceModelWin->DeviceName_Txt));
    prefix = trim (XmTextFieldGetString (DeviceModelWin->DevModPrefix_Txt));
    terminals = XmTextFieldGetString (DeviceModelWin->DevModTerminals_Txt);

    if (!device || !*device || !prefix || !*prefix || !terminals || !*terminals) {
        PopupMessageBox ((char*)"Make sure that the Device, Prefix\nand Terminals text fields are filled in.");
        goto ret;
    }

    informalDescription = XmTextFieldGetString (DeviceModelWin->DevModInformal_Txt);
    formalDescription = (char *) XmTextGetString (DeviceModelWin->DevModFormal_Txt);

    /* Determine the file to write to.  In case this procedure was invoked
     * by "save in database", it will be a temporary file, which is only needed as
     * input for the putdevmod program, and can be discarded after it served this
     * purpose.
     */

    if (w) {
        /* The program used to import a device model into the database
         * needs a device file as input.  Therefore, create a temporary file,
         * and first save into this.
         */
	char buf[80];
	DeviceFile = tempname ("temp_", buf, 80);
        if ((fp = fopen (DeviceFile, "w"))) {
            WriteDeviceFile (fp, device, terminals, prefix, formalDescription, informalDescription);
            fprintf (fp, "\n");
            fclose (fp);

	    sprintf (CmdLine, "putdevmod %s%s",
		XmToggleButtonGetState (DeviceModelWin->SaveInDbEquiv_Tggl)? "-e " : "",
		DeviceFile);
            ExecuteSpaceCommand (CmdLine, DeviceFile, ListCells);
        }
        else
            PopupMessageBox ((char*)"Cannot write device model to temp.file\n\nDevice model not saved!");

	unlink (DeviceFile);
    }
    else {  /* save in file, called from FileSelectionOKCallback */
        DeviceFile = strsave ((char *) client_data);

        if ((fp = fopen (DeviceFile, "w"))) {
            WriteDeviceFile (fp, device, terminals, prefix, formalDescription, informalDescription);
            fprintf (fp, "\n");
            fclose (fp);
        }
        else
            PopupMessageBox (mprintf ("Cannot write device model to file\n\"%s\".\nCheck permissions!",
                             DeviceFile));

        DISPOSE (DeviceFile, 0);
    }

    XtFree (informalDescription);
    XtFree (formalDescription);
ret:
    XtFree (device);
    XtFree (prefix);
    XtFree (terminals);
}

/**********************************************************
* Retrieve and display information about a device, either
* from a .dev file, or from the circuit part of a NELSIS database.
*/
void ReadDeviceModel ()
{
    int pos;
    char *DeviceFile, *deviceName, *string, *s, *marker, *DbaseWithDevMod;
    FILE *fp;

    if (XmToggleButtonGetState (DeviceModelWin->DevModFromFile_Tggl)) {
	/* read device from ".dev" device file */
	string = trim (XmTextFieldGetString (DeviceModelWin->DevModFromFile_Txt));
	/* for uniformity below, allocate DeviceFile such that the
	 * same freeing-command can be used always (DISPOSE instead of XtFree)
	 */
	DeviceFile = strsave (string);
	XtFree (string);
    }
    else {   /* read device from file integrated in database-cell */
	/* Get device or cell name */
	deviceName = trim (XmTextFieldGetString (DeviceModelWin->DevModFromDbase_Txt));
	if (!deviceName || !*deviceName) {
	    XtFree (deviceName);
	    return;
	}
	/* Get name of database containing device model */
	DbaseWithDevMod = trim (XmTextFieldGetString (DeviceModelWin->DbaseWithDevMod_Txt));
	if (!DbaseWithDevMod || !*DbaseWithDevMod) {
	    XtFree (DbaseWithDevMod);
	    return;
	}
	DeviceFile = strsave (mprintf ("%s/circuit/%s/devmod", DbaseWithDevMod, deviceName));
	XtFree (DbaseWithDevMod);
	XtFree (deviceName);
    }

    if (!(fp = fopen (DeviceFile, "r"))) {
	PopupMessageBox (mprintf ("Cannot open device file\n%s\nfor reading!", DeviceFile));
	DISPOSE (DeviceFile, 0);
	return;
    }
    DISPOSE (DeviceFile, 0);

    XmTextSetString (DeviceModelWin->DevModFormal_Txt, (char*)"");
    XmTextFieldSetString (DeviceModelWin->DevModInformal_Txt, (char*)"");
    XmTextFieldSetString (DeviceModelWin->DevModTerminals_Txt, (char*)"");
    XmTextFieldSetString (DeviceModelWin->DevModPrefix_Txt, (char*)"");
    pos = 0;

    while (fgets (globalTextBuffer, sizeof (globalTextBuffer), fp) != NULL) {
	if (strstr (globalTextBuffer, "end") == globalTextBuffer)
	    break;
	else if (strstr (globalTextBuffer, "begin spicemod\n") == globalTextBuffer)
	    continue;
	else if (strstr (globalTextBuffer, "device ") == globalTextBuffer) {
	    deviceName = globalTextBuffer + strlen ("device ");
	    while (isspace (*deviceName)) ++deviceName;
	    marker = deviceName;
	    while (isgraph (*marker)) ++marker;
	    *marker = '\0';
	    XmTextFieldSetString (DeviceModelWin->DeviceName_Txt, deviceName);
	}
	else if (strstr (globalTextBuffer, "* terminals") == globalTextBuffer) {
	    marker = globalTextBuffer + strlen ("* terminals");
	    if ((s = strchr (marker, '\n'))) *s = '\0';
	    while (isspace (*marker)) ++marker;
	    XmTextFieldSetString (DeviceModelWin->DevModTerminals_Txt, marker);
	}
	else if (strstr (globalTextBuffer, "* prefix") == globalTextBuffer) {
	    marker = globalTextBuffer + strlen ("* prefix");
	    if ((s = strchr (marker, '\n'))) *s = '\0';
	    while (isspace (*marker)) ++marker;
	    XmTextFieldSetString (DeviceModelWin->DevModPrefix_Txt, marker);
	}
	else if (strstr (globalTextBuffer, "* description") == globalTextBuffer) {
	    marker = globalTextBuffer + strlen ("* description");
	    if ((s = strchr (marker, '\n'))) *s = '\0';
	    while (isspace (*marker)) ++marker;
	    XmTextFieldSetString (DeviceModelWin->DevModInformal_Txt, marker);
	}
	else {
	    XmTextInsert (DeviceModelWin->DevModFormal_Txt, pos, globalTextBuffer);
	    pos += strlen (globalTextBuffer);
	}
    }

    if (pos) /* set position back to begin of formal text */
	XmTextShowPosition(DeviceModelWin->DevModFormal_Txt, 0);

    fclose (fp);
}

/*
** X-Designer Stub ToggleEnableWidget
*/

/********************************************************************
* Enables or disables ("grays out") a widget, depending on the state
* of the toggle button widget that calls this functions.
*/
void ToggleEnableWidget (Widget , XtPointer client_data, XtPointer xt_call_data)
{
    XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data;

    XtSetSensitive (*(Widget *)client_data, call_data->set ? TRUE : FALSE);
}

/*
** X-Designer Stub ToggleWidget
*/

void ToggleWidget (Widget , XtPointer client_data, XtPointer )
{
	XmToggleButtonSetState (*(Widget *)client_data, TRUE, TRUE);
}

/*
** X-Designer Stub ToggleLoadForms
*/

void ToggleLoadForms (Widget , XtPointer , XtPointer )
{
	loadAlsoOpenForms = !loadAlsoOpenForms;
}

/*
** X-Designer Stub TogglePrompt
*/

void TogglePrompt (Widget w, XtPointer , XtPointer )
{
    XmString label;
    char auxLabel[30];

    ++promptType; promptType %= 5;
    sprintf (auxLabel, "Change prompt (%d)", promptType);
    label = XmStringCreateLtoR (auxLabel, csDEFAULT);
    XtVaSetValues (w, XmNlabelString, label, NULL);
    XmStringFree (label);
}

/*************************************************************
* Indicate in the menu bar the number of programs that are
* currently launched via the GUI (and still running).
*/
void IndicateRun (int index)
{
    XmString label;
    char auxLabel[30];

    if (index) {
        if (index == 1)
            sprintf (auxLabel, "1 program running");
        else
            sprintf (auxLabel, "%2d programs running", index);
	label = XmStringCreateLtoR (auxLabel, csDEFAULT);
        XtVaSetValues (Shell->RunIndicator_Lbl, XmNlabelString, label, NULL);
        XmStringFree (label);
        XtMapWidget (Shell->RunIndicator_Lbl);
    }
    else {
        XtUnmapWidget (Shell->RunIndicator_Lbl);
    }
    XFlush (XtDisplay (Shell->Shell));
    return;
}

/****************************************************************
* Update the Job Control window: text of commandlines, and
* sensitivity of [Terminate] buttons.
*/
void UpdateJobControlWindow (int slotNr, int empty, char *cmdLine)
{
    Widget j = 0, t = 0;

    switch (slotNr) {
	case 0: t = JobControlWin->Job0_Txt; j = JobControlWin->StopJob0; break;
	case 1: t = JobControlWin->Job1_Txt; j = JobControlWin->StopJob1; break;
	case 2: t = JobControlWin->Job2_Txt; j = JobControlWin->StopJob2; break;
	case 3: t = JobControlWin->Job3_Txt; j = JobControlWin->StopJob3; break;
	case 4: t = JobControlWin->Job4_Txt; j = JobControlWin->StopJob4; break;
    }
    if (t) {
	XmTextFieldSetString (t, cmdLine? cmdLine : (char *)"");
	XtSetSensitive (t, empty? FALSE : TRUE);
	XtSetSensitive (j, empty? FALSE : TRUE);
    }
}

/****************************************************************************
*  Adds a string to the Program Output window.
*  Reduces text stored there if larger than certain limit.
*/
void AddToOutputWindow (char *text)
{
    XmTextPosition WorkAreaPos;

    WorkAreaPos = XmTextGetLastPosition (Shell->WorkArea_Frame->WorkAreaText);
    if ((int) WorkAreaPos > MAX_BUFSIZE - BUFSIZ) {
        XmTextReplace (Shell->WorkArea_Frame->WorkAreaText, 0, BUFSIZ - 1, (char*)"");
        WorkAreaPos = XmTextGetLastPosition (Shell->WorkArea_Frame->WorkAreaText);
    }
    XmTextInsert (Shell->WorkArea_Frame->WorkAreaText, WorkAreaPos, text);

    /* Take care that added text is display (by scrolling). */
    WorkAreaPos = XmTextGetLastPosition (Shell->WorkArea_Frame->WorkAreaText);
    XmTextShowPosition(Shell->WorkArea_Frame->WorkAreaText, WorkAreaPos);

    XFlush (XtDisplay (Shell->Shell));
}

/*******************************************************************
* If the display&edit-option for the command line is switched on,
* a window showing the command line in a text field is popped up.
* Otherwise, the command line is directly submitted for processing.
*/
void SubmitCmdLine (char *cmdLine)
{
    if (ShowCommandLine.value) {
        XmTextFieldSetString (CmdLineWin->CmdLine_Txt, cmdLine);
        BringUpWindow (CmdLineWin->CmdLineWin, CmdLineWin->CmdLineDialog, NO_OPERATION);
    }
    else
        ExecuteSpaceCommand (cmdLine, NULL, ListCells);
}

/*
** X-Designer Stub DefaultsWholeForm
*/

/********************************************************
* Set the factory default for all items on the form
* identified by  (int) client_data
*/
void DefaultsWholeForm (Widget , XtPointer client_data, XtPointer )
{
    long item = (long) client_data;
    if (UserDefaultFlag)
	AdmWindow ((int) item, SET_U_DEF);
    else if (GeneralDefaultFlag)
	AdmWindow ((int) item, SET_G_DEF);
    else
	AdmWindow ((int) item, SET_F_DEF);
}

/*
** X-Designer Stub ApplyDefault
*/

/************************************************************************
* If "Set User/Factory Default" toggle in "Options" menu is switched on,
* set the corresponding default for eligible items when they activated or
* taking focus.
*/
void ApplyDefault (Widget , XtPointer client_data, XtPointer )
{
    long item = (long) client_data;
    if (FactoryDefaultFlag)
	AdmVariable ((int) item, SET_F_DEF, NULL);
    else if (UserDefaultFlag)
	AdmVariable ((int) item, SET_U_DEF, NULL);
    else if (GeneralDefaultFlag)
	AdmVariable ((int) item, SET_G_DEF, NULL);
}

/*
** X-Designer Stub ToggleGeneralDefault
*/

/********************************************************
* Toggle "Set General Default" in "Options" menu.
*/
void ToggleGeneralDefault (Widget , XtPointer , XtPointer xt_call_data)
{
    XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data;
    if (call_data->set) {
        UserDefaultFlag = FactoryDefaultFlag = 0;
        XmToggleButtonSetState (Shell->SetUserDflt_Tggl, FALSE, TRUE);
        XmToggleButtonSetState (Shell->SetFactoryDflt_Tggl, FALSE, TRUE);
        GeneralDefaultFlag = 1;
        ChangeCursor (1);
    }
    else {
        GeneralDefaultFlag = 0;
        ChangeCursor (0);
    }
}

/*
** X-Designer Stub ToggleFactoryDefault
*/

/********************************************************
* Toggle "Set Factory Default" in "Options" menu.
*/
void ToggleFactoryDefault (Widget , XtPointer , XtPointer xt_call_data)
{
    XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data;
    if (call_data->set) {
        UserDefaultFlag = GeneralDefaultFlag = 0;
        XmToggleButtonSetState (Shell->SetUserDflt_Tggl, FALSE, TRUE);
        XmToggleButtonSetState (Shell->SetGeneralDflt_Tggl, FALSE, TRUE);
        FactoryDefaultFlag = 1;
        ChangeCursor (1);
    }
    else {
        FactoryDefaultFlag = 0;
        ChangeCursor (0);
    }
}

/*
** X-Designer Stub ToggleUserDefault
*/

/********************************************************
* Toggle "Set User Default" in "Options" menu.
*/
void ToggleUserDefault (Widget , XtPointer , XtPointer xt_call_data)
{
    XmToggleButtonCallbackStruct *call_data = (XmToggleButtonCallbackStruct *) xt_call_data;
    if (call_data->set) {
        FactoryDefaultFlag = GeneralDefaultFlag = 0;
        XmToggleButtonSetState (Shell->SetFactoryDflt_Tggl, FALSE, TRUE);
        XmToggleButtonSetState (Shell->SetGeneralDflt_Tggl, FALSE, TRUE);
        UserDefaultFlag = 1;
        ChangeCursor (1);
    }
    else {
        UserDefaultFlag = 0;
        ChangeCursor (0);
    }
}

/*************************************************************************
* Change cursor appearance in Shell window and all its pop-up children
*/
void ChangeCursor (int activateDefault)
{
    Display *display = XtDisplay (Shell->Shell);
    int i;
    if (activateDefault) {
        FDflt_cursor = XCreateFontCursor (display, XC_dot);
        for (i = 0; i < (int) (Shell->Shell->core.num_popups); i++) {
            if (XtIsRealized (Shell->Shell->core.popup_list[i])) {
                XDefineCursor (display, XtWindow (Shell->Shell->core.popup_list[i]), FDflt_cursor);
            }
        }
    }
    else {
        for (i = 0; i < (int) (Shell->Shell->core.num_popups); i++) {
            if (XtIsRealized (Shell->Shell->core.popup_list[i])) {
                XUndefineCursor (display, XtWindow (Shell->Shell->core.popup_list[i]));
            }
        }
    }
    XFlush (XtDisplay (Shell->Shell));
}

/*
** X-Designer Stub VariablesFromWindow
*/

/************************************************************************
* Read changed settings and parameter values from a window, and transfer
* the settings to the internally used variables.  The window is identified
* by an integer; see option.h for mnemonic names.
*/
void VariablesFromWindow (Widget , XtPointer client_data, XtPointer )
{
    long item = (long) client_data;
	AdmWindow ((int) item, ACC_VALUES);
}

/*
** X-Designer Stub terminateProgramCallback
*/

/*****************************************************************
* Terminate the program with the indicated slot number.
*/
void terminateProgramCallback (Widget , XtPointer client_data, XtPointer )
{
    long item = (long) client_data;
	terminateProgram ((int) item);
}

/*
** X-Designer Stub XResistorVersusFe
*/

/***************************************************************
*  Realize radio-button behavior for the FeMesh toggle versus
*  the toggles of the resistance form in the XspaceWin.
*/
void XResistorVersusFe (Widget w, XtPointer , XtPointer )
{
    if (XmToggleButtonGetState (w)) {
	if (w == XspaceWin->XFeMesh_Tggl) {
	    XmToggleButtonSetState (XspaceWin->XEquiPot_Tggl, FALSE, FALSE);
	    XmToggleButtonSetState (XspaceWin->XOutputRes_Tggl, FALSE, FALSE);
	    XmToggleButtonSetState (XspaceWin->XResistor_Tggl, FALSE, FALSE);
	}
	else
	    XmToggleButtonSetState (XspaceWin->XFeMesh_Tggl, FALSE, FALSE);
    }
}

/*
** X-Designer Stub XLayoutVersus3d
*/

/************************************************************************
* Realize radio-button behavior for some toggle buttons in the XspaceWin.
*/
void XLayoutVersus3d (Widget w, XtPointer , XtPointer )
{
    if (XmToggleButtonGetState (w)) {
	if (w == XspaceWin->X3d_Tggl) {
	    XmToggleButtonSetState (XspaceWin->XTileBound_Tggl, FALSE, FALSE);
	    XmToggleButtonSetState (XspaceWin->XTiles_Tggl, FALSE, FALSE);
	    XmToggleButtonSetState (XspaceWin->XInputEdge_Tggl, FALSE, FALSE);
	}
	else
	    XmToggleButtonSetState (XspaceWin->X3d_Tggl, FALSE, FALSE);
    }
}

/*
** X-Designer Stub CmdWinButtonsCallback
*/

/**********************************************************************
* Submit command line, add it to the command history, and clear the
* command line (for [Run] button), or only clear the command line
* ([Cancel] button).  Also take care of command execution after <return>
* is pressed when the command line window is active.
*/
void CmdWinButtonsCallback (Widget w, XtPointer , XtPointer )
{
    XmString xmstring, *items = NULL;
    char *cmdLine;
    int item_count;
    Arg args[2];

    if (w == CmdLineWin->CmdWinClose_Bttn) {
        ShowCommandLine.value = 0;
        XtUnmanageChild(CmdLineWin->CmdLineDialog);
    }
    else {
        cmdLine = XmTextFieldGetString (CmdLineWin->CmdLine_Txt);
	if (w != CmdLineWin->CmdCancel_Bttn && cmdLine && *cmdLine) {
	    xmstring = XmStringCreateLtoR (cmdLine, csDEFAULT);
            XmListAddItem (CmdLineWin->CommandHistory, xmstring, 0);

            // Allow only a certain number of items in the command history list
            XtSetArg (args[0], XmNitemCount, &item_count);
            XtSetArg (args[1], XmNitems, &items);
            XtGetValues (CmdLineWin->CommandHistory, args, 2);
            if (item_count > 20) {
                XmListDeleteItem (CmdLineWin->CommandHistory, *items);
            }
	    XmListSetBottomPos (CmdLineWin->CommandHistory, 0);

            XmStringFree (xmstring);
            ExecuteSpaceCommand (cmdLine, NULL, ListCells);
        }
        XtFree (cmdLine);
        XmTextFieldSetString (CmdLineWin->CmdLine_Txt, (char*)"");
    }
}

/*
** X-Designer Stub CommandHistoryCallback
*/

/*********************************************************************************
*  Insert the selected command from the history list into the command-text-field.
*/
void CommandHistoryCallback (Widget w, XtPointer , XtPointer xt_call_data)
{
    XmListCallbackStruct *call_data = (XmListCallbackStruct *) xt_call_data;
    char *cmdLine;
    if (XmStringGetLtoR (call_data->item, csDEFAULT, &cmdLine)) {
        XmTextFieldSetString (CmdLineWin->CmdLine_Txt, cmdLine);
        XmListDeselectItem (w, call_data->item);
    }
    XtFree (cmdLine);
}

/*
** X-Designer Stub ConfirmCallback
*/

/*************************************************************
* Executes command after explicit confirmation by the user.
*/
void ConfirmCallback (Widget , XtPointer client_data, XtPointer )
{
    if ((long) client_data) { /* OK */
        if (ConfirmedCommandInfo.cmdLine) {
            ExecuteSpaceCommand(ConfirmedCommandInfo.cmdLine, ConfirmedCommandInfo.tempFileName,
                                ConfirmedCommandInfo.callOnCompletion);
        }
        else if (ConfirmedCommandInfo.callOnCompletion) {
            ConfirmedCommandInfo.callOnCompletion();
        }
    }
    else if (ConfirmedCommandInfo.callOnDenial){
        ConfirmedCommandInfo.callOnDenial();
    }
    if (ConfirmedCommandInfo.cmdLine)
        DISPOSE (ConfirmedCommandInfo.cmdLine, 0);
    if (ConfirmedCommandInfo.tempFileName)
        DISPOSE (ConfirmedCommandInfo.tempFileName, 0);
    ConfirmedCommandInfo.callOnCompletion = NULL;
    ConfirmedCommandInfo.callOnDenial = NULL;
}

/*****************************************************************
* Popup the confirmation window with appropriate title-text.
*/
void PopupConfirmWin (char *text)
{
    XmString label;
    label = XmStringCreateLtoR (text, csDEFAULT);
    XtVaSetValues (ConfirmWin->Confirm_Lbl, XmNlabelString, label, NULL);
    XmStringFree (label);
    XtManageChild (ConfirmWin->ConfirmDialog);
}

/*
** X-Designer Stub CloseQuickRefWin
*/

/****************************************************************
* Close quick reference window
*/
void CloseQuickRefWin (Widget , XtPointer , XtPointer )
{
	ShowQuickReference.value = 0;
	XtUnmanageChild(QuickRefWin->QuickRefDialog);
}

/*
** X-Designer Stub FileSelectionOKCallback
*/

/*******************************************************************************
* The same file selection widget is used for selecting all files and directories
* as needed.  The purpose of file selection is indicated in the window title.
* From that title the present callback also infers what it is supposed to do.
*/
void FileSelectionOKCallback (Widget , XtPointer , XtPointer )
{
    static char *SelectedFile;
    char *string, *selectedFile;
    int i, nrOfListedItems;
    Arg args[2];
    XmString *xmstring;
    FILE *fp;

    if (SelectedFile) XtFree (SelectedFile);
    if ((SelectedFile = XmTextFieldGetString (FileSelectionWin->FileSelectionText)))
	selectedFile = strip_blanks (SelectedFile);
    else
	selectedFile = (char*)""; /* just in case */

    if (!strcmp (FileSelectorTitle, "Open Working Database")) {
        if (IsDatabase (selectedFile)) {
            new_db = strsave (selectedFile);   /* refresh the database string */
            ChangeToOtherDatabase ();
        }
        else
            PopupMessageBox (mprintf ("\"%s\"\nis no valid database.", selectedFile));
    }
    else if (!strcmp (FileSelectorTitle, "Remove Database")) {
	rem_db = selectedFile;
	ConfirmedCommandInfo.cmdLine = NULL;
	ConfirmedCommandInfo.tempFileName = NULL;
	ConfirmedCommandInfo.callOnCompletion = RemoveDatabase;
	ConfirmedCommandInfo.callOnDenial = NULL;
	PopupConfirmWin (mprintf ("Remove Database directory:\n\"%s\"\nAre you sure?", rem_db));
    }
    else if (!strcmp (FileSelectorTitle, "Database for Reading Device Model")) {
        if (IsDatabase (selectedFile)) {
            XmTextFieldSetString (DeviceModelWin->DbaseWithDevMod_Txt, selectedFile);
            XmTextFieldSetString (DeviceModelWin->DevModFromDbase_Txt, (char*)"");
        }
        else
            PopupMessageBox (mprintf ("\"%s\"\nis no valid database.", selectedFile));
    }
    else if (!strcmp (FileSelectorTitle, "Database for Library List")) {
        if (*selectedFile) {
            XmTextFieldSetString (ImportWin->ImportRemoteDatabaseText, selectedFile);

            /* If the selected project is already in the Libr.List, then
             * there too mark it as selected. */
            XtSetArg (args[0], XmNitemCount, &nrOfListedItems);
            XtSetArg (args[1], XmNitems, &xmstring);
            XtGetValues (ImportWin->ImportProjectList, args, 2);
            for (i = 0; i < nrOfListedItems; i++) {
                XmStringGetLtoR (xmstring[i], XmSTRING_DEFAULT_CHARSET, &string);
                if (!strcmp (string, selectedFile))
                    XmListSelectItem (ImportWin->ImportProjectList, xmstring[i], FALSE);
                XtFree (string);
            }
        }
    }
    else if (!strcmp (FileSelectorTitle, "Add at End of Parameter File"))
        XmTextFieldSetString (ParMisWin->ParaEnd_Txt, selectedFile);
    else if (!strcmp (FileSelectorTitle, "Add at Beginning of Parameter File"))
        XmTextFieldSetString (ParMisWin->ParaFront_Txt, selectedFile);
    else if (!strcmp (FileSelectorTitle, "Read Device Model from File")) {
        XmTextFieldSetString (DeviceModelWin->DevModFromFile_Txt, selectedFile);
        ReadDeviceModel ();
    }
    else if (!strcmp (FileSelectorTitle, "Save Device Model in File")) {
        DeviceModelSaveCallback (NULL, selectedFile, NULL);
    }
    else if (strstr (FileSelectorTitle, "Use Control File")) {
	Widget w = RetrieveOptionSPICEWin->SpiceCntrlFile_Txt;
	string = FileSelectorTitle + 16;
	if (*string) {
	    if (!strcmp (string, " for SLS"))
		w = RetrieveOptionSLSWin->SlsCntrlFile_Txt;
	    else if (!strcmp (string, " for NLE"))
		w = RetrieveOptionNLEWin->NleCntrlFile_Txt;
	    else if (!strcmp (string, " for EDIF"))
		w = RetrieveOptionEDIFWin->EdifCntrlFile_Txt;
	    else if (!strcmp (string, " for VHDL"))
		w = RetrieveOptionVHDLWin->VhdlCntrlFile_Txt;
	}
	XmTextFieldSetString (w, selectedFile);
    }
    else if (!strcmp (FileSelectorTitle, "Import Layout File"))
        XmTextFieldSetString (LoadWin->LoadFileText, selectedFile);
    else if (!strcmp (FileSelectorTitle, "Custom mask list for GDS II import"))
        XmTextFieldSetString (LoadWin->LoadOptionMaskListText, selectedFile);
    else if (!strcmp (FileSelectorTitle, "Save Program Output Window in File")) {
        if ((fp = fopen (selectedFile, "w"))) {
            string = (char *) XmTextGetString (Shell->WorkArea_Frame->WorkAreaText);
            fprintf (fp, "%s\n", string);
            fclose (fp);
            XtFree (string);
        }
        else
            PopupMessageBox (mprintf ("Cannot open file\n\"%s\"\nfor saving program output window!", selectedFile));
    }
    else if (!strcmp (FileSelectorTitle, "Element Definition Source File"))
        XmTextFieldSetString (NewTechWin->NewTechElemDef_Txt, selectedFile);
    else if (!strcmp (FileSelectorTitle, "Mask Data File"))
        XmTextFieldSetString (NewTechWin->NewTechMask_Txt, selectedFile);
    else if (!strcmp (FileSelectorTitle, "Name of New Database"))
        XmTextFieldSetString (NewDbWin->DatabaseNameText, selectedFile);
    else if (!strcmp (FileSelectorTitle, "Customized Element Definition File"))
        XmTextFieldSetString (ParMisWin->ElemDefFile_Txt, selectedFile);
    else if (!strcmp (FileSelectorTitle, "File for Retrieval Output"))
        XmTextFieldSetString (RetrieveWin->RetrievalOutputFile_Txt, selectedFile);
    else if (!strcmp (FileSelectorTitle, "File for Highlay"))
        XmTextFieldSetString (HighlayWin->Namefile_Txt, selectedFile);
    else if (!strcmp (FileSelectorTitle, "Load Settings"))
        ReadUserDefaults (selectedFile);
    else if (!strcmp (FileSelectorTitle, "Save Settings"))
        SaveUserDefaults (selectedFile);
}

/*
** X-Designer Stub AdjustSelectabilityC
*/

void AdjustSelectabilityC (Widget w, XtPointer , XtPointer )
{
    int cap_val = TRUE;

    cIndicator = 1;
    if (w == ExtractWin->CapExtractFast_Bttn) {
	XtSetSensitive (ExtractWin->CapCouplSubstr_Bttn, TRUE);
	XtSetSensitive (ParCapFastWin->CapFast_Frm, TRUE);
	XtSetSensitive (ParCapAccurateWin->CapAcc_Frm, FALSE);
    }
    else if (w == ExtractWin->CapExtractAccrt_Bttn) {
/*********************************************************************
* When accurate capacitance extraction is chosen, only 2 of the three
* types of capacitances may be chosen.  Alter the present choice
* of type of capacitance if this becomes illegal when switching to
* accurate capacitance extraction.
**********************************************************************/
	XtVaGetValues (ExtractWin->CapType_OptnMn, XmNmenuHistory, &w, NULL);
	if (w == ExtractWin->CapCouplSubstr_Bttn)
	    XtVaSetValues (ExtractWin->CapType_OptnMn, XmNmenuHistory, ExtractWin->CapAll_Bttn, NULL);
	XtSetSensitive (ExtractWin->CapCouplSubstr_Bttn, FALSE);
	XtSetSensitive (ParCapFastWin->CapFast_Frm, FALSE);
	XtSetSensitive (ParCapAccurateWin->CapAcc_Frm, TRUE);
    }
    else {
	XtSetSensitive (ParCapFastWin->CapFast_Frm, FALSE);
	XtSetSensitive (ParCapAccurateWin->CapAcc_Frm, FALSE);
	cap_val = FALSE;
	cIndicator = 0;
    }
    XtSetSensitive (ExtractWin->CapFineControl_Bttn, cap_val);
    XtSetSensitive (ExtractWin->CapType_OptnMn, cap_val);
    if (cIndicator && !rIndicator) cap_val = FALSE;
    XtSetSensitive (ExtractWin->FreqDep_Frm, cap_val);
}

/*
** X-Designer Stub AdjustSelectabilityR
*/

void AdjustSelectabilityR (Widget w, XtPointer , XtPointer )
{
    int res_val = TRUE;
    int acc_val = (w == ExtractWin->ResExtractAccrt_Bttn)? TRUE : FALSE;

    rIndicator = 1;
    if (w != ExtractWin->ResExtractFast_Bttn && w != ExtractWin->ResExtractAccrt_Bttn) {
	res_val = FALSE;
	rIndicator = 0;
    }
    XtSetSensitive (ExtractWin->ResFineControl_Bttn, res_val);
    XtSetSensitive (ExtractWin->ResType_OptnMn, res_val);
    XtSetSensitive (ParResWin->MinSheetResFrm, res_val);
    XtSetSensitive (ParResWin->MaxMeshAngleFrm, acc_val);
    if (rIndicator && !cIndicator) res_val = FALSE;
    XtSetSensitive (ExtractWin->FreqDep_Frm, res_val);
}

/*
** X-Designer Stub AdjustSelectabilityS
*/

void AdjustSelectabilityS (Widget w, XtPointer , XtPointer )
{
    int a_val = (w == ExtractWin->SubstrateAccrt_Bttn)? TRUE : FALSE;
    XtSetSensitive (ExtractWin->SubstrateResFineControl_Bttn, a_val);
    XtSetSensitive (ParSubAccrtWin->SubAcc_Frm, a_val);
}

void AdjustSelectabilitySC (Widget w, XtPointer, XtPointer)
{
    int a_val = (w == ExtractWin->SubstrateCapAccrt_Bttn)? TRUE : FALSE;
    int f_val = (w == ExtractWin->SubstrateCapFast_Bttn)? TRUE : FALSE;
    XtSetSensitive (ParSubCapAccrtWin->SubAcc_Frm, a_val);
    XtSetSensitive (ParSubCapFastWin->ParSubCapFastFrm, f_val);
    if (f_val == TRUE) a_val = TRUE;
    XtSetSensitive (ExtractWin->SubstrateCapFineControl_Bttn, a_val);
}

/*
** X-Designer Stub AdjustSelectabilityH
*/

void AdjustSelectabilityH (Widget w, XtPointer , XtPointer )
{
    int b_val = (w == ExtractWin->ApplyHeur_Bttn)? TRUE : FALSE;
    XtSetSensitive (ExtractWin->CircuitFineControlButton, b_val);
    XtSetSensitive (ParHeuristicsWin->HeuristicsValues_Frm, b_val);
}

/*
** X-Designer Stub AdjustSelectabilityF
*/

void AdjustSelectabilityF (Widget w, XtPointer , XtPointer )
{
    int b_val = (w == ExtractWin->FreqDep_Bttn)? TRUE : FALSE;
    XtSetSensitive (ExtractWin->max_frequency_text, b_val);
    XtSetSensitive (ExtractWin->max_frequency_Lbl, b_val);
    XtSetSensitive (ExtractWin->GHz_Lbl, b_val);
}

/*
** X-Designer Stub PopupFileSelectWin
*/

/******************************************************************************
* Pop-up a file selection window.  Its title is customized to reflect the
* purpose of file selection.  This title is also used by the [OK] callback
* to decide what to do with the selected file.  In some cases a filter is applied.
*/
void PopupFileSelectWin (Widget , XtPointer client_data, XtPointer )
{
    Arg args[6];
    static XmString db_lab = (XmString) NULL;
    static XmString fi_lab = (XmString) NULL;
    XmString pat;
    char *s = (char*)"*";
    int ac = 0;
    int rmDB = 0;

    strncpy (FileSelectorTitle, (char *) client_data, sizeof(FileSelectorTitle)-1);

    if (strstr (FileSelectorTitle, "Database")) {
	if (dmproject && !strcmp (FileSelectorTitle, "Remove Database")) {
	    char *t, c = 0;
	/* Go back to "OpenedDatabase/.." and select as
	** default the "OpenedDatabase" for removal.
	*/
	    if ((t = strrchr (OpenedDatabase, '/'))) {
		c = *++t;
		*t = '\0';
	    }
	    if (db_dir) XmStringFree (db_dir);
	    db_dir = XmStringCreateLtoR (OpenedDatabase, csDEFAULT);
	    if (t) *t = c;
	    rmDB = 1;
	}
	if (rmDB || FileTypeMask != XmFILE_DIRECTORY) {
	    if (FileTypeMask == XmFILE_REGULAR) {
		XmStringFree (fi_dir);
		XtVaGetValues (FileSelectionWin->FileSelectionDialog, XmNdirectory, &fi_dir, NULL);
	    }
	    if (!db_lab) db_lab = XmStringCreateLtoR ((char*)"Databases", csDEFAULT);
	    XtSetArg (args[ac], XmNfileListLabelString, db_lab); ++ac;
	    XtSetArg (args[ac], XmNfileTypeMask, XmFILE_DIRECTORY); ++ac;
	    XtSetArg (args[ac], XmNdirectory, db_dir); ++ac;
	    FileTypeMask = XmFILE_DIRECTORY;
	}
    }
    else {
	if (FileTypeMask != XmFILE_REGULAR) {
	    if (FileTypeMask == XmFILE_DIRECTORY) {
		XmStringFree (db_dir);
		XtVaGetValues (FileSelectionWin->FileSelectionDialog, XmNdirectory, &db_dir, NULL);
	    }
	    if (!fi_lab) fi_lab = XmStringCreateLtoR ((char*)"Files", csDEFAULT);
	    XtSetArg (args[ac], XmNfileListLabelString, fi_lab); ++ac;
	    XtSetArg (args[ac], XmNfileTypeMask, XmFILE_REGULAR); ++ac;
	    XtSetArg (args[ac], XmNdirectory, fi_dir); ++ac;
	    FileTypeMask = XmFILE_REGULAR;
	}
	     if (!strcmp(FileSelectorTitle, "Element Definition Source File"))	s = (char*)"*.s";
	else if (!strcmp(FileSelectorTitle, "Customized Element Definition File")) s = (char*)"*.t";
	else if (strstr (FileSelectorTitle, "Settings"))	s = (char*)"helios.default*";
	else if (strstr (FileSelectorTitle, "Device Model"))	s = (char*)"*.dev";
	else if (strstr (FileSelectorTitle, "Highlay"))		s = (char*)"*.hil";
	else if (strstr (FileSelectorTitle, "Import Layout File")) {
	    LoadLayoutFilterCallback (NULL, NULL, NULL);	s = 0;
	}
    }

    if (s) {
	pat = XmStringCreateLtoR (s, csDEFAULT);
	XtSetArg (args[ac], XmNpattern, pat); ++ac;
    }
    else pat = 0;
    XtSetValues (FileSelectionWin->FileSelectionDialog, args, ac);
    if (s) XmStringFree (pat);

    if (FileTypeMask == XmFILE_DIRECTORY) {
	ListDatabaseFilter (FileSelectionWin->FileSelectionDialog);
      if (rmDB) { /* select the "OpenedDatabase" for removal */
	pat = XmStringCreateLtoR (OpenedDatabase, csDEFAULT);
	XmListSelectItem (FileSelectionWin->FileSelectionList, pat, TRUE);
	XmStringFree (pat);
      }
    }
    BringUpWindow (FileSelectionWin->FileSelectionWin, FileSelectionWin->FileSelectionDialog, NO_OPERATION);
    XtVaSetValues (FileSelectionWin->FileSelectionWin, XmNtitle, FileSelectorTitle, NULL);
}

/********************************************************
* CurrentGMT returns the current local time (not GMT)
*/
char * CurrentGMT()
{
    static char currentTime[100];
    time_t timer = time (NULL);
    strcpy (currentTime, ctime (&timer));
    return (currentTime);
}

/********************************************************
* Check a whether a directory is a NELSIS database
*/
int IsDatabase (char *Database)
{
    return (Database && access (mprintf ("%s/%s", Database, DBRCFILE), R_OK) != -1);
}

/********************************************************
* Called by ChangeToOtherDatabase ()
*/
void ReadTechnologyDefaults ()
{
    char *TechDefaultsFile;
    static int CurrentProcessId = -1;
    int item;
    FILE *fp;

    if (CurrentProcessId != dmproject -> procid) {
	CurrentProcessId = dmproject -> procid;

	TechDefaultsFile = dmGetMetaDesignData (PROCPATH, dmproject, "space.def.p");
	if (!(fp = fopen (TechDefaultsFile, "r"))) {
	    if (!TechDefaultsFile) TechDefaultsFile = (char*)"space.def.p";
	    PopupMessageBox (mprintf (
		"The file with default technology parameters\n\"%s\"\n%s%s", TechDefaultsFile,
		"is not accessible.  Using general parameter defaults instead.\n",
		"Please check that these make sense in the present context."));
	    if (InitialSetValues) return;
	    TechDefaultsFile = (char*)"";
	}
	XmTextFieldSetString (UsedFilesWin->TechDfltFile_Txt, giveICD (TechDefaultsFile));

	Debug (fprintf (stderr, "Default parameter file = %s\n", giveICD (TechDefaultsFile)));

	for (item = EXTRACTION_OPTION; item <= LAST_EXTRACTION_PARAMETER; item++)
	    AdmVariable (item, READ_F_DEF, fp);
	if (fp) fclose (fp);
    }
}

/***********************************************************
*  Manage the status of a cell.
*
*  If "set" is given as status argument, the cell is given
*  macro status,  for "unset" as status argument, the macro
*  status of the cell is removed.
*  An integer indicating the cell status is returned.
*/
int ManageCellStatus (char *cell, int oldtype, int type, int it, IMPCELL *icle)
{
    static char msks[512];
    struct stat buf;
    DM_PROJECT *pkey;
    DM_CELL *cellKey;
    DM_STREAM *dsp;
    int old, newst, always;

    if (new_proj) { /* new project */
	DM_XDATA xdata;
	xdata.name = cell;
	interfaceremote = 0;
	old = dmGetCellStatus (dmproject, &xdata);
	timestamp = xdata.timestamp;
	if (icle && (old == 1 || xdata.celltype == DM_CT_IMPORT || type == 4)) {
	    pkey = dmOpenProject (icle->dmpath, PROJ_READ);
	    if (type == 4) {
		if (!pkey || dmStatXData (pkey, &buf)) return type;
	    }
	    else if (pkey) {
		xdata.name = icle->cellname;
		interfaceremote = 1;
		(void)dmGetCellStatus (pkey, &xdata);
		if (timestamp < xdata.timestamp) timestamp = -xdata.timestamp;
		xdata.name = cell;
	    }
	}
	else pkey = dmproject;

	if (type == -1 && it == -1) { /* get status */
	    DM_PROCDATA *mdata;
	    char *s = xdata.masks;
	    switch (xdata.interfacetype) {
	    case DM_IF_FREE: interfacetype = 1; break;
	    case DM_IF_FREEMASKS: interfacetype = 2; break;
	    default: interfacetype = 0;
	    }
	    cell_msks = msks;
	    if (*s) {
		if (pkey)
		    mdata = (DM_PROCDATA *) dmGetMetaDesignData (PROCESS, pkey);
		else
		    mdata = (DM_PROCDATA *) 0;
		if (mdata && (s = strtok (s, " "))) {
		    do {
			if (cell_msks > msks) *cell_msks++ = ' ';
			if ((old = atoi (s)) < mdata->nomasks) s = mdata->mask_name[old];
			strcpy (cell_msks, s);
			cell_msks += strlen (s);
		    } while ((s = strtok (NULL, " ")));
		    cell_msks = msks;
		}
		else strcpy (cell_msks, s);
	    }
	    else *cell_msks = '\0';
	    switch (xdata.celltype) {
	    case DM_CT_MACRO: type = 1; break;
	    case DM_CT_DEVICE: type = 2; break;
	    case DM_CT_LIBRARY: type = 3; break;
	    default: type = 0;
	    }
	    goto ret;
	}
	if (it != -1) { /* set interfacetype */
	    switch (it) {
	    case  1: xdata.interfacetype = DM_IF_FREE; break;
	    case  2: xdata.interfacetype = DM_IF_FREEMASKS; break;
	    default: xdata.interfacetype = DM_IF_STRICT;
	    }
	    if (it == 2) xdata.masks = cell_msks;
	}
	if (type != -1) { /* set celltype */
	    switch (type) {
	    case  1: xdata.celltype = DM_CT_MACRO; break;
	    case  2: xdata.celltype = DM_CT_DEVICE; break;
	    case  3: xdata.celltype = DM_CT_LIBRARY; break;
	    case  4: xdata.celltype = DM_CT_IMPORT; break;
	    default: xdata.celltype = DM_CT_REGULAR;
	    }
	}
	if (dmPutCellStatus (dmproject, &xdata))
	    PopupMessageBox ((char*)"Cannot update the database.");
ret:
	if (pkey && pkey != dmproject) dmCloseProject (pkey, COMPLETE);
	return type;
    }

    if (type == -1 && it == -1) { /* get status */
	pkey = icle? dmOpenProject (icle->dmpath, PROJ_READ) : dmproject;
	interfaceremote = (pkey != dmproject);
	timestamp = type = interfacetype = 0;
	*msks = 0;
	if (!pkey) return type;
	if (icle) cell = icle->cellname;
	cellKey = dmCheckOut (pkey, cell, WORKING, DONTCARE, LAYOUT, READONLY);
	if (cellKey) {
	    if (dmStat (cellKey, "is_macro", &buf) == 0) { /* status available */
		timestamp = buf.st_mtime;
		dsp = dmOpenStream (cellKey, "is_macro", "r");
		if (fscanf (dsp->dmfp, "%d %s", &old, msks) > 0) {
		    if (old == 1) type = interfacetype = 1;
		    if (*msks) {
			char *s = msks;
			while ((s = strchr (s, '+'))) *s = ' ';
			interfacetype = 2;
		    }
		}
		dmCloseStream (dsp, COMPLETE);
	    }
	    dmCheckIn (cellKey, COMPLETE);
	}
	old = NOdmErrorMsg;
	NOdmErrorMsg = 1;
	cellKey = dmCheckOut (pkey, cell, WORKING, DONTCARE, CIRCUIT, READONLY);
	NOdmErrorMsg = old;
	if (cellKey) {
	    if (dmStat (cellKey, "devmod", &buf) == 0) {
		if (buf.st_mtime > timestamp) timestamp = buf.st_mtime;
		type += 2;
	    }
	    dmCheckIn (cellKey, COMPLETE);
	}
	cell_msks = msks;
	if (icle) timestamp = -timestamp;
	if (pkey != dmproject) dmCloseProject (pkey, COMPLETE);
	return type;
    }

    if (icle) return type;

    always = 0;

    if (type != -1 && ((type & 2) || (oldtype & 2))) { /* set/unset device status */
	newst = ((type & 2) == 2);
	old = !newst;
	NOdmErrorMsg = 1;
	cellKey = dmCheckOut (dmproject, cell, WORKING, DONTCARE, CIRCUIT, ATTACH);
	NOdmErrorMsg = 0;
	if (cellKey) {
	    old = (dmStat (cellKey, "devmod", &buf) == 0);
	    if (old != newst) {
		if (newst) {
		    dsp = dmOpenStream (cellKey, "devmod", "w");
		    dmCloseStream (dsp, COMPLETE);
		}
		else {
		    dmUnlink (cellKey, (char*)"devmod");
		    always = 1;
		}
		old = (dmStat (cellKey, "devmod", &buf) == 0);
	    }
	    dmCheckIn (cellKey, COMPLETE);
	}
	else if (newst) {
	    DM_CELL *layCellKey;
	    DM_STREAM *ldsp;
	    long lower[2];
	    long upper[2];

	    layCellKey = dmCheckOut (dmproject, cell, ACTUAL, DONTCARE, LAYOUT, READONLY);
	    if (!layCellKey) goto cant_update;

	    cellKey = dmCheckOut (dmproject, cell, WORKING, DONTCARE, CIRCUIT, UPDATE);
	    if (!cellKey) {
		dmCheckIn (layCellKey, COMPLETE);
		goto cant_update;
	    }

	    ldsp = dmOpenStream (layCellKey, "term", "r");
	    dsp = dmOpenStream (cellKey, "term", "w");
	    cterm.term_attribute = NULL;
	    cterm.term_lower = lower;
	    cterm.term_upper = upper;
	    lower[0] = 0;  lower[1] = 0;
	if (ldsp) {
	    while (dmGetDesignData (ldsp, GEO_TERM)) {
		strcpy (cterm.term_name, gterm.term_name);
		if (gterm.nx > 0 && gterm.ny > 0) {
		    cterm.term_dim = 2;
		    upper[0] = gterm.nx - 1;  upper[1] = gterm.ny - 1;
		}
		else if (gterm.nx > 0) {
		    cterm.term_dim = 1;
		    upper[0] = gterm.nx - 1;
		}
		else if (gterm.ny > 0) {
		    cterm.term_dim = 1;
		    upper[0] = gterm.ny - 1;
		}
		else {
		    cterm.term_dim = 0;
		}
		dmPutDesignData (dsp, CIR_TERM);
	    }
	    dmCloseStream (ldsp, COMPLETE);
	}
	    dmCloseStream (dsp, COMPLETE);
	    dmCheckIn (layCellKey, COMPLETE);

	    dsp = dmOpenStream (cellKey, "devmod", "w");
	    dmCloseStream (dsp, COMPLETE);
	    dsp = dmOpenStream (cellKey, "mc", "w");
	    dmCloseStream (dsp, COMPLETE);
	    dsp = dmOpenStream (cellKey, "net", "w");
	    dmCloseStream (dsp, COMPLETE);

	    old = (dmStat (cellKey, "devmod", &buf) == 0);
	    dmCheckIn (cellKey, COMPLETE);
	}
cant_update:
	if (old != newst) PopupMessageBox ((char*)"Cannot update device status.");
    }

    if (always || (type & 1) || (oldtype & 1)) { /* set/unset macro status */
	if (type == -1) newst = (oldtype & 1);
	else newst = (type & 1);
	old = !newst;
	cellKey = dmCheckOut (dmproject, cell, WORKING, DONTCARE, LAYOUT, ATTACH);
	if (cellKey) {
	    *msks = 0;
	    old = 0;
	    if (dmStat (cellKey, "is_macro", &buf) == 0) { /* status available */
		dsp = dmOpenStream (cellKey, "is_macro", "r");
		(void)fscanf (dsp->dmfp, "%d %s", &old, msks);
		dmCloseStream (dsp, COMPLETE);
	    }
	    if (it != -1) { /* interface masks setting */
		if (strcmp (cell_msks, msks)) always = 1;
	    }
	    else cell_msks = msks; /* don't change msks! */
	    if (always) old = !newst;
	    if (old != newst && (dsp = dmOpenStream (cellKey, "is_macro", "w"))) {
		if (*cell_msks)
		    fprintf (dsp->dmfp, "%d %s\n", newst, cell_msks);
		else
		    fprintf (dsp->dmfp, "%d\n", newst);
		dmCloseStream (dsp, COMPLETE);
		old = newst;
	    }
	    dmCheckIn (cellKey, COMPLETE);
	}
	if (old != newst) PopupMessageBox ((char*)"Cannot update macro status.");
    }

    return type;
}

/******************************************************************************
* Bring up a window: If the child of the shell is not already managed, then
* do manage it, and also initialize the parameters of the window.  Otherwise,
* bring the window to the front by unmapping the shell and mapping it again.
*/
void BringUpWindow (Widget shell, Widget dialog, int label)
{
    if (XtIsManaged (dialog)) {
        XtUnmapWidget (shell);
        XtMapWidget (shell);
    }
    else {
        if (label != NO_OPERATION) AdmWindow (label, SET_VALUES);
        XtManageChild (dialog);
    }
}

/*
** X-Designer Stub AdjustRetrieve
*/

void AdjustRetrieve (Widget w, XtPointer , XtPointer )
{
    int b1, b2, b3, b4 = 0;

    if (w != RetrieveWin->RetrieveEDIFButton && w != RetrieveWin->RetrieveSLSButton &&
	w != RetrieveWin->RetrieveVHDLButton && w != RetrieveWin->RetrieveNLEButton) {
	b1 = b3 = b4 = 1; b2 = 0;
	if (w == RetrieveWin->RetrievePSTARButton) { b1 = 0; b2 = 1; }
	else if (w == RetrieveWin->RetrieveSPFButton) b1 = 0;
	else if (w == RetrieveWin->RetrieveSPEFButton) b1 = b3 = 0;

	XtSetSensitive (RetrieveOptionSPICEWin->SpiceUseNetNames_Tggl, b1);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceOmitModDef_Tggl, b1);
	XtSetSensitive (RetrieveOptionSPICEWin->PstarMiscSpecials_Frm, b2);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceUseInstNames_Tggl, b3);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceAutoBulk_Tggl, b3);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceAlwaysPBulk_Tggl, b3);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceAlwaysNBulk_Tggl, b3);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceNoUncnnct_Tggl, b3);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceNoTitle_Tggl, b3);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceFloatPatch_Tggl, b3);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceOmitModDef_Tggl, b3);
	XtSetSensitive (RetrieveOptionSPICEWin->SpiceExpandNames_Tggl, !b3);
    }
    XtSetSensitive (RetrieveOptionEDIFWin->EDIF_Frm, w == RetrieveWin->RetrieveEDIFButton);
    XtSetSensitive (RetrieveOptionNLEWin->NLE_Frm, w == RetrieveWin->RetrieveNLEButton);
    XtSetSensitive (RetrieveOptionSLSWin->SLS_Frm, w == RetrieveWin->RetrieveSLSButton);
    XtSetSensitive (RetrieveOptionVHDLWin->VHDL_Frm, w == RetrieveWin->RetrieveVHDLButton);
    XtSetSensitive (RetrieveOptionSPICEWin->SPICE_Frm, b4);
}

/*
** X-Designer Stub OpenWindow
*/

/******************************************************************************
* Pop-up a window, and sometimes perform some preparatory actions.  One of the
* main reasons for this way of implementation, rather than use of the "show"
* link of X-Designer, is to ensure that already opened windows are brought to
* the front of the display (with the aid of BringUpWindow).
*/
void OpenWindow (Widget w, XtPointer client_data, XtPointer )
{
    char *str, *path;
    char buf[BUFSIZ];
    FILE *fp;

    switch ((long) client_data) {
    case SPICE_ADVANCED_OPTION:
	XtVaGetValues (RetrieveWin->RetrieveFormat_OptnMn, XmNmenuHistory, &w, NULL);
	if (w == RetrieveWin->RetrieveEDIFButton)
	    BringUpWindow (RetrieveOptionEDIFWin->RetrieveOptionEDIFWin,
		RetrieveOptionEDIFWin->RetrieveOptionEDIFDialog, EDIF_ADVANCED_OPTION);
	else if (w == RetrieveWin->RetrieveNLEButton)
	    BringUpWindow (RetrieveOptionNLEWin->RetrieveOptionNLEWin,
		RetrieveOptionNLEWin->RetrieveOptionNLEDialog, NLE_ADVANCED_OPTION);
	else if (w == RetrieveWin->RetrieveSLSButton)
	    BringUpWindow (RetrieveOptionSLSWin->RetrieveOptionSLSWin,
		RetrieveOptionSLSWin->RetrieveOptionSLSDialog, SLS_ADVANCED_OPTION);
	else if (w == RetrieveWin->RetrieveVHDLButton)
	    BringUpWindow (RetrieveOptionVHDLWin->RetrieveOptionVHDLWin,
		RetrieveOptionVHDLWin->RetrieveOptionVHDLDialog, VHDL_ADVANCED_OPTION);
	else
	    BringUpWindow (RetrieveOptionSPICEWin->RetrieveOptionSPICEWin,
		RetrieveOptionSPICEWin->RetrieveOptionSPICEDialog, SPICE_ADVANCED_OPTION);
	AdjustRetrieve (w, NULL, NULL);
	break;
    case RETRIEVE_OPTION:
	BringUpWindow (RetrieveWin->RetrieveWin, RetrieveWin->RetrieveDialog, RETRIEVE_OPTION);
	break;
    case XSPACE:
	BringUpWindow (XspaceWin->XspaceWin, XspaceWin->XspaceDialog, XSPACE);
	break;
    case EXTRACTION_OPTION:
	BringUpWindow (ExtractWin->ExtractWin, ExtractWin->ExtractDialog, EXTRACTION_OPTION);
	break;
    case LOAD_LAYOUT_OPTION:
	BringUpWindow (LoadWin->LoadWin, LoadWin->LoadDialog, LOAD_LAYOUT_OPTION);
	break;
    case HIGHLAY:
	BringUpWindow (HighlayWin->HighlayWin, HighlayWin->HighlayDialog, HIGHLAY);
	break;
    case MATCH:
	BringUpWindow (MatchWin->MatchWin, MatchWin->MatchDialog, MATCH);
	break;
    case DEVICE_MODELS:
	BringUpWindow (DeviceModelWin->DeviceModelWin, DeviceModelWin->DeviceModelDialog, DEVICE_MODELS);
	break;
    case MISCELLANEOUS_FINE:
	DisplayDescription  (NULL, (XtPointer) "MORE_DETAILS", NULL);
	BringUpWindow (ParMisWin->ParMisWin, ParMisWin->ParMisDialog, MISCELLANEOUS_FINE);
	break;
    case CIRCUIT_REDUCTION:
	DisplayDescription  (NULL, (XtPointer) "REDUC_DETAILS", NULL);
	BringUpWindow (ParHeuristicsWin->ParHeuristicsWin, ParHeuristicsWin->ParHeuristicsDialog, CIRCUIT_REDUCTION);
	break;
    case RESISTANCE_EXTRACT:
	DisplayDescription  (NULL, (XtPointer) "RES_DETAILS", NULL);
	BringUpWindow (ParResWin->ParResWin, ParResWin->ParResDialog, RESISTANCE_EXTRACT);
	break;
    case CAPACITANCE_DETAILS:
	XtVaGetValues (ExtractWin->CapExtract_OptnMn, XmNmenuHistory, &w, NULL);
	if (w == ExtractWin->CapExtractFast_Bttn) {
	    DisplayDescription  (NULL, (XtPointer) "CAP_DETAILS", NULL);
	    BringUpWindow (ParCapFastWin->ParCapFastWin, ParCapFastWin->ParCapFastDialog, CAPACITANCE_FAST);
	}
	else if (w == ExtractWin->CapExtractAccrt_Bttn) {
	    DisplayDescription  (NULL, (XtPointer) "CAP3D_DETAILS", NULL);
	    BringUpWindow (ParCapAccurateWin->ParCapAccurateWin, ParCapAccurateWin->ParCapAccurateDialog, CAPACITANCE_ACCURATE);
	}
	break;
    case SUBSTRATE_DETAILS:
	DisplayDescription  (NULL, (XtPointer) "SUB3D_DETAILS", NULL);
	BringUpWindow (ParSubAccrtWin->ParSubAccrtWin, ParSubAccrtWin->ParSubAccrtDialog, SUBRES_ACCRT_FINE);
	break;
    case SUBSTRATECAP_DETAILS:
	XtVaGetValues (ExtractWin->SubstrateCap_OptnMn, XmNmenuHistory, &w, NULL);
	if (w == ExtractWin->SubstrateCapFast_Bttn) {
	    DisplayDescription  (NULL, (XtPointer) "SUBCAPFAST_DETAILS", NULL);
	    BringUpWindow (ParSubCapFastWin->ParSubCapFastWin, ParSubCapFastWin->ParSubCapFastDialog, SUBCAP_FAST_FINE);
	}
	else if (w == ExtractWin->SubstrateCapAccrt_Bttn) {
	    DisplayDescription  (NULL, (XtPointer) "SUBCAP3D_DETAILS", NULL);
	    BringUpWindow (ParSubCapAccrtWin->ParSubAccrtWin, ParSubCapAccrtWin->ParSubAccrtDialog, SUBCAP_ACCRT_FINE);
	}
	break;
    case DELETE_CELL:
	BringUpWindow (DeleteWin->DeleteWin, DeleteWin->DeleteDialog, NO_OPERATION);
	DeleteListCallback (NULL, (void *)"list", NULL);
	break;
    case IMPORT_OPTION:
	BringUpWindow (ImportWin->ImportWin, ImportWin->ImportDialog, NO_OPERATION);
	DisplayProjlist (NULL, NULL, NULL);
	break;
    case NEW_DATABASE:
	/* Set defaults from current database */
	XmTextFieldSetString (NewDbWin->DatabaseNameText, OpenedDatabase);
	path = 0;
	if ((str = getenv ("ICDPROCESS"))) {
	    if (!isProcessName (str)) path = str;
	}
	else if (TechnologyName) {
	    str = TechnologyName;
	}
	else if (TechnologyPath[0]) {
	    path = str = TechnologyPath;
	}
        else {
            str = (char*)"";
        }
	XmTextFieldSetString (NewDbWin->ProcessNameText, str);
	if (path)
	    sprintf (buf, "%s/default_lambda", path);
	else
	    sprintf (buf, "%s/share/lib/process/%s/default_lambda", icdpath, str);
	path = (char*)"";
	if ((fp = fopen (buf, "r"))) {
	    *buf = '\0';
	    fscanf (fp, "%s", buf);
	    fclose (fp);
	    path = lambdaStr (buf);
	}
	if (!*path) {
	    if ((str = XmTextFieldGetString (UsedFilesWin->Lambda_Txt))) {
		path = strcpy (buf, str);
		XtFree (str);
	    }
	}
	if (*path) XmTextFieldSetString (NewDbWin->LambdaText, path);
	BringUpWindow (NewDbWin->NewDbWin, NewDbWin->NewDbDialog, NO_OPERATION);
	break;
    case NEW_TECHNOLOGY:
	BringUpWindow (NewTechWin->NewTechWin, NewTechWin->NewTechDialog, NO_OPERATION);
	break;
    case ABOUT_WINDOW:
	BringUpWindow (AboutWin->AboutWin, AboutWin->AboutDialog, NO_OPERATION);
	break;
    case USED_FILES:
	BringUpWindow (UsedFilesWin->UsedFilesWin, UsedFilesWin->UsedFilesDialog, NO_OPERATION);
	break;
    case MANAGE_STATUS:
	BringUpWindow (MacroWin->MacroWin, MacroWin->MacroDialog, NO_OPERATION);
	break;
    case COMMAND_WINDOW:
	ShowCommandLine.value = 1;
	BringUpWindow (CmdLineWin->CmdLineWin, CmdLineWin->CmdLineDialog, NO_OPERATION);
	break;
    case JOB_CONTROL:
	BringUpWindow (JobControlWin->JobControlWin, JobControlWin->JobControlDialog, NO_OPERATION);
	break;
    case QUICK_REFERENCE:
	pleaseMapWidget = 1;
	DisplayDescription (NULL, (XtPointer) "QUICK_REFERENCE", NULL);
	break;
    case HELP:
	pleaseMapWidget = 1;
	DisplayDescription (NULL, (XtPointer) "HELP", NULL);
	break;
    case MANUAL_PAGE:
	BringUpWindow (ManPageWin->ManPageWin, ManPageWin->ManPageDialog, NO_OPERATION);
	break;
    }
}

/******************************************************************************
* Display a manual page using "icdman"
*/
void ShowManualPage (char *commandName)
{
    FILE *fp;
    struct stat buf;
    char *manFileName;
    char *marker, *s;
    char *description, header[22];
    XmTextPosition ManPagePos;
    int oldlen, lines;
    int empty_line = 0;

    ManPagePos = XmTextGetLastPosition (ManPageWin->ManPage_Txt);
    XmTextReplace (ManPageWin->ManPage_Txt, 0, ManPagePos, (char*)"");

    manFileName = mprintf ("%s/share/man/cat1/%s.1", icdpath, commandName);
    buf.st_size = 0;
    (void) stat (manFileName, &buf);

    oldlen = (int)(buf.st_size + 1);
    if (oldlen < 2 || !(fp = fopen (manFileName, "r"))) {
	description = strsave (mprintf ("cannot open $ICDPATH/share/man/cat1/%s.1", commandName));
	goto ret;
    }
    description = NEW (char, oldlen);
    *description = 0;
    oldlen = 0;
    lines = 0;

    while (fgets (globalTextBuffer, sizeof(globalTextBuffer), fp)) {

	if (empty_line) {
	    if (*globalTextBuffer == '\n') continue;
	    empty_line = 0;
	}
	else
	    if (*globalTextBuffer == '\n') empty_line = 1;

        /* Eliminate the sequence "_\b" from globalTextBuffer.
         * We assume that the remaining backspace characters are used
         * in combinations like "a\ba", to multiple print 'a'.
         */
        s = marker = globalTextBuffer;
        while (*marker != '\n') {
	    if (*marker < ' ' || *marker > 126) {
		if (*marker == '\b') {
		    if (*(marker-1) == *(marker+1)) marker++;
		    else if (*(marker+1) == -30 && *(marker+2) <= -120 && *(marker+3) < 0) marker += 3;
		}
		else if (*marker == -30) { /* special 3-byte chars */
		    if (*(marker+1) == -128) {
			if (*(marker+2) == -112) *s++ = '-';
			else if (*(marker+2) == -103) *s++ = '\'';
			else if (*(marker+2) == -104) *s++ = '`';
			else if (*(marker+2) < 0) *s++ = '?';
			else --marker;
			marker += 2;
		    }
		    else if (*(marker+1) == -120) {
			if (*(marker+2) == -110) *s++ = '-';
			else if (*(marker+2) < 0) *s++ = '?';
			else --marker;
			marker += 2;
		    }
		}
                marker++;
	    }
	    else if (*marker == '_' && *(marker+1) == '\b') marker += 2;
	    else *s++ = *marker++;
        }
	*s++ = *marker;
	*s = 0;

	/*
        ManPagePos = XmTextGetLastPosition (ManPageWin->ManPage_Txt);
        XmTextInsert (ManPageWin->ManPage_Txt, ManPagePos, globalTextBuffer);
	*/
	if (!oldlen) {
	    if (*globalTextBuffer == '\n') continue;
	    strncpy (header, globalTextBuffer, 20);
	    header[20] = 0;
	}
	else if (lines > 20 && strncmp (header, globalTextBuffer, 20) == 0) {
	    if (description[oldlen-1] == '\n' &&
		description[oldlen-2] == '\n') { /* skip this footer */
		oldlen -= 2;
		while (description[--oldlen] != '\n');
		description[oldlen] = 0;
		continue;
	    }
	}
	strcpy (description + oldlen, globalTextBuffer);
	oldlen += strlen (globalTextBuffer);
	++lines;
    }
    fclose (fp);
ret:
    while (oldlen && description[--oldlen] == '\n') description[oldlen] = 0;
    XmTextInsert (ManPageWin->ManPage_Txt, 0, description);
    XmTextShowPosition(ManPageWin->ManPage_Txt, 0);
    DISPOSE (description, 0);
 // unlink (manFileName);
}

/*
** X-Designer Stub DisplayManualPageCallback
*/

/*****************************************************************
* Callback for selection of manual page from index
*/
void DisplayManualPageCallback (Widget w, XtPointer , XtPointer xt_call_data)
{
    XmListCallbackStruct *call_data = (XmListCallbackStruct *) xt_call_data;
    static char *old;
    char *commandName, *s;

    XmStringGetLtoR (call_data->item, csNORMAL, &commandName);
    if ((s = strchr (commandName, ' '))) *s = '\0';
    if (old && !strcmp (old, commandName)) {
	XmListSelectItem (w, call_data->item, FALSE);
	XmTextShowPosition(ManPageWin->ManPage_Txt, 0);
    }
    else
	ShowManualPage (commandName);
    if (old) XtFree (old);
    old = commandName;
}

/*
** X-Designer Stub MenuSimeyeCallback
*/

/*****************
*  Run Simeye
*/
void MenuSimeyeCallback (Widget , XtPointer , XtPointer )
{
    char *cell;
    char *simeye;

    cell = XmTextFieldGetString (Shell->Cell_Frame->SelectedCell_Txt);

    if (!(simeye = getenv ("HELIOS_SIMEYE")))
        simeye = (char*)"simeye";
    /* Default, always use simeye, and not simeye2 (the Athena widget version).
       Since when a helios version is compiled, MOTIF is present,
       simeye can also be compiled. */

    if (cell && *cell && _dmExistCell (dmproject, cell, CIRCUIT)) {
	if (strcmp (simeye, "simeye") == 0)
	    SubmitCmdLine (mprintf ("%s -R %s", simeye, cell));
	else
	    SubmitCmdLine (mprintf ("%s %s", simeye, cell));
    }
    else
	SubmitCmdLine (mprintf ("%s", simeye));

    XtFree (cell);
}

/*
** X-Designer Stub MatchSelectNetwork
*/

void MatchSelectNetwork (Widget w, XtPointer client_data, XtPointer )
{
    char *type = (char *) client_data;
    char *cell;

    cell = XmTextFieldGetString (Shell->Cell_Frame->SelectedCell_Txt);
    if (!cell) return;
    w = strcmp (type, "nom") == 0 ? MatchWin->NomNetw_Txt : MatchWin->ActNetw_Txt;
    XmTextFieldSetString (w, cell);
    XtFree (cell);
}

/*
** X-Designer Stub MatchOKCallback
*/

void MatchOKCallback (Widget , XtPointer , XtPointer )
{
    char *cell1, *cell2;

    cell1 = trim (XmTextFieldGetString (MatchWin->NomNetw_Txt));
    cell2 = trim (XmTextFieldGetString (MatchWin->ActNetw_Txt));
    if (!cell1 || !*cell1)
        PopupMessageBox ((char*)"No nominal_network is selected!");
    else if (!cell2 || !*cell2)
        PopupMessageBox ((char*)"No actual_network is selected!");
    else if (!strcmp (cell1, cell2))
        PopupMessageBox ((char*)"Same network names are selected!");
    else {
	AdmVariable (MATCH, WRITE_PARAMS, NULL);
	ADD_TO_CMDLINE (mprintf (" %s %s", cell1, cell2));
	SubmitCmdLine (CmdLine);
    }
    XtFree (cell1);
    XtFree (cell2);
}

/*
** X-Designer Stub HighlayOKCallback
*/

void HighlayOKCallback (Widget , XtPointer , XtPointer )
{
    char *cell;

    cell = XmTextFieldGetString (Shell->Cell_Frame->SelectedCell_Txt);
    if (!cell || !*cell)
        PopupMessageBox ((char*)"No cell selected!");
    else {
	AdmVariable (HIGHLAY, WRITE_PARAMS, NULL);
	if (Namefile && !*Namefile)
	    PopupMessageBox ((char*)"No namefile specified!");
	else if (!HighlayOptEnabled)
	    PopupMessageBox ((char*)"No nets, ports or devices enabled\nfor high-lighting!");
	else {
	    ADD_TO_CMDLINE (mprintf (" %s", cell));
	    if (Namefile) ADD_TO_CMDLINE (mprintf (" %s", Namefile));
	    SubmitCmdLine (CmdLine);
	}
    }
    XtFree (cell);
}

/*
** X-Designer Stub ShowInterfaceCB
*/

void ShowInterfaceCB (Widget w, XtPointer , XtPointer )
{
    IMPCELL *icle;
    char *cell, *s;
    Arg args[2];
    XmString *xms, xmstring;
    int count, ct;

    cell = NULL;
    for (ct = 0; ct <= 3 && !cell; ++ct) {
	switch (ct) {
	case 0: w = MacroWin->RegularSetList; break;
	case 1: w = MacroWin->MacroSetList; break;
	case 2: w = MacroWin->DeviceSetList; break;
	case 3: w = MacroWin->LibrarySetList;
	}
	XtSetArg (args[0], XmNselectedItemCount, &count);
	XtSetArg (args[1], XmNselectedItems, &xms);
	XtGetValues (w, args, 2);
	if (count > 0) XmStringGetLtoR (*xms, XmSTRING_DEFAULT_CHARSET, &cell);
        XmListDeselectAllItems (w);
    }

    if (cell) {
	switch (ct) {
	case 1: XmListDeselectAllItems (MacroWin->MacroSetList);
	case 2: XmListDeselectAllItems (MacroWin->DeviceSetList);
	case 3: XmListDeselectAllItems (MacroWin->LibrarySetList);
	}
	xmstring = XmStringCreateLtoR (cell, csDEFAULT);
	XmListSelectItem (w, xmstring, FALSE);
	XmStringFree (xmstring);

	s = strchr (cell, '(');
	if (s) *(s-1) = '\0';

	icle = NULL;
	s = cell;
	if (*cell == '*') {
	    IMPCELL **icl;
	    ++cell;
	    if ((icl = getImpCellList (dmproject, (char*)LAYOUT)))
		while ((icle = *icl++))
		    if (!strcmp (icle->alias, cell)) break;
	}
	(void) ManageCellStatus (cell, -1, -1, -1, icle);
	XtFree (s);

	switch (interfacetype) {
	case  0: w = MacroWin->Strict_Bttn; break;
	case  1: w = MacroWin->Free_Bttn; break;
	case  2: w = MacroWin->FMasks_Bttn; break;
	default: w = MacroWin->Default_Bttn;
	}
	XtVaSetValues (MacroWin->Itype_OptnMn, XmNmenuHistory, w, NULL);
	XmTextFieldSetString (MacroWin->FMasks_Txt, cell_msks);
	if (timestamp) {
	    if (timestamp < 0) { /* remote */
		timestamp = -timestamp;
		s = ctime (&timestamp) + 3;
		*s = '*';
	    }
	    else { /* local */
		s = ctime (&timestamp) + 4;
	    }
	    if ((cell = strchr (s, '\n'))) *cell = '\0';
	}
	else s = (char*)"";
	XmTextFieldSetString (MacroWin->Timestamp_Txt, s);
	SetMasksText (w, NULL, NULL);
    }
}

/*
** X-Designer Stub SetInterfaceCB
*/

void SetInterfaceCB (Widget w, XtPointer , XtPointer )
{
    char *cell, *s;
    Arg args[2];
    XmString *xmstring;
    int i, count, ct, it, skip_imp;
    int ok = 0;

    cell_msks = (char*)"";
    XtVaGetValues (MacroWin->Itype_OptnMn, XmNmenuHistory, &w, NULL);
    if (w == MacroWin->Strict_Bttn) it = 0;
    else if (w == MacroWin->Free_Bttn) it = 1;
    else if (w == MacroWin->FMasks_Bttn) it = 2;
    else return;

    if (it == 2 && SetCellMasks ()) return;

    skip_imp = 0;

    for (ct = 0; ct <= 3; ++ct) {
	switch (ct) {
	case 0: w = MacroWin->RegularSetList; break;
	case 1: w = MacroWin->MacroSetList; break;
	case 2: w = MacroWin->DeviceSetList; break;
	case 3: w = MacroWin->LibrarySetList;
	}
	XtSetArg (args[0], XmNselectedItemCount, &count);
	XtSetArg (args[1], XmNselectedItems, &xmstring);
	XtGetValues (w, args, 2);
	/* set it for all selected cells */
	for (i = 0; i < count; ++i) {
	    XmStringGetLtoR (xmstring[i], XmSTRING_DEFAULT_CHARSET, &cell);
	    if (cell) {
		IMPCELL *icle = NULL;
		s = strchr (cell, '(');
		if (s) *(s-1) = '\0';
		s = cell;
		if (*cell == '*') {
		    IMPCELL **icl;
		    ++cell;
		    if ((icl = getImpCellList (dmproject, (char*)LAYOUT)))
			while ((icle = *icl++))
			    if (!strcmp (icle->alias, cell)) break;
		    if (!icle) {
			PopupMessageBox (mprintf ("Cannot find imported cell:\n\"%s\"", cell));
			goto skip;
		    }
		    else if (!new_proj) {
			skip_imp = 1;
			goto skip;
		    }
		}
		(void) ManageCellStatus (cell, ct, -1, it, icle);
		ok = 1;
skip:
		XtFree (s);
	    }
	}
    }

    if (skip_imp) PopupMessageBox ((char*)"Cannot set status for imported cells!");

    if (it == 2) XtFree (cell_msks);

    if (ok) {
	NOdmErrorMsg = 1;
	DisplayCellStatus (NULL, NULL, NULL);
	NOdmErrorMsg = 0;
    }
}

/*
** X-Designer Stub SetMasksText
*/

void SetMasksText (Widget w, XtPointer , XtPointer )
{
    XtSetSensitive (MacroWin->FMasks_Txt, w == MacroWin->FMasks_Bttn);
}

